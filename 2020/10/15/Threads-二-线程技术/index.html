<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(二)线程技术"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(二)线程技术 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程成本-Thread-Costs"><span class="toc-number">1.</span> <span class="toc-text">线程成本(Thread Costs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程技术的使用"><span class="toc-number">2.</span> <span class="toc-text">线程技术的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread"><span class="toc-number">2.1.</span> <span class="toc-text">NSThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建detached-thread"><span class="toc-number">2.1.1.</span> <span class="toc-text">创建detached thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过NSThread对象来使用线程"><span class="toc-number">2.1.2.</span> <span class="toc-text">通过NSThread对象来使用线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置线程的属性"><span class="toc-number">2.1.3.</span> <span class="toc-text">配置线程的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用NSObject生成线程"><span class="toc-number">2.2.</span> <span class="toc-text">使用NSObject生成线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写线程入口例程-Thread-Entry-Routine"><span class="toc-number">2.3.</span> <span class="toc-text">编写线程入口例程 Thread Entry Routine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建-Autorelease-Pool"><span class="toc-number">2.3.1.</span> <span class="toc-text">创建 Autorelease Pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置异常处理程序-Exception-Handler"><span class="toc-number">2.3.2.</span> <span class="toc-text">设置异常处理程序 Exception Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置Run-Loop"><span class="toc-number">2.3.3.</span> <span class="toc-text">设置Run Loop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终止线程Terminating-a-Thread"><span class="toc-number">2.4.</span> <span class="toc-text">终止线程Terminating a Thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">3.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">30</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(二)线程技术</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>当应用程序生成一个新线程时，该线程成为应用程序进程空间中的一个独立实体。每个线程都有自己的执行堆栈，并由内核分别计划在运行时运行。</p>
<a id="more"></a>

<p>一个线程可以与其他线程和其他进程通信，执行I/O操作，以及执行您可能需要它执行的任何其他操作。然而，由于它们位于同一进程空间内，单个应用程序中的所有线程共享相同的虚拟内存空间，并且具有与进程本身相同的访问权限。</p>
<h2 id="线程成本-Thread-Costs"><a href="#线程成本-Thread-Costs" class="headerlink" title="线程成本(Thread Costs)"></a>线程成本(Thread Costs)</h2><p>线程在 <code>内存使用</code> 和 <code>性能方面</code> 给程序(和系统)带来了实际成本。每个线程都需要在<code>内核内存空间</code> 和 <code>程序的内存空间</code>中分配内存。</p>
<p>管理线程 和 协调协调调度 所需的核心结构使用有线内存(<code>wired memory</code>)存储在内核中。<br>线程的栈空间(<code>stack space</code>) 和 每个线程的数据 存储在程序的内存空间中(<code>program’s memory space.</code>)。这些结构中的大多数都是在您首次创建线程时 创建和初始化的，由于需要与内核进行交互，这个过程可能相对昂贵。</p>
<p>如下表量化了与在应用程序中创建新的用户级线程相关的大约成本。创建线程的时间成本是一个粗略的近似值，仅应用于彼此的相对比较。线程创建时间可能因处理器负载、计算机速度以及可用系统和程序内存量而有很大差异。</p>
<table>
<thead>
<tr>
<th>项</th>
<th>大约成本</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Kernel data structures</td>
<td>大约1KB</td>
<td>此内存用于存储线程数据结构和属性，其中大部分作为有线内存(<code>wired memory</code>)分配，因此无法分页到磁盘。</td>
</tr>
<tr>
<td>Stack space</td>
<td>512KB(子线程)；<br>8MB(Mac OS主线程)；<br>1MB(iOS主线程)</td>
<td>子线程允许的最小<code>stack size</code>为16kb，<code>stack size</code>必须为4kb的倍数。在线程创建时，此内存空间会在进程空间中预留，但是与该内存相关联的实际页面直到需要时才创建。</td>
</tr>
<tr>
<td>Creation time</td>
<td>约90微秒</td>
<td>此值反映了创建线程的初始调用到线程的入口点例程开始执行之间的时间。这些数字是通过分析在基于Intel的iMac上创建线程时生成的平均值和中间值确定的，iMac上有一个2GHz的酷睿双核处理器和运行OSXV10.5的1GB内存。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：由于具有底层内核支持，<code>operation objects</code>通常可以更快地创建线程。它们不是每次都从头创建线程，而是使用内核中已经存在的线程池(<code>pools of threads</code>)，以节省分配时间。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="noopener">参见并发编程指南Concurrency Programming Guide</a>。</p>
</blockquote>
<p>编写线程代码时要考虑的另一个成本是生产成本(<code>production costs</code>)。</p>
<p>设计线程化应用程序有时需要对组织应用程序数据结构的方式进行根本性的更改。为了避免使用同步，可能需要进行这些更改，同步本身可能会对设计不良的应用程序造成巨大的性能损失。设计这些数据结构，调试线程代码中的问题，可能会增加开发线程化应用程序所需的时间。但是，如果您的线程花费太多时间在等待锁或不执行任何操作，避免这些成本可能会在运行时造成更大的问题。</p>
<h2 id="线程技术的使用"><a href="#线程技术的使用" class="headerlink" title="线程技术的使用"></a>线程技术的使用</h2><p>创建低级线程相对简单。在任何情况下，都必须有一个函数或方法作为线程的主要入口点，并且必须使用一个可用的线程例程来启动线程。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>如果希望在自己的执行线程中运行<code>Objective-C</code>方法，请使用<code>NSThread</code>，适用于iOS 2.0+，在OS X v10.5之前，主要使用 <a href="https://developer.apple.com/documentation/foundation/nsthread" target="_blank" rel="noopener">NSThread</a> 类来生成线程。</p>
<p><code>NSThread</code>类支持类似于<code>NSOperation</code>的语义，用于监视线程的运行时条件。您可以使用这些语义来取消线程的执行，或者确定线程是否仍在执行或已完成其任务。</p>
<p>可以定义<code>NSThread</code>的子类并覆盖<code>main</code>方法来实现你的线程的<code>main</code>入口点。如果覆盖了<code>main</code>，则不需要通过调用<code>super</code>来调用继承的行为。</p>
<p>当您需要执行冗长的任务但又不想阻止应用程序其余部分的执行时，线程特别有用。可以使用线程来避免阻塞应用程序的主线程，主线程处理 用户界面 和 事件 相关的操作。线程还可以用来将一个大的作业划分成几个小的作业，这可以提高多核计算机的性能。</p>
<p>以下通过系统提供的方法来使用 <code>NSThread</code></p>
<h4 id="创建detached-thread"><a href="#创建detached-thread" class="headerlink" title="创建detached thread"></a>创建detached thread</h4><p><code>detached thread</code> 意味着当线程退出时，系统会自动回收线程的资源。这种方式只能在线程运行后从线程本身访问一些线程属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个线程,不需要启动它执行</span></span><br><span class="line"><span class="comment">* target 和 object 将在执行期间被保留，然后被释放。</span></span><br><span class="line"><span class="comment">* 所有版本的OS X都支持此方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(detachRun:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@"detach thread的参数"</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)detachRun:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"detachRun == %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"detachRun ==%@"</span>, str);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(detachPerform:) withObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"添加额外的执行-%@"</span>, str]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(detachPerformOther:) onThread:[<span class="built_in">NSThread</span> currentThread] withObject:<span class="string">@"传递到当前thread"</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)detachPerform:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, str, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)detachPerformOther:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, str, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">detachRun == &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000234740</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">detachRun ==detach thread的参数</span><br><span class="line">添加额外的执行-detach thread的参数, &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000234740</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">传递到当前thread, &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002317040</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过NSThread对象来使用线程"><a href="#通过NSThread对象来使用线程" class="headerlink" title="通过NSThread对象来使用线程"></a>通过NSThread对象来使用线程</h4><p>在<code>OS X v10.5</code>中，添加了对创建<code>NSThread</code>对象的支持，而无需立即产生相应的新线程。此支持使得可以在启动线程之前获取和设置各种线程属性。这也使得以后可以使用该线程对象来引用正在运行的线程。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)dosome:(<span class="built_in">NSString</span> *)str;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dosome:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@===%@"</span>, [<span class="built_in">NSThread</span> currentThread], <span class="keyword">self</span>.name, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createThread1&#123;</span><br><span class="line">    <span class="comment">/** 创建 NSThread 对象</span></span><br><span class="line"><span class="comment">     *  @param1 target：目标对象</span></span><br><span class="line"><span class="comment">     *  @param2 selector：该消息选择器 将发送到 目标对象。selector只能有一个参数，不能有返回值。</span></span><br><span class="line"><span class="comment">     *  @param3 object：传递给目标对象的参数，可以为nil</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(baseRun:) object:@<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程的基本属性</span></span><br><span class="line">    thread.name = <span class="string">@"oneThread"</span>;</span><br><span class="line">    <span class="comment">/* 线程的优先级</span></span><br><span class="line"><span class="comment">     * 取值范围 0.0~1.0，1.0是最高优先级，cpu调度该线程的可能性大。这个范围内的优先级映射到操作系统的优先级值。</span></span><br><span class="line"><span class="comment">     * 一个“典型的”线程优先级可能是0.5，但是由于优先级是由内核确定的，因此不能保证此值实际上是多少。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    thread.threadPriority = <span class="number">0.8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步生成新线程，并在新线程上调用接收方的主方法。</span></span><br><span class="line">    [thread start];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果您有一个NSThread对象，该对象的线程当前正在运行，则可以向该线程发送一条消息。</span></span><br><span class="line">    <span class="comment">// 此方法不适用于进行线程之间的时间紧迫或频繁通信</span></span><br><span class="line">    <span class="keyword">self</span>.p.name = <span class="string">@"小明"</span>;</span><br><span class="line">    [<span class="keyword">self</span>.p performSelector:<span class="keyword">@selector</span>(dosome:) onThread:thread withObject:<span class="string">@"线程间通讯参数-小明"</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.p.name = <span class="string">@"小红"</span>;</span><br><span class="line">    [<span class="keyword">self</span>.p performSelector:<span class="keyword">@selector</span>(dosome:) onThread:[<span class="built_in">NSThread</span> mainThread] withObject:<span class="string">@"线程间通讯参数-小红"</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)baseRun:(<span class="built_in">NSNumber</span> *)num &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"传递参数 = %@"</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在给定的时间间隔内休眠线程，当线程被阻塞时，不会发生运行循环处理。</span></span><br><span class="line">    <span class="comment">// [NSThread sleepForTimeInterval:2.0];</span></span><br><span class="line">    <span class="comment">// 阻塞当前线程，直到指定的时间</span></span><br><span class="line">    [<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">2.0</span>]];</span><br><span class="line">    <span class="comment">// [NSThread sleepUntilDate:[NSDate distantFuture]];</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"过了2秒后，%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动当前线程的runloop，该方法后面的内容将不会被执行</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"因为启动了 run loop 不会执行！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传递参数 &#x3D; 8</span><br><span class="line">&lt;NSThread: 0x6000038ea900&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;, 小红&#x3D;&#x3D;&#x3D;线程间通讯参数-小红</span><br><span class="line">过了2秒后，&lt;NSThread: 0x600003881f00&gt;&#123;number &#x3D; 5, name &#x3D; oneThread&#125;</span><br><span class="line">&lt;NSThread: 0x600003881f00&gt;&#123;number &#x3D; 5, name &#x3D; oneThread&#125;, 小红&#x3D;&#x3D;&#x3D;线程间通讯参数-小明</span><br></pre></td></tr></table></figure>

<p>如果有一个NSThread对象的线程当前正在运行，则 <code>performSelector:onThread:withObject:waitUntilDone:</code>是线程间通信的一种方便方式。使用此技术发送的消息由另一个线程直接执行，作为其正常运行循环处理的一部分，这确实意味着目标线程必须在其运行循环中运行。</p>
<h4 id="配置线程的属性"><a href="#配置线程的属性" class="headerlink" title="配置线程的属性"></a>配置线程的属性</h4><p><strong>1、<code>Stack Size</code></strong></p>
<p>对于您创建的每个新线程，系统都会在您的进程空间中分配特定数量的内存，作为该线程的栈(<code>stack</code>)。栈(<code>stack</code>)管理栈帧(<code>stack frames</code>)，也是线程的任何局部变量声明的地方。所有线程技术都提供了设置堆栈大小的某种方法，如下对于<code>NSThread</code>的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程堆栈的大小，以kb为单位，必须为4的倍数。</span></span><br><span class="line"><span class="comment">// 若要更改堆栈大小，必须在启动线程之前设置此属性。</span></span><br><span class="line">thread.stackSize = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、配置线程本地存储</strong></p>
<p>每个线程都维护一个键值对字典，可以从线程中的任何位置访问该字典。可以使用此字典来存储希望在整个线程执行过程中保持的信息。例如：使用它存储要在线程 <code>run loop</code> 的多次迭代中保留的状态信息。如下对于<code>NSThread</code>的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以向该对象添加线程所需的任何键</span></span><br><span class="line">thread.threadDictionary[<span class="string">@"tag"</span>] = <span class="string">@"action"</span>;</span><br><span class="line">thread.threadDictionary[<span class="string">@"num"</span>] = @<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3、设置线程的 Detached State</strong></p>
<p>默认情况下，大多数高级线程技术都会创建分离线程(<code>detached threads</code>)。在大多数情况下，<code>detached threads</code>是首选的，因为它们允许系统在线程完成后立即释放线程的数据结构。</p>
<p><code>detached threads</code>也不需要与程序进行显式交互。从线程中检索结果的方法由您自行决定。相比之下，系统不会为可连接线程(<code>joinable threads</code>)回收资源，直到另一个线程显式连接该线程，这个进程可能阻塞执行连接的线程。</p>
<p>可以将<code>joinable threads</code>看作<code>child threads</code>，尽管它们仍然作为独立线程运行，但 <code>joinable thread</code> 必须由另一个线程连接，然后系统才能回收其资源。<code>joinable thread</code> 还提供了一种将数据从退出线程传递到另一个线程的显式方法。在连接退出之前，<code>joinable thread</code>可以将数据指针或其他返回值传递给<code>pthread_exit</code>函数。然后，另一个线程可以通过调用<code>pthread_join</code>函数来声明此数据。</p>
<blockquote>
<p>注意：<br>在应用程序退出时，<code>detached threads</code>可以立即终止，但<code>joinable threads</code>不能。在允许进程退出之前，必须连接每个<code>joinable threads</code>。因此，在线程正在做一些不应中断的关键工作时，例如将数据保存到磁盘时，<code>joinable threads</code>可能更可取。</p>
<p>如果您确实想创建<code>joinable threads</code>，那么唯一的方法就是使用<code>POSIX</code>线程。</p>
</blockquote>
<p><strong>4、设置线程优先级 Thread Priority</strong></p>
<p>创建的任何新线程都有一个与之关联的默认优先级。内核的调度算法在确定要运行的线程时会考虑线程优先级，优先级较高的线程比优先级较低的线程更有可能运行。较高的优先级不能保证线程有特定的执行时间，只是与较低优先级的线程相比，调度程序更有可能选择它。</p>
<blockquote>
<p>注意：通常最好将线程的优先级保留为默认值。</p>
</blockquote>
<h3 id="使用NSObject生成线程"><a href="#使用NSObject生成线程" class="headerlink" title="使用NSObject生成线程"></a>使用NSObject生成线程</h3><p>在iOS和osxv10.5及更高版本中，所有<code>NSObject</code>对象都能够生成一个新线程，并使用它来执行其中一个方法。使用 <code>performSelectorInBackground:withObject:</code>创建一个分离线程(<code>detached thread</code>)，此方法与 <code>NSThread</code>的<code>detachNewThreadSelector:toTarget:withObject:</code>方法效果相同。新线程使用默认配置立即生成并开始运行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObj performSelectorInBackground:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h3 id="编写线程入口例程-Thread-Entry-Routine"><a href="#编写线程入口例程-Thread-Entry-Routine" class="headerlink" title="编写线程入口例程 Thread Entry Routine"></a>编写线程入口例程 Thread Entry Routine</h3><p>在大多数情况下，线程的入口点例程会做一些：初始化数据结构，做一些工作或可选地设置<code>run loop</code>，并在线程代码完成后进行清理。根据您的设计，在编写入门例程时可能需要采取一些额外的步骤。</p>
<h4 id="创建-Autorelease-Pool"><a href="#创建-Autorelease-Pool" class="headerlink" title="创建 Autorelease Pool"></a>创建 Autorelease Pool</h4><p>在 <code>Objective-C</code> 框架中链接的应用程序通常必须在每个线程中至少创建一个<code>Autorelease Pool</code>。</p>
<p>如果应用程序使用托管模型(<code>managed model</code>)（应用程序在其中处理对象的保留和释放），则<code>Autorelease Pool</code>将 捕获 从该线程自动释放的所有对象。</p>
<p>如果应用程序使用垃圾收集(<code>garbage collection</code>)而不是托管内存模型(<code>managed memory model</code>)，则不需要创建<code>Autorelease Pool</code>。</p>
<p>如果代码模块必须同时支持<code>garbage collection</code>和<code>managed memory model</code>的情况下，必须存在<code>Autorelease Pool</code>以支持<code>managed memory model</code>代码。</p>
<p>如果您的应用程序使用<code>managed memory model</code>，创建<code>Autorelease Pool</code>应该是您在线程入口例程中所做的第一件事。同样，销毁这个<code>Autorelease Pool</code>应该是你在线程中做的最后一件事。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadRoutine &#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init]; <span class="comment">// 顶级池</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Do thread work here.</span></span><br><span class="line">    </span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为顶级自动释放池在线程退出之前不会释放其对象，所以长寿命线程(<code>long-lived threads</code>)应该创建额外的自动释放池来更频繁地释放对象。例如，使用<code>run loop</code>的线程可能会每次通过该<code>run loop</code>创建和释放自动释放池。更频繁地释放对象可以防止应用程序的内存占用过大，从而导致性能问题。但是，与任何与性能相关的行为一样，您应该度量代码的实际性能，并适当地调整自动释放池的使用。</p>
<p>有关内存管理和自动释放池，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">Advanced Memory Management Programming Guide.</a></p>
<h4 id="设置异常处理程序-Exception-Handler"><a href="#设置异常处理程序-Exception-Handler" class="headerlink" title="设置异常处理程序 Exception Handler"></a>设置异常处理程序 Exception Handler</h4><p>如果您的应用程序捕获并处理了异常(<code>catches and handles exceptions</code>)，则应准备好线程代码以捕获可能发生的任何异常。虽然最好在异常可能发生的地方处理异常，但如果未能在线程中捕获抛出的异常，则会导致应用程序退出。</p>
<p>在线程输入例程(<code>thread entry routine</code>)中安装 <code>final</code> <code>try/catch</code>可以捕获任何未知异常并提供适当的响应。有关在<code>Objective-C</code>中设置如何引发和捕获异常的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i" target="_blank" rel="noopener">Exception Programming Topics</a></p>
<h4 id="设置Run-Loop"><a href="#设置Run-Loop" class="headerlink" title="设置Run Loop"></a>设置Run Loop</h4><p>在编写要在单独线程上运行的代码时，您有两个选项。</p>
<p>第一种选择是将线程的代码作为一个长任务来编写，以在很少或没有中断的情况下执行，并在线程完成后退出；</p>
<p>第二个选项是将线程放入<code>loop</code>，并在请求到达时动态处理请求。第一个选项不需要为代码进行特殊设置；您只需开始做您想做的工作。然而，第二个选项涉及设置线程的<code>run loop</code>。</p>
<p><code>OS X</code>和<code>iOS</code>为每个线程中实现<code>run loop</code>提供内置支持。应用程序框架会自动启动应用程序主线程的<code>run loop</code>。如果您创建任何辅助线程，则必须配置<code>run loop</code>并手动启动它。</p>
<p>有关使用和配置运行循环的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Run Loop</a>。</p>
<h3 id="终止线程Terminating-a-Thread"><a href="#终止线程Terminating-a-Thread" class="headerlink" title="终止线程Terminating a Thread"></a>终止线程Terminating a Thread</h3><p>退出线程的推荐方法是让线程正常退出它的入口点例程。尽管<code>Cocoa</code>、<code>POSIX</code>和<code>Multiprocessing Services</code>提供了直接杀死线程的例程，但强烈反对使用这些例程。终止线程会阻止该线程在其自身之后进行清理。线程分配的内存可能会泄漏，线程当前使用的任何其他资源可能无法正常清理，从而在以后造成潜在问题。</p>
<p>如果您预计需要在操作过程中终止线程，则应从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到了此类消息。如果确实有消息要求线程退出，则该线程将有机会执行所需的清理并正常退出；否则，它只需返回工作并处理下一块数据。</p>
<p>响应<code>cancel messages</code>的一种方法是使用<code>run loop input source</code>来接收此类消息。如下示例显示了该代码在线程的主入口例程(<code>main entry routine</code>)中的结构（该示例仅显示了主循环部分，并且不包括设置<code>autorelease pool</code>或配置要执行的实际工作的步骤。）该示例在<code>run loop</code>上安装了一个<code>custom input source</code>，该输入源可能可以从另一个线程发送消息。在完成全部工作量的一部分后，线程会短暂运行<code>run loop</code>，以查看消息是否到达输入源。如果不是，则<code>run loop</code>立即退出，循环继续进行下一个工作块。因为处理程序无法直接访问<code>exitNow</code>局部变量，所以退出条件通过线程字典中的键值对传达。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> moreWorkToDo = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> exitNow = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSRunLoop</span>* runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add the exitNow BOOL to the thread dictionary.</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>* threadDict = [[<span class="built_in">NSThread</span> currentThread] threadDictionary];</span><br><span class="line">    [threadDict setValue:[<span class="built_in">NSNumber</span> numberWithBool:exitNow] forKey:<span class="string">@"ThreadShouldExitNow"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Install an input source.</span></span><br><span class="line">    [<span class="keyword">self</span> myInstallCustomInputSource];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (moreWorkToDo &amp;&amp; !exitNow)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do one chunk of a larger body of work here.</span></span><br><span class="line">        <span class="comment">// Change the value of the moreWorkToDo Boolean when done.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Run the run loop but timeout immediately if the input source isn't waiting to fire.</span></span><br><span class="line">        [runLoop runUntilDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check to see if an input source handler changed the exitNow value.</span></span><br><span class="line">        exitNow = [[threadDict valueForKey:<span class="string">@"ThreadShouldExitNow"</span>] boolValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2" target="_blank" rel="noopener">Threading Programming Guide</a></p>
<p><a href="http://www.devtalking.com/archives/page/10/" target="_blank" rel="noopener">程序员说</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/15/Threads-%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/">http://yoursite.com/2020/10/15/Threads-%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/18/Threads-%E4%B8%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Threads(三)并发编程</span></a></div><div class="next-post pull-right"><a href="/2020/10/15/Threads-%E4%B8%80-%E6%A6%82%E5%BF%B5/"><span>Threads(一)概念</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>