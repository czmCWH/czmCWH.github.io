<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(二)创建线程"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(二)创建线程 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程成本-Thread-Costs"><span class="toc-number">1.</span> <span class="toc-text">线程成本(Thread Costs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程技术的使用"><span class="toc-number">2.</span> <span class="toc-text">线程技术的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread"><span class="toc-number">2.1.</span> <span class="toc-text">NSThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用NSObject生成线程"><span class="toc-number">2.2.</span> <span class="toc-text">使用NSObject生成线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的属性"><span class="toc-number">3.</span> <span class="toc-text">线程的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-Stack-Size"><span class="toc-number">3.1.</span> <span class="toc-text">配置 Stack Size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置线程本地存储"><span class="toc-number">3.2.</span> <span class="toc-text">配置线程本地存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置线程的-Detached-State"><span class="toc-number">3.3.</span> <span class="toc-text">设置线程的 Detached State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置-Thread-Priority"><span class="toc-number">3.4.</span> <span class="toc-text">设置 Thread Priority</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编写-Thread-Entry-Routine"><span class="toc-number">4.</span> <span class="toc-text">编写 Thread Entry Routine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Autorelease-Pool"><span class="toc-number">4.1.</span> <span class="toc-text">创建 Autorelease Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置异常处理程序-Exception-Handler"><span class="toc-number">4.2.</span> <span class="toc-text">设置异常处理程序 Exception Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置Run-Loop"><span class="toc-number">4.3.</span> <span class="toc-text">设置Run Loop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止线程Terminating-a-Thread"><span class="toc-number">5.</span> <span class="toc-text">终止线程Terminating a Thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">6.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(二)创建线程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>当应用程序生成一个新线程时，该线程成为应用程序进程空间中的一个独立实体。每个线程都有自己的执行栈，并由内核分别计划在运行时运行。</p>
<a id="more"></a>

<p>一个线程可以与其他线程和其他进程通信，执行I/O操作，以及执行您可能需要它执行的任何其他操作。然而，由于它们位于同一进程空间内，单个应用程序中的所有线程共享相同的虚拟内存空间，并且具有与进程本身相同的访问权限。</p>
<h2 id="线程成本-Thread-Costs"><a href="#线程成本-Thread-Costs" class="headerlink" title="线程成本(Thread Costs)"></a>线程成本(Thread Costs)</h2><ul>
<li>线程在 <code>内存使用</code> 和 <code>性能方面</code> 给程序(和系统)带来了实际成本。每个线程都需要在<code>内核内存空间</code> 和 <code>程序的内存空间</code>中分配内存。</li>
</ul>
<p>管理线程和协调其调度所需的核心结构 使用<code>wired memory</code>(有线内存)存储在内核中。<br>线程的<code>stack space</code>(栈空间) 和 每个线程的数据 存储在<code>program’s memory space</code>(程序的内存空间中)。大多数这些结构都是在你首次创建线程时创建和初始化的，由于需要与内核进行交互，这个过程可能相对昂贵。</p>
<p>如下表量化了与在应用程序中创建新的用户级线程相关的大约成本。其中一些成本是可配置的，例如为辅助线程分配的堆栈空间量。创建线程的时间成本是一个粗略的近似值，仅应用于彼此的相对比较。线程创建时间可能因处理器负载、计算机速度以及可用系统和程序内存量而有很大差异。</p>
<table>
<thead>
<tr>
<th>项</th>
<th>大约成本</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Kernel data structures</td>
<td>大约1KB</td>
<td>此内存用于存储线程数据结构和属性，其中大部分作为有线内存(<code>wired memory</code>)分配，因此无法分页到磁盘。</td>
</tr>
<tr>
<td>Stack space</td>
<td>512KB(子线程)；<br>8MB(Mac OS主线程)；<br>1MB(iOS主线程)</td>
<td>子线程允许的最小<code>stack size</code>为16kb，<code>stack size</code>必须为4kb的倍数。在线程创建时，此内存空间会在进程空间中预留，但是与该内存相关联的实际页面直到需要时才创建。</td>
</tr>
<tr>
<td>Creation time</td>
<td>约90微秒</td>
<td>此值反映了创建线程的初始调用到线程的入口点例程开始执行之间的时间。这些数字是通过分析在基于Intel的iMac上创建线程时生成的平均值和中间值确定的，iMac上有一个2GHz的酷睿双核处理器和运行OSXV10.5的1GB内存。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：由于具有底层内核支持，<code>operation objects</code>通常可以更快地创建线程。它们不是每次都从头创建线程，而是使用内核中已经存在的线程池(<code>pools of threads</code>)，以节省分配时间。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="noopener">参见并发编程指南Concurrency Programming Guide</a>。</p>
</blockquote>
<ul>
<li>编写线程代码时要考虑的另一个成本是<code>production costs</code>(生产成本)。</li>
</ul>
<p>设计<code>threaded application</code>(线程化应用程序) 有时需要对 组织应用程序数据结构的方式 进行根本性的更改。进行这些更改可能是必要的，以避免使用同步，同步本身可能会对设计不良的应用程序造成巨大的性能损失。设计这些数据结构，调试线程代码中的问题，可能会增加开发 <code>threaded application</code> 所需的时间。但是，如果你的线程花费太多时间在等待<code>locks</code>或不执行任何操作，避免这些成本(即，开发<code>threaded application</code>所需的时间)可能会在运行时造成更大的问题。</p>
<h2 id="线程技术的使用"><a href="#线程技术的使用" class="headerlink" title="线程技术的使用"></a>线程技术的使用</h2><p>创建<code>low-level threads</code>相对简单。在任何情况下，都必须有一个函数或方法作为线程的主要入口点，并且必须使用一个可用的<code>thread routines</code>(线程例程)来启动<code>thread</code>。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>如果希望在自己的执行线程中运行<code>Objective-C</code>方法，请使用 <a href="https://developer.apple.com/documentation/foundation/nsthread" target="_blank" rel="noopener">NSThread</a>，适用于<code>iOS 2.0+</code>。<code>NSThread</code>类支持类似于<code>NSOperation</code>的语义，用于监视线程的运行时条件。可以使用这些语义来取消线程的执行，或者确定线程是否仍在执行或已完成其任务。</p>
<p>可以子类化<code>NSThread</code>并重写<code>main</code>方法来实现线程的<code>main</code>入口点。。如果重写了<code>main</code>，则不需要在<code>main</code>方法中调用<code>super</code>来调用继承的行为。</p>
<p>如下有两种使用<code>NSThread</code>类创建线程的方法：</p>
<ul>
<li>方法一：<code>NSThread</code>的类方法;</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方式创建线程，只能在线程运行后访问一些线程属性</span></span><br><span class="line"><span class="comment">// 在执行该线程期间，将保留对象aTarget和anArgument，然后将其释放。</span></span><br><span class="line"><span class="comment">// aTarget 执行完 aSelector 后，将退出线程(通过exit()类方法)</span></span><br><span class="line"><span class="type">Thread</span>.detachNewThreadSelector(#selector(runAction(<span class="number">_</span>:)), toTarget: <span class="keyword">self</span>, with: <span class="string">"class func param"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">runAction</span><span class="params">(<span class="number">_</span> str: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">2.0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// class func param</span></span><br><span class="line"><span class="comment">// &lt;NSThread: 0x600000dad840&gt;&#123;number = 6, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法二：实例化<code>NSThread</code>对象，并调用其<code>start</code>方法；</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此方式无需立即生成相应的新线程，使得可以在启动线程之前获取和设置各种线程属性。</span></span><br><span class="line"><span class="keyword">let</span> thread = <span class="type">Thread</span>(target: <span class="keyword">self</span>, selector: #selector(runAction(<span class="number">_</span>:)), object: <span class="string">"target thread"</span>)</span><br><span class="line">thread.name = <span class="string">"one thread"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 线程的优先级取值范围 0.0~1.0，1.0是最高优先级，cpu调度该线程的可能性大。这个范围内的优先级映射到操作系统的优先级值。</span></span><br><span class="line"><span class="comment">// 一个“典型的”线程优先级可能是0.5，但是由于优先级是由内核确定的，因此不能保证此值实际上是多少。</span></span><br><span class="line">thread.threadPriority = <span class="number">0.8</span></span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// target thread</span></span><br><span class="line"><span class="comment">// &lt;NSThread: 0x600002985d80&gt;&#123;number = 6, name = one thread&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>iOS 10.0及以上版本，都提供了以闭包的方式创建线程</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span>.detachNewThread &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"适用于ios 10.0+; "</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> thread = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"适用于ios 10.0+，构造函数方式; "</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ul>
<li>子类化 Thread</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>: <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"执行自定义Thread，"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thread = <span class="type">MyThread</span>()</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<p>上面两种方式都会在应用程序创建一个<code>detached thread</code>(独立的线程)，<code>detached thread</code>意味着线程退出时，系统会自动回收线程的资源。这也意味着您的代码以后不必显式地与线程连接。</p>
<p>使用 <code>performSelector</code> 向正在运行的线程发送消息，该线程的 <code>run loop</code> 必须处于活动状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.perform(#selector(addAction(<span class="number">_</span>:)), on: thread, with: <span class="string">"add task"</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">runAction</span><span class="params">(<span class="number">_</span> str: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="type">Thread</span>.sleep(until: <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">2.0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">    <span class="type">RunLoop</span>.current.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">addAction</span><span class="params">(<span class="number">_</span> str: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="type">Thread</span>.current, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用NSObject生成线程"><a href="#使用NSObject生成线程" class="headerlink" title="使用NSObject生成线程"></a>使用NSObject生成线程</h3><p>在iOS和OS X v10.5及更高版本中，所有对象都可以生成新线程并使用它执行其方法。使用如下所示，使用此方法与<code>Thread</code>的<code>detachNewThreadSelector</code>效果相同，立即使用默认配置生成新线程并开始运行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.performSelector(inBackground: #selector(runAction(<span class="number">_</span>:)), with: <span class="string">"创建thread"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">runAction</span><span class="params">(<span class="number">_</span> str: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// 创建thread &lt;NSThread: 0x600000354ac0&gt;&#123;number = 5, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><p>在创建线程之后，有时甚至在创建线程之前，您可能需要配置线程环境的不同部分。以下各节描述了可以进行的一些更改以及何时进行更改。</p>
<h3 id="配置-Stack-Size"><a href="#配置-Stack-Size" class="headerlink" title="配置 Stack Size"></a>配置 Stack Size</h3><p>对于你创建的每个新线程，系统都会在你的进程空间中分配特定数量的内存，作为该线程的栈(<code>stack</code>)。栈(<code>stack</code>)管理栈帧(<code>stack frames</code>)，也是线程的任何局部变量声明的地方。</p>
<p>如果要更改给定线程的<code>stack size</code>，<strong>则必须在创建线程之前进行更改</strong>。所有线程技术都提供了设置堆栈大小的某种方法，如下对于<code>NSThread</code>的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程堆栈的大小，以kb为单位，必须为4的倍数。</span></span><br><span class="line">thread.stackSize = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="配置线程本地存储"><a href="#配置线程本地存储" class="headerlink" title="配置线程本地存储"></a>配置线程本地存储</h3><p>每个线程都维护一个键值对字典，可以从线程中的任何位置访问该字典。可以使用此字典来存储希望在整个线程执行过程中保持的信息。例如：使用它存储要在线程 <code>run loop</code> 的多次迭代中保留的状态信息。如下对于<code>NSThread</code>的设置：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以向该对象添加线程所需的任何键</span></span><br><span class="line">thread.threadDictionary[<span class="string">@"tag"</span>] = <span class="string">@"action"</span>;</span><br><span class="line">thread.threadDictionary[<span class="string">@"num"</span>] = @<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="设置线程的-Detached-State"><a href="#设置线程的-Detached-State" class="headerlink" title="设置线程的 Detached State"></a>设置线程的 Detached State</h3><p>默认情况下，大多数高级线程技术都会创建<code>detached threads</code>。在大多数情况下，<code>detached threads</code>是首选的，因为它们允许系统在线程完成后立即释放线程的数据结构。</p>
<p><code>detached threads</code>也不需要与程序进行显式交互。从线程中检索结果的方法由您自行决定。相比之下，系统不会为可连接线程(<code>joinable threads</code>)回收资源，直到另一个线程显式连接该线程，这个进程可能阻塞执行连接的线程。</p>
<p>可以将<code>joinable threads</code>看作<code>child threads</code>，尽管它们仍然作为独立线程运行，但 <code>joinable thread</code> 必须由另一个线程连接，然后系统才能回收其资源。<code>joinable thread</code> 还提供了一种将数据从退出线程传递到另一个线程的显式方法。在连接退出之前，<code>joinable thread</code>可以将数据指针或其他返回值传递给<code>pthread_exit</code>函数。然后，另一个线程可以通过调用<code>pthread_join</code>函数来声明此数据。</p>
<blockquote>
<p>注意：<br>在应用程序退出时，<code>detached threads</code>可以立即终止，但<code>joinable threads</code>不能。在允许进程退出之前，必须连接每个<code>joinable threads</code>。因此，在线程正在做一些不应中断的关键工作时，例如将数据保存到磁盘时，<code>joinable threads</code>可能更可取。</p>
<p>如果您确实想创建<code>joinable threads</code>，那么唯一的方法就是使用<code>POSIX</code>线程。</p>
</blockquote>
<h3 id="设置-Thread-Priority"><a href="#设置-Thread-Priority" class="headerlink" title="设置 Thread Priority"></a>设置 Thread Priority</h3><p>创建的任何新线程都有一个与之关联的默认优先级。内核的调度算法在确定要运行的线程时会考虑线程 <code>Priority</code>，优先级较高的线程比优先级较低的线程更有可能运行。较高的优先级不能保证线程有特定的执行时间，只是与较低优先级的线程相比，调度程序更有可能选择它。</p>
<blockquote>
<p>注意：通常最好将线程的优先级保留为默认值。增加某些线程的优先级也会增加<code>lower-priority threads</code>之间出现饥饿的可能性。如果您的应用程序包含必须相互交互的<code>high-priority</code>和<code>low-priority</code>线程，则<code>lower-priority threads</code>的饥饿可能会阻塞其他线程并造成性能瓶颈。</p>
</blockquote>
<h2 id="编写-Thread-Entry-Routine"><a href="#编写-Thread-Entry-Routine" class="headerlink" title="编写 Thread Entry Routine"></a>编写 Thread Entry Routine</h2><p>在大多数情况下，线程的<code>entry point routines</code>(入口点例程)会做一些：初始化数据结构，做一些工作或有选择地设置<code>run loop</code>，并在线程代码完成后进行清理。根据您的设计，在编写<code>entry routine</code>时可能需要采取一些额外的步骤。</p>
<h3 id="创建-Autorelease-Pool"><a href="#创建-Autorelease-Pool" class="headerlink" title="创建 Autorelease Pool"></a>创建 Autorelease Pool</h3><p>在 <code>Objective-C</code> 框架中链接的应用程序通常必须在其每个线程中至少创建一个<code>Autorelease Pool</code>。如果应用程序使用<code>managed model(</code>托管模型)——应用程序处理对象的保留和释放——<code>Autorelease Pool</code>会捕获从该线程自动释放的任何对象。</p>
<p>如果应用程序使用垃圾收集(<code>garbage collection</code>)而不是托管内存模型(<code>managed memory model</code>)，则不需要创建<code>Autorelease Pool</code>。如果代码模块必须同时支持<code>garbage collection</code>和<code>managed memory model</code>的情况下，必须存在<code>Autorelease Pool</code>以支持<code>managed memory model</code>代码。</p>
<p>如果您的应用程序使用<code>managed memory model</code>，创建<code>Autorelease Pool</code>应该是您在线程入口例程中所做的第一件事。同样，销毁这个<code>Autorelease Pool</code>应该是你在线程中做的最后一件事。此<code>pool</code>确保捕获自动释放的对象，尽管在线程本身退出之前不会释放它们。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadRoutine &#123;</span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init]; <span class="comment">// 顶级池</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Do thread work here.</span></span><br><span class="line">    </span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>top-level autorelease pool</code>在线程退出之前不会释放其对象，所以<code>long-lived threads</code>(长寿命线程)应该创建额外的<code>autorelease pools</code>来更频繁地释放对象。例如，使用<code>run loop</code>的线程可能会每次通过该<code>run loop</code>创建和释放自动释放池。更频繁地释放对象可以防止应用程序的内存占用过大，从而导致性能问题。但是，与任何与性能相关的行为一样，您应该度量代码的实际性能，并适当地调整自动释放池的使用。</p>
<p>有关内存管理和自动释放池，请查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">Advanced Memory Management Programming Guide.</a></p>
<p>对于 MRC 我们需要按照上面的方式创建线程的 <code>Autorelease Pool</code>，在 ARC 环境下，我们可以看到线程会对它入口函数中的对象进行强引用，如下所以：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"阿黄"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSome</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> thread = <span class="type">Thread</span> &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">5.0</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">self</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">        thread.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog: <span class="type">Dog?</span> = <span class="type">Dog</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"经过5秒后打印"</span>)</span><br><span class="line">dog?.doSome()</span><br><span class="line">dog = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// 经过5秒后打印</span></span><br><span class="line"><span class="comment">// 阿黄</span></span><br></pre></td></tr></table></figure>

<h3 id="设置异常处理程序-Exception-Handler"><a href="#设置异常处理程序-Exception-Handler" class="headerlink" title="设置异常处理程序 Exception Handler"></a>设置异常处理程序 Exception Handler</h3><p>如果您的应用程序<code>catches and handles exceptions</code>(捕获并处理了异常)，则应准备好线程代码以捕获可能发生的任何异常。虽然最好在异常可能发生的地方处理异常，但如果未能在线程中捕获抛出的异常，则会导致应用程序退出。</p>
<p>在<code>thread entry routine</code>中安装 <code>final</code> <code>try/catch</code>可以捕获任何未知异常并提供适当的响应。有关在<code>Objective-C</code>中设置如何引发和捕获异常的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i" target="_blank" rel="noopener">Exception Programming Topics</a></p>
<h3 id="设置Run-Loop"><a href="#设置Run-Loop" class="headerlink" title="设置Run Loop"></a>设置Run Loop</h3><p>在编写要在单独线程上运行的代码时，您有两个选项。</p>
<p>第一种选择是将线程的代码编写成一个长任务，以在很少或没有中断的情况下执行，并在线程完成后退出；第二个选项是将线程放入<code>loop</code>，并在请求到达时动态处理请求。第一个选项不需要为代码进行特殊设置，你只需开始做你想做的工作。然而，第二个选项涉及设置线程的<code>run loop</code>。</p>
<p>有关使用和配置运行循环的信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Run Loop</a>。</p>
<h2 id="终止线程Terminating-a-Thread"><a href="#终止线程Terminating-a-Thread" class="headerlink" title="终止线程Terminating a Thread"></a>终止线程Terminating a Thread</h2><p>退出线程的推荐方法是让线程正常退出它的<code>entry point routine</code>。尽管<code>Cocoa</code>、<code>POSIX</code>和<code>Multiprocessing Services</code>提供了直接杀死线程的<code>routines</code>，但强烈反对使用这些例程。终止线程会阻止该线程在其自身之后进行清理。线程分配的内存可能会泄漏，线程当前使用的任何其他资源可能无法正常清理，从而在以后造成潜在问题。</p>
<p>如果预计需要在操作过程中终止线程，则应从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着要定期停止工作并检查是否收到了此类消息。如果确实有消息要求线程退出，则该线程将有机会执行所需的清理并正常退出；否则，它只需返回工作并处理下一块数据。</p>
<p>响应<code>cancel messages</code>的一种方法是使用<code>run loop input source</code>来接收此类消息。如下示例显示了该代码在线程的主入口例程(<code>main entry routine</code>)中的结构（该示例仅显示了主循环部分，并且不包括设置<code>autorelease pool</code>或配置要执行的实际工作的步骤。）该示例在<code>run loop</code>上安装了一个<code>custom input source</code>，该输入源可能可以从另一个线程发送消息。在完成全部工作量的一部分后，线程会短暂运行<code>run loop</code>，以查看消息是否到达输入源。如果不是，则<code>run loop</code>立即退出，循环继续进行下一个工作块。因为处理程序无法直接访问<code>exitNow</code>局部变量，所以退出条件通过线程字典中的键值对传达。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> moreWorkToDo = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> exitNow = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSRunLoop</span>* runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add the exitNow BOOL to the thread dictionary.</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>* threadDict = [[<span class="built_in">NSThread</span> currentThread] threadDictionary];</span><br><span class="line">    [threadDict setValue:[<span class="built_in">NSNumber</span> numberWithBool:exitNow] forKey:<span class="string">@"ThreadShouldExitNow"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Install an input source.</span></span><br><span class="line">    [<span class="keyword">self</span> myInstallCustomInputSource];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (moreWorkToDo &amp;&amp; !exitNow)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Do one chunk of a larger body of work here.</span></span><br><span class="line">        <span class="comment">// Change the value of the moreWorkToDo Boolean when done.</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Run the run loop but timeout immediately if the input source isn't waiting to fire.</span></span><br><span class="line">        [runLoop runUntilDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check to see if an input source handler changed the exitNow value.</span></span><br><span class="line">        exitNow = [[threadDict valueForKey:<span class="string">@"ThreadShouldExitNow"</span>] boolValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2" target="_blank" rel="noopener">Threading Programming Guide</a></p>
<p><a href="http://www.devtalking.com/archives/page/10/" target="_blank" rel="noopener">程序员说</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/15/Threads-%E4%BA%8C-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/">http://yoursite.com/2020/10/15/Threads-%E4%BA%8C-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/18/Threads-%E4%B8%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Threads(三)并发编程</span></a></div><div class="next-post pull-right"><a href="/2020/10/15/Threads-%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/"><span>Threads(一)线程概述</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>