<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(六)GCD - Dispatch Sources"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(六)GCD - Dispatch Sources | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dispatch-Sources"><span class="toc-number">1.</span> <span class="toc-text">Dispatch Sources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-Dispatch-Sources"><span class="toc-number">2.</span> <span class="toc-text">创建 Dispatch Sources</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编写和安装-Event-Handler"><span class="toc-number">2.1.</span> <span class="toc-text">编写和安装 Event Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装-Cancellation-Handler"><span class="toc-number">2.2.</span> <span class="toc-text">安装 Cancellation Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更改Target-Queue"><span class="toc-number">2.3.</span> <span class="toc-text">更改Target Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将自定义数据-与-Dispatch-Source-相关联"><span class="toc-number">2.4.</span> <span class="toc-text">将自定义数据 与 Dispatch Source 相关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Sources-的内存管理"><span class="toc-number">2.5.</span> <span class="toc-text">Dispatch Sources 的内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dispatch-Source-示例"><span class="toc-number">3.</span> <span class="toc-text">Dispatch Source 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Timer"><span class="toc-number">3.1.</span> <span class="toc-text">创建 Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从Descriptor读取数据"><span class="toc-number">3.2.</span> <span class="toc-text">从Descriptor读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将数据写入-Descriptor"><span class="toc-number">3.3.</span> <span class="toc-text">将数据写入 Descriptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监控-File-System-对象"><span class="toc-number">3.4.</span> <span class="toc-text">监控 File-System 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监控信号"><span class="toc-number">3.5.</span> <span class="toc-text">监控信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监控进程"><span class="toc-number">3.6.</span> <span class="toc-text">监控进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消-Dispatch-Source"><span class="toc-number">4.</span> <span class="toc-text">取消 Dispatch Source</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂起和恢复-Dispatch-Sources"><span class="toc-number">5.</span> <span class="toc-text">挂起和恢复 Dispatch Sources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">6.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(六)GCD - Dispatch Sources</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>每当与底层系统交互时，你都必须为该任务花费大量时间做好准备。调用内核层或其他系统层涉及到上下文的更改，与在你自己的进程中发生的调用相比，该更改相当昂贵。因此，许多系统库提供异步接口，允许你的代码向系统提交请求，并在处理该请求的同时继续执行其他工作。<code>Grand Central Dispatch</code>基于此一般行为，允许你提交请求，并使用<code>blocks</code>和<code>dispatch queues</code>将结果报告回代码。</p>
<a id="more"></a>

<h2 id="Dispatch-Sources"><a href="#Dispatch-Sources" class="headerlink" title="Dispatch Sources"></a>Dispatch Sources</h2><p><code>dispatch source</code>是一种基本数据类型，用于协调特定低级系统事件的处理。<code>Grand Central Dispatch</code>支持以下类型的<code>dispatch sources</code>：</p>
<ul>
<li><p><code>Timer dispatch sources</code> 生成定期通知。</p>
</li>
<li><p>当 <code>UNIX</code> 信号到达时，<code>Signal dispatch sources</code>(信号调度源)会通知你。</p>
</li>
<li><p><code>descriptor sources</code> 会通知你各种基于文件和套接字的操作，例如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、当数据可供读取时</span><br><span class="line">2、何时可以写入数据</span><br><span class="line">3、在文件系统中删除，移动或重命名文件时</span><br><span class="line">4、文件元信息更改时</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Process dispatch sources</code>通知你与进程相关的事件，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、进程退出时</span><br><span class="line">2、当进程发出&#96;fork&#96;或&#96;exec&#96;类型的调用时</span><br><span class="line">3、当信号传递到进程时</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Mach port dispatch sources</code>会通知你与<code>Mach</code>相关的事件。</p>
</li>
<li><p><code>Custom dispatch sources</code>是你自己定义并触发的源。</p>
</li>
</ul>
<p><code>Dispatch sources</code>取代了通常用于处理与系统相关事件的异步回调函数。配置<code>dispatch source</code>时，可以指定 要监视的事件 以及 用于处理这些事件的<code>dispatch queue</code>和代码。可以使用<code>block</code>对象或函数指定代码。当感兴趣的事件到达时，<code>dispatch source</code>将你的<code>block</code>或函数提交到指定的<code>dispatch queue</code>执行。</p>
<p>与手动提交到<code>queue</code>的任务不同，<code>dispatch sources</code>为你的应用程序提供了连续的事件源。<code>dispatch source</code>将一直附加到其<code>dispatch queue</code>，直到你明确取消它为止。附加时，每当发生相应事件时，它都会将其关联的任务代码提交给<code>dispatch queue</code>。某些事件（例如<code>timer events</code>）以固定的间隔发生，但大多数事件仅在特定条件出现时才偶尔发生。因此，<code>dispatch sources``retain</code>其关联的<code>dispatch queue</code>，以防止在事件可能仍处于挂起状态时过早地释放该<code>queue</code>。</p>
<p>为了防止事件在<code>dispatch queue</code>中积压，<code>dispatch sources</code>实现了<code>event coalescing scheme</code>(事件合并方案)。如果新事件在 前一个事件的<code>event handler</code>出<code>queue</code>并执行 之前到达，则<code>dispatch source</code>将新事件中的数据与旧事件中的数据合并。根据事件的类型，合并可能会替换旧事件或更新其持有的信息。例如，<code>signal-based dispatch source</code>(基于信号的调度源)仅提供有关最新信号的信息，而且还报告自从上次调用<code>event handler</code>(事件处理程序)以来已传递了多少信号总数。</p>
<h2 id="创建-Dispatch-Sources"><a href="#创建-Dispatch-Sources" class="headerlink" title="创建 Dispatch Sources"></a>创建 Dispatch Sources</h2><p>创建<code>dispatch source</code>包括创建 事件源 和<code>dispatch source</code>本身。事件的 <code>source</code> 是处理事件所需的任何本地数据结构。例如，对于<code>descriptor-based dispatch source</code>(基于描述符的调度源)，你将需要打开描述符；对于<code>process-based source</code>(基于进程的源)，则需要获取目标程序的进程ID。有了<code>event source</code>(事件源)后，就可以按照以下方式创建相应的<code>dispatch source</code>：</p>
<p>1、使用 <code>dispatch_source_create</code> 函数创建<code>dispatch source</code></p>
<p>2、配置<code>dispatch source</code>：</p>
<ul>
<li>将<code>event handler</code>分配给<code>dispatch source</code>;</li>
<li>对于<code>timer sources</code>，请使用 <code>dispatch_source_set_timer</code> 函数设置定时器信息。</li>
</ul>
<p>3、为<code>dispatch source</code>分配一个<code>cancellation handler</code>(取消处理程序) (这一步可选)；</p>
<p>4、调用<code>dispatch_resume</code>函数开始处理事件；</p>
<p>由于 <code>dispatch sources</code> 在使用前需要进行一些额外配置，因此<code>dispatch_source_create</code> 函数以挂起状态返回 <code>dispatch sources</code>。挂起时，<code>dispatch source</code>将接收事件，但不处理它们。这使你有时间安装 <code>event handler</code> 并执行处理实际事件所需的任何其他配置。</p>
<h3 id="编写和安装-Event-Handler"><a href="#编写和安装-Event-Handler" class="headerlink" title="编写和安装 Event Handler"></a>编写和安装 Event Handler</h3><p>要处理 <code>dispatch source</code> 生成的事件，必须定义一个<code>event handle</code>(事件处理程序)来处理这些事件。<code>event handle</code>是你使用<code>dispatch_source_set_event_handler</code> 或<code>dispatch_source_set_event_handler_f</code> 函数安装在 <code>dispatch source</code> 上的函数或<code>block</code>对象。当事件到达时，<code>dispatch source</code>将你的<code>event handler</code>提交到指定的<code>dispatch queue</code>进行处理。</p>
<p><code>event handler</code>的主体负责处理所有到达的事件。如果你的 <code>event handler</code> 已经排队并且正在等待处理事件，当一个新事件到来时，则<code>dispatch source</code>将合并这两个事件。<code>event handler</code>通常只查看最新事件的信息，但根据<code>dispatch source</code>的类型，<code>event handler</code>也可以能够获取有关发生并合并的其他事件的信息。如果一个或多个新事件在<code>event handler</code>开始执行后到达，则 <code>dispatch source</code> 将保留这些事件，直到当前<code>event handler</code>完成执行为止。此时，它将使用新事件再次将<code>event handler</code>提交到队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于 block 的事件处理程序不带参数，也没有返回值。</span></span><br><span class="line"><span class="keyword">void</span> (^dispatch_block_t)(<span class="keyword">void</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基于函数的事件处理程序采用单个上下文指针，其中包含dispatch source对象，并且不返回值</span></span><br><span class="line"><span class="keyword">void</span> (*dispatch_function_t)(<span class="keyword">void</span> *)</span><br></pre></td></tr></table></figure>

<p>在<code>event handler</code>内部，可以从<code>dispatch source</code>本身获取有关给定事件的信息。尽管将<code>function-based event handlers</code>(基于函数的事件处理程序)作为参数传递了指向<code>dispatch source</code>的指针，但是<code>block-based event handlers</code>(基于块的事件处理程序)必须自己捕获该指针。可以通过正常引用包含<code>dispatch source</code>的变量来对<code>blocks</code>执行此操作。 例如，以下代码片段捕获了在<code>blocks</code>范围之外声明的<code>source</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,</span><br><span class="line">                                 myDescriptor, 0, myQueue);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">   &#x2F;&#x2F; 从捕获的源变量中获取一些数据。来自父上下文。</span><br><span class="line">   size_t estimated &#x3D; dispatch_source_get_data(source);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure>

<p>在<code>block</code>内部捕获变量通常是为了获得更大的 <code>flexibility</code>(灵活性) 和 <code>dynamism</code>(动态性)。当然，默认情况下，捕获的变量在<code>block</code>内是只读的。尽管<code>blocks</code>功能支持了在特定情况下修改捕获的变量，但不应在与<code>dispatch source</code>关联的<code>event handlers</code>中尝试这样做。<code>Dispatch sources</code>始终异步执行其<code>event handlers</code>，因此捕获的任何变量的定义范围可能在<code>event handler</code>执行时就消失了。</p>
<p>如下列出了可以从<code>event handler</code>代码中调用以获取事件信息的函数。</p>
<ul>
<li><code>dispatch_source_get_handle</code></li>
</ul>
<p>此函数返回<code>dispatch source</code>管理的基础系统数据类型。</p>
<p>对于<code>descriptor dispatch source</code>，此函数返回一个<code>int</code>类型，其中包含与<code>dispatch source</code>关联的<code>descriptor</code>(描述符)。</p>
<p>对于<code>signal dispatch source</code>，此函数返回一个<code>int</code>类型，其中包含最近事件的信号编号。</p>
<p>对于<code>process dispatch source</code>，此函数返回被监视进程的<code>pid_t</code>数据结构。</p>
<p>对于<code>Mach port dispatch source</code>，此函数返回<code>mach_port_t</code>数据结构。</p>
<p>对于其他<code>dispatch sources</code>，此函数返回的值未定义。</p>
<ul>
<li><code>dispatch_source_get_data</code></li>
</ul>
<p>此函数返回与事件关联的所有挂起数据。</p>
<p>对于从文件读取数据的<code>descriptor dispatch source</code>，此函数返回可读取的字节数。</p>
<p>对于将数据写入文件的<code>descriptor dispatch source</code>，如果有可用的写入空间，则此函数返回正整数。</p>
<p>对于监视文件系统活动的<code>descriptor dispatch source</code>，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_vnode_flags_t</code>枚举类型。</p>
<p>对于<code>process dispatch source</code>，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_proc_flags_t</code>枚举类型。</p>
<p>对于<code>Mach port dispatch source</code>，此函数返回一个常量，指示发生的事件的类型。有关常量的列表，请参见<code>dispatch_source_machport_flags_t</code>枚举类型。</p>
<p>对于<code>custom dispatch source</code>，此函数返回根据现有数据创建的新数据值，并将新数据传递给<code>dispatch_source_merge_data</code>函数。</p>
<ul>
<li><code>dispatch_source_get_mask</code></li>
</ul>
<p>此函数返回用于创建<code>dispatch source</code>的事件标志。</p>
<p>对于<code>process dispatch source</code>，此函数返回<code>dispatch source</code>接收的事件的掩码。有关常量的列表，请参见<code>dispatch_source_proc_flags_t</code>枚举类型。</p>
<p>对于具有发送权限的<code>Mach port dispatch source</code>，此函数返回所需事件的掩码。 有关常量的列表，请参见<code>dispatch_source_mach_send_flags_t</code>枚举类型。</p>
<p>对于自定义<code>OR dispatch source</code>，此函数返回用于合并数据值的掩码。</p>
<h3 id="安装-Cancellation-Handler"><a href="#安装-Cancellation-Handler" class="headerlink" title="安装 Cancellation Handler"></a>安装 Cancellation Handler</h3><p><code>Cancellation handlers</code>(取消处理程序)用于在<code>release</code> <code>dispatch source</code>之前对其进行清理。对于大多数类型的<code>dispatch sources</code>，<code>cancellation handlers</code>是可选的，并且仅当你有一些与<code>dispatch source</code>相关联的自定义行为也需要更新时，才需要<code>Cancellation handlers</code>。但是，对于使用<code>descriptor</code> 或 <code>Mach port</code>的<code>dispatch sources</code>，必须提供<code>cancellation handler</code>以关闭<code>descriptor</code>或<code>release</code> <code>Mach port</code>。否则，由于代码或系统其他部分无意识地重用了那些结构，可能导致代码中的细微错误。</p>
<p>你可以随时安装<code>cancellation handler</code>，但通常在创建<code>dispatch source</code>时会这样做。你可以使用<code>dispatch_source_set_cancel_handler</code>或<code>dispatch_source_set_cancel_handler_f</code>函数来安装<code>cancellation handler</code>，具体取决于你要在实现中使用<code>block</code>对象还是函数。</p>
<p>下面的示例显示一个简单的<code>cancellation handler</code>，它关闭为<code>dispatch source</code>打开的<code>descriptor</code>(描述符)。<code>fd</code>变量是包含<code>descriptor</code>的捕获变量。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_cancel_handler(mySource, ^&#123;</span><br><span class="line">   close(fd); &#x2F;&#x2F; Close a file descriptor opened earlier.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="更改Target-Queue"><a href="#更改Target-Queue" class="headerlink" title="更改Target Queue"></a>更改Target Queue</h3><p>尽管在创建<code>dispatch source</code>时指定了要在其上运行事件和<code>cancellation handlers</code>(取消处理程序)的队列，但可以使用<code>dispatch_set_target_queue</code>函数随时更改该<code>queue</code>。你可以这样做来更改处理<code>dispatch source</code>事件的优先级。</p>
<p>更改<code>dispatch source</code>的<code>queue</code>是异步操作，<code>dispatch source</code> 会尽最大努力尽快进行更改。如果<code>event handler</code>(事件处理程序)已经在队列中并等待处理，它将在前一个<code>queue</code>上执行。但是，在你进行更改时 到达的其它事件 可以在任一<code>queue</code>中进行处理。</p>
<h3 id="将自定义数据-与-Dispatch-Source-相关联"><a href="#将自定义数据-与-Dispatch-Source-相关联" class="headerlink" title="将自定义数据 与 Dispatch Source 相关联"></a>将自定义数据 与 Dispatch Source 相关联</h3><p>与<code>Grand Central Dispatch</code>中的许多其他数据类型一样，你可以使用<code>dispatch_set_context</code>函数将自定义数据与<code>dispatch source</code>相关联。可以使用上下文指针存储<code>event handler</code>处理事件所需的任何数据。如果确实在上下文指针中存储了任何自定义数据，则还应该安装<code>cancellation handler</code>，以便在不再需要<code>dispatch source</code>时<code>release</code>该数据。</p>
<p>如果使用<code>blocks</code>实现<code>event handler</code>(事件处理程序)，则还可以捕获局部变量并在<code>block-based code</code>(基于块的代码)中使用它们。尽管这可以减少将数据存储在<code>dispatch source</code>的上下文指针中的需要，但你应始终谨慎使用此功能。因为<code>dispatch sources</code>可能在你的应用程序中长期存在，所以在捕获包含指针的变量时应格外小心。如果可以随时释放指针所指向的数据，则应复制数据或保留数据以防止发生这种情况。无论哪种情况，你都需要提供一个<code>cancellation handler</code>，以便以后释放数据。</p>
<h3 id="Dispatch-Sources-的内存管理"><a href="#Dispatch-Sources-的内存管理" class="headerlink" title="Dispatch Sources 的内存管理"></a>Dispatch Sources 的内存管理</h3><p>像其他<code>dispatch objects</code>一样，<code>dispatch sources</code>也是<code>reference counted data types</code>(引用计数的数据类型)。<code>dispatch source</code>的初始引用计数为1，可以使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数进行保留和释放。当<code>queue</code>的引用计数达到零时，系统将自动释放<code>dispatch source</code>数据结构。</p>
<p>由于它们的使用方式，可以在<code>dispatch sources</code>本身内部或外部管理<code>dispatch sources</code>的所有权。有了外部所有权，另一个对象或代码段就拥有了<code>dispatch source</code>的所有权，并负责在不再需要时释放它。对于内部所有权，<code>dispatch source</code>拥有自己，并负责在适当的时间释放自己。尽管外部所有权很常见，但是在想要创建自主<code>dispatch source</code>，并让它管理代码的某些行为 而无需任何进一步交互的情况下，可以使用 内部所有权。例如，如果<code>dispatch source</code>被设计为响应单个全局事件，则可以让它处理该事件然后立即退出。</p>
<h2 id="Dispatch-Source-示例"><a href="#Dispatch-Source-示例" class="headerlink" title="Dispatch Source 示例"></a>Dispatch Source 示例</h2><p>以下各节说明如何创建和配置一些更常用的调度源。</p>
<h3 id="创建-Timer"><a href="#创建-Timer" class="headerlink" title="创建 Timer"></a>创建 Timer</h3><p><code>Timer dispatch sources</code>以定期、基于时间的时间间隔生成事件。可以使用<code>timer</code>来启动需要定期执行的特定任务。例如，游戏和其他图形密集型应用程序可能使用计时器来启动屏幕或动画更新。还可以设置一个<code>timer</code>，并使用产生的事件来检查频繁更新的服务器上的新信息。</p>
<p>所有<code>timer dispatch sources</code>都是<code>interval timers</code>(间隔计时器)，即一旦创建，它们就会以你指定的间隔传递常规事件。创建<code>timer dispatch source</code>时，必须指定的值之一是<code>leeway</code>(回旋值)，以使系统对<code>timer events</code>的期望精度有所了解。<code>Leeway</code>值使系统在 管理电源 和 唤醒内核 方面具有一定的灵活性。例如，系统可以使用<code>leeway</code>值来提前或延迟触发时间，并使它与其他系统事件更好地保持一致。因此，你应该尽可能为自己的<code>timers</code>指定一个<code>leeway</code>值。</p>
<blockquote>
<p>注意：即使你指定的<code>leeway</code>值为0，也永远不要期望<code>timer</code>以你要求的精确纳秒触发。该系统会尽力满足您你需求，但无法保证确切的触发时间。</p>
</blockquote>
<p>当计算机进入<code>sleep</code>状态时，所有<code>timer dispatch sources</code>都将被挂起。当计算机唤醒时，这些<code>timer dispatch sources</code>也会自动唤醒。根据<code>timer</code>的配置，这种性质的暂停可能会影响你的<code>timer</code>下次触发的时间。如果你使用<code>dispatch_time</code>函数或<code>DISPATCH_TIME_NOW</code>常量设置<code>timer dispatch source</code>，则<code>timer dispatch source</code>将使用<code>default system clock</code>(默认系统时钟)来确定何时触发。但是，当计算机处于休眠状态时，<code>default clock</code>不会提前。相比之下，当使用<code>dispatch_walltime</code>函数设置<code>timer dispatch source</code>时，<code>timer dispatch source</code>会将其触发时间跟踪到挂钟时间。后一种选项通常适用于触发间隔相对较大的<code>timers</code>，因为它可以防止事件时间之间的偏移过大。</p>
<p>创建一个<code>timer dispatch source</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者在主队列 dispatch_get_main_queue()</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1、创建 timer</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</span><br><span class="line">                                                  <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="comment">/* 2、配置timer</span></span><br><span class="line"><span class="comment">     * 参数2：表示timer开始触发的事件。由于此处timer每30秒触发一次，时间间隔较大，因此使用 dispatch_walltime</span></span><br><span class="line"><span class="comment">     * 参数3：表示timer多少秒触发一次</span></span><br><span class="line"><span class="comment">     * 参数4：表示timer的 leeway 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>), <span class="number">30</span>ull * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、设置timer的事件处理程序</span></span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4、让timer开始处理事件。dispatch_suspend 与 dispatch_resume的作用相反，用于让timer暂停</span></span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 5、存储timer的引用，避免被立即释放</span></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// &lt;NSThread: 0x600002363940&gt;&#123;number = 3, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<p>尽管创建<code>timer dispatch source</code>是接收基于时间的事件的主要方式，但也可以使用其他选项。如果要在指定的时间间隔后执行一次<code>block</code>，则可以使用<code>dispatch_after</code>或<code>dispatch_after_f</code>函数。该函数的行为与<code>dispatch_async</code>函数非常相似，不同之处在于，它允许你指定将<code>block</code>交到<code>queue</code>的时间值。可以根据需要将时间值指定为相对或绝对时间值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="从Descriptor读取数据"><a href="#从Descriptor读取数据" class="headerlink" title="从Descriptor读取数据"></a>从<code>Descriptor</code>读取数据</h3><p>要从<code>file</code>(文件)或<code>socket</code>(套接字)读取数据，必须打开<code>file</code>(文件)或<code>socket</code>(套接字)并创建<code>DISPATCH_SOURCE_TYPE_READ</code>类型的<code>dispatch source</code>。你指定的<code>event handler</code>应该能够读取和处理<code>file descriptor</code>(文件描述符)的内容。对于<code>file</code>，这相当于读取文件数据（或该数据的子集）并为你的应用程序创建适当的数据结构。对于<code>network socket</code>(网络套接字)，这涉及处理新接收到的网络数据。</p>
<p>每当读取数据时，都应始终将<code>descriptor</code>(描述符)配置为使用<code>non-blocking operations</code>(非阻塞操作)。虽然可以使用<code>dispatch_source_get_data</code>函数查看有多少数据可供读取，但是该函数返回的数字可能会在你进行调用的时间 与 你实际读取数据的时间之间发生变化。如果基础文件被截断或发生网络错误，则从当前线程中的<code>descriptor</code>(描述符)中读取数据可能会使<code>event handler</code>在执行过程中暂停，并阻止<code>dispatch queue</code>调度其他任务。对于<code>serial queue</code>，这可能会使队列死锁，甚至对于<code>concurrent queue</code>，这也会减少可以启动的新任务的数量。</p>
<p>如下示例，将<code>dispatch source</code>配置为从文件读取数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t ProcessContentsOfFile(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 准备文件开始读取</span></span><br><span class="line">   <span class="keyword">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">   <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   fcntl(fd, F_SETFL, O_NONBLOCK);  <span class="comment">// 为了确保dispatch queue在没有数据读取时不会不必要地阻塞，使用fcntl函数来避免阻塞读取操作</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">   dispatch_source_t readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,</span><br><span class="line">                                   fd, <span class="number">0</span>, queue);</span><br><span class="line">   <span class="keyword">if</span> (!readSource)</span><br><span class="line">   &#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 安装 event handler</span></span><br><span class="line">   dispatch_source_set_event_handler(readSource, ^&#123;</span><br><span class="line">      size_t estimated = dispatch_source_get_data(readSource) + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 将数据读取到文本缓冲区中</span></span><br><span class="line">      <span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)malloc(estimated);</span><br><span class="line">      <span class="keyword">if</span> (buffer)</span><br><span class="line">      &#123;</span><br><span class="line">         ssize_t actual = read(fd, buffer, (estimated));</span><br><span class="line">         Boolean done = MyProcessFileData(buffer, actual);  <span class="comment">// 通过自定义函数处理数据</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 完成后释放缓冲区</span></span><br><span class="line">         free(buffer);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 没有数据了，取消source</span></span><br><span class="line">         <span class="keyword">if</span> (done)</span><br><span class="line">            dispatch_source_cancel(readSource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 安装 cancellation handler，确保在读取数据后关闭文件描述符</span></span><br><span class="line">   dispatch_source_set_cancel_handler(readSource, ^&#123;close(fd);&#125;);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始读取文件</span></span><br><span class="line">   dispatch_resume(readSource);</span><br><span class="line">   <span class="keyword">return</span> readSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将数据写入-Descriptor"><a href="#将数据写入-Descriptor" class="headerlink" title="将数据写入 Descriptor"></a>将数据写入 Descriptor</h3><p>将数据写入<code>file</code>(文件)或<code>socket</code>(套接字)的过程与读取数据的过程非常相似。配置用于写操作的<code>descriptor</code>(描述符)之后，将创建类型为<code>DISPATCH_SOURCE_TYPE_WRITE</code>的<code>dispatch source</code>。一旦创建<code>dispatch source</code>，系统将调用你的<code>event handler</code>，使它有机会开始将数据写入<code>file</code>(文件)或<code>socket</code>(套接字)。完成数据写入后，请使用<code>dispatch_source_cancel</code>函数取消<code>dispatch source</code>。</p>
<p>每当写入数据时，都应始终将<code>file descriptor</code>(文件描述符)配置为使用<code>non-blocking operations</code>(非阻塞操作)。尽管可以使用<code>dispatch_source_get_data</code>函数查看有多少空间可供写入，但是该函数返回的值仅是建议性的，并且可能在 调用时间 和 实际写入数据的时间 之间发生变化。如果发生错误，将数据写入<code>block</code>的<code>file descriptor</code>可能会使<code>event handler</code>执行过程中暂停，并阻止<code>dispatch queue</code>调度其他任务。对于<code>serial queue</code>，这可能会使队列死锁，甚至对于<code>concurrent queue</code>，这也会减少可以启动的新任务的数量。</p>
<h3 id="监控-File-System-对象"><a href="#监控-File-System-对象" class="headerlink" title="监控 File-System 对象"></a>监控 File-System 对象</h3><p>如果要监控<code>file system object</code>(文件系统对象)的更改，则可以设置类型为<code>DISPATCH_SOURCE_TYPE_VNODE</code>的<code>dispatch source</code>。当文件被删除，写入或重命名时，可以使用这种类型的<code>dispatch source</code>来接收通知。当文件的特定类型的元信息（例如文件的大小和链接数）发生变化时，你也可以使用它来发出警报。</p>
<blockquote>
<p>注意：当<code>source</code>本身正在处理事件时，为<code>dispatch source</code>指定的<code>file descriptor</code>(文件描述符)必须保持打开状态。</p>
</blockquote>
<h3 id="监控信号"><a href="#监控信号" class="headerlink" title="监控信号"></a>监控信号</h3><p><code>UNIX signals</code>允许从其域外部对应用程序进行操作。应用程序可以接收许多不同类型的<code>signals</code>(信号)，范围从不可恢复的错误（例如非法指令）到有关重要信息的通知（例如子进程退出时）。传统上，应用程序使用<code>sigaction</code>函数来安装<code>signal handler function</code>，该功能在<code>signals</code>到达时立即对<code>signals</code>同步处理。如果你只想收到<code>signals</code>到达的通知，而实际上却不想处理该<code>signals</code>，则可以使用<code>signal dispatch source</code>来异步处理<code>signals</code>。</p>
<p><code>Signal dispatch sources</code>(信号调度源)不能替代你使用<code>sigaction</code>函数安装的<code>synchronous signal handlers</code>(同步信号处理程序)。<code>Synchronous signal handlers</code>实际上可以捕获<code>signal</code>(信号)并阻止它终止你的应用程序。<code>Signal dispatch sources</code>允许你仅监视<code>signal</code>(信号)的到达。此外，你不能使用<code>signal dispatch sources</code>来检索所有类型的<code>signal</code>(信号)。具体来说，不能使用它们来监视<code>SIGILL</code>，<code>SIGBUS</code>和<code>SIGSEGV</code>信号。</p>
<p>因为<code>signal dispatch sources</code>(信号调度源)在<code>dispatch queue</code>上异步执行，所以它们不受与<code>synchronous signal handlers</code>相同的限制。例如，你可以从<code>signal dispatch source</code>的事件处理程序中调用的函数没有任何限制。这种灵活性的权衡是，在<code>signal</code>到达的时间与<code>dispatch source</code>的事件处理程序被调用之间的延迟可能会有所增加。</p>
<p>如果你正在为自定义框架开发代码，则使用<code>signal dispatch sources</code>的优点是你的代码可以独立于与其链接的任何应用程序监控信号。<code>Signal dispatch sources</code>不会干扰应用程序可能已安装的其他<code>dispatch sources</code>或任何同步信号处理程序。</p>
<h3 id="监控进程"><a href="#监控进程" class="headerlink" title="监控进程"></a>监控进程</h3><p><code>process dispatch source</code>使你可以监视特定进程的行为并做出适当响应。父进程可以使用这种类型的<code>dispatch source</code>来监视它创建的任何子进程。例如，父进程可以使用它来监视子进程的死亡。同样，子进程可以使用它来监视其父进程并在父进程退出时退出。</p>
<p>清单4-6显示了安装调度源以监视父进程终止的步骤。 当父进程死亡时，调度源将设置一些内部状态信息，以使子进程知道应该退出。 （您自己的应用程序将需要实现MySetAppExitFlag函数，以设置适当的终止标志。）由于调度源是自动运行的，因此拥有自己的资源，因此它在预期程序关闭时也会取消并释放自身。</p>
<h2 id="取消-Dispatch-Source"><a href="#取消-Dispatch-Source" class="headerlink" title="取消 Dispatch Source"></a>取消 Dispatch Source</h2><p><code>Dispatch sources</code> 将保持活动状态，直到你使用 <code>dispatch_source_cancel</code> 函数显式取消它为止。取消<code>dispatch source</code>将停止新事件的传递，并且无法撤消。 因此，通常可以取消<code>dispatch source</code>，然后立即释放它，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RemoveDispatchSource(dispatch_source_t mySource)</span><br><span class="line">&#123;</span><br><span class="line">   dispatch_source_cancel(mySource);</span><br><span class="line">   dispatch_release(mySource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch source</code>是异步操作。尽管在调用<code>dispatch_source_cancel</code>函数之后不会处理任何新事件，但是已由<code>dispatch source</code>处理的事件将继续被处理。完成所有最终事件的处理后，如果存在<code>dispatch source</code>，则<code>dispatch source</code>将执行其<code>cancellation handler</code>(取消处理程序)。</p>
<p><code>cancellation handler</code>(取消处理程序)是你 释放内存 或 清除代表<code>dispatch source</code>获取的任何资源的机会。如果你的<code>dispatch source</code>使用<code>descriptor</code>(描述符)或<code>mach port</code>，则必须提供<code>cancellation handler</code>(取消处理程序)以关闭<code>descriptor</code>(描述符)或在发生取消时销毁<code>port</code>。其他类型的<code>dispatch sources</code>不需要<code>cancellation handlers</code>，但是如果将任何内存或数据与<code>dispatch source</code>相关联，则仍应提供<code>cancellation handlers</code>。例如，如果将数据存储在<code>dispatch source</code>的上下文指针中，则应提供一个。</p>
<h2 id="挂起和恢复-Dispatch-Sources"><a href="#挂起和恢复-Dispatch-Sources" class="headerlink" title="挂起和恢复 Dispatch Sources"></a>挂起和恢复 Dispatch Sources</h2><p>可以使用<code>dispatch_suspend</code>和<code>dispatch_resume</code>方法临时挂起和恢复<code>dispatch source</code>事件的传递。这些方法增加和减少<code>dispatch object</code>的挂起计数。因此，在恢复事件传递之前，必须平衡对<code>dispatch_suspend</code>的每个调用和匹配对<code>dispatch_resume</code>的调用。</p>
<p>当你挂起<code>dispatch source</code>时，该<code>dispatch source</code>被挂起时发生的任何事件都将被累积，直到恢复<code>queue</code>为止。当<code>queue</code>恢复时，不是传递所有事件，而是在传递之前将事件合并为单个事件。例如，如果您正在监视文件中的名称更改，则传递的事件将仅包括姓氏更改。以这种方式合并事件可以防止它们在队列中堆积，并在工作恢复时使您的应用程序不堪重负。</p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1" target="_blank" rel="noopener">Dispatch Sources</a></p>
<p><a href="http://alex1212112.github.io/" target="_blank" rel="noopener">Summerrose’s Blog * Dispatch Source</a></p>
<p><a href="https://juejin.cn/post/6844904127856640007" target="_blank" rel="noopener">多线程之GCD底层原理篇</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/23/Threads-%E5%85%AD-GCD-Dispatch-Sources/">http://yoursite.com/2020/10/23/Threads-%E5%85%AD-GCD-Dispatch-Sources/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/24/Threads-%E4%B8%83-%E8%BF%9C%E7%A6%BB%E7%BA%BF%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Threads(七)远离线程</span></a></div><div class="next-post pull-right"><a href="/2020/10/23/Threads-%E4%BA%94-GCD-Dispatch-Queues/"><span>Threads(五)GCD - Dispatch Queues</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>