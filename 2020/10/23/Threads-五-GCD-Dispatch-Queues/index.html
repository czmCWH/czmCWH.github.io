<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(五)GCD - Dispatch Queues"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(五)GCD - Dispatch Queues | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dispatch-Queues"><span class="toc-number">1.</span> <span class="toc-text">Dispatch Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Queues-的类型"><span class="toc-number">1.1.</span> <span class="toc-text">Dispatch Queues 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#串行队列"><span class="toc-number">1.1.1.</span> <span class="toc-text">串行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发队列"><span class="toc-number">1.1.2.</span> <span class="toc-text">并发队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主调度队列"><span class="toc-number">1.1.3.</span> <span class="toc-text">主调度队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-queues的优点"><span class="toc-number">1.2.</span> <span class="toc-text">dispatch queues的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列相关技术"><span class="toc-number">1.3.</span> <span class="toc-text">队列相关技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatch-groups"><span class="toc-number">1.3.1.</span> <span class="toc-text">Dispatch groups</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatch-semaphores"><span class="toc-number">1.3.2.</span> <span class="toc-text">Dispatch semaphores</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatch-sources"><span class="toc-number">1.3.3.</span> <span class="toc-text">Dispatch sources</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用block执行任务"><span class="toc-number">2.</span> <span class="toc-text">使用block执行任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建和管理-Dispatch-Queues"><span class="toc-number">3.</span> <span class="toc-text">创建和管理 Dispatch Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-Global-Concurrent-Dispatch-Queues"><span class="toc-number">3.1.</span> <span class="toc-text">获取 Global Concurrent Dispatch Queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-Serial-Dispatch-Queues"><span class="toc-number">3.2.</span> <span class="toc-text">创建 Serial Dispatch Queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在运行时获取-Common-Queues"><span class="toc-number">3.3.</span> <span class="toc-text">在运行时获取 Common Queues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Queues的内存管理"><span class="toc-number">3.4.</span> <span class="toc-text">Dispatch Queues的内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Queue-存储自定义上下文信息"><span class="toc-number">3.5.</span> <span class="toc-text">使用 Queue 存储自定义上下文信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为Queue提供清理功能"><span class="toc-number">3.6.</span> <span class="toc-text">为Queue提供清理功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向Queue添加任务"><span class="toc-number">4.</span> <span class="toc-text">向Queue添加任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#向-Queue-添加单个任务"><span class="toc-number">4.1.</span> <span class="toc-text">向 Queue 添加单个任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#向并发队列添加任务"><span class="toc-number">4.1.1.</span> <span class="toc-text">向并发队列添加任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向串行队列添加任务"><span class="toc-number">4.1.2.</span> <span class="toc-text">向串行队列添加任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向主队列添加任务"><span class="toc-number">4.1.3.</span> <span class="toc-text">向主队列添加任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完成任务时执行-Completion-Block"><span class="toc-number">4.2.</span> <span class="toc-text">完成任务时执行 Completion Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同时执行循环迭代"><span class="toc-number">4.3.</span> <span class="toc-text">同时执行循环迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在主线程上执行任务"><span class="toc-number">4.4.</span> <span class="toc-text">在主线程上执行任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在任务中使用Objective-C对象"><span class="toc-number">4.5.</span> <span class="toc-text">在任务中使用Objective-C对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#挂起和恢复队列"><span class="toc-number">5.</span> <span class="toc-text">挂起和恢复队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Dispatch-Semaphores-调节有限资源的使用"><span class="toc-number">6.</span> <span class="toc-text">使用 Dispatch Semaphores 调节有限资源的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#等待排队的任务组"><span class="toc-number">7.</span> <span class="toc-text">等待排队的任务组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dispatch-Queues和线程安全"><span class="toc-number">8.</span> <span class="toc-text">Dispatch Queues和线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">9.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">35</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(五)GCD - Dispatch Queues</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><code>Grand Central Dispatch（GCD）</code> 调度队列(<code>dispatch queues</code>)是执行任务的强大工具，它使你可以相对于调用者异步或同步地执行任意代码块。适用于 <code>ios 4.0+</code>。</p>
<a id="more"></a>

<p>与相应的线程代码相比，<code>dispatch queues</code>的优点是，使用起来更简单，能更有效地执行任务。</p>
<h2 id="Dispatch-Queues"><a href="#Dispatch-Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><ul>
<li><p><code>Dispatch queue</code> 是在应用程序中异步并发执行任务的一种简便方法。</p>
</li>
<li><p><code>task</code>(任务) 只是应用程序需要执行的一些工作，如：可以定义一个任务来执行一些计算、创建或修改数据结构、处理从文件中读取的一些数据，或者执行任意数量的操作。通过将相应的代码放置在函数或<code>block</code>对象中并将其添加到<code>dispatch queue</code>来定义任务。</p>
</li>
<li><p><code>dispatch queue</code>是一种类似对象的结构，用于管理提交给它的任务。所有<code>dispatch queue</code>都是<code>first-in, first-out</code>(先进先出)数据结构。因此，添加到队列中的任务总是按照添加时相同的顺序启动。<code>GCD</code>会自动为你提供一些<code>dispatch queues</code>，但也可以为特定目的创建其他<code>dispatch queues</code>。</p>
</li>
</ul>
<h3 id="Dispatch-Queues-的类型"><a href="#Dispatch-Queues-的类型" class="headerlink" title="Dispatch Queues 的类型"></a>Dispatch Queues 的类型</h3><h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p><code>Serial queues</code>(串行队列，又称 <code>private dispatch queues</code>) 按添加到队列的顺序一次执行一个任务。当前执行的任务运行在 <code>dispatch queue</code> 管理的不同线程上（可能因任务而异）。</p>
<p><code>Serial queues</code> 通常用于同步对特定资源的访问。可以根据需要创建任意多个<code>Serial queues</code>，并且每个队列都与所有其他队列并行运行。</p>
<h4 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h4><p><code>Concurrent queues</code>(并发队列，也称为 <code>global dispatch queue</code> 的一种) 可以并发执行一个或多个任务，但是任务仍然按照将它们添加到队列中的顺序启动。当前执行的任务在 <code>dispatch queue</code> 管理的不同线程上运行。在任何给定点执行的任务的确切数量是可变的，这取决于系统条件。</p>
<p>在<code>iOS 5</code>及更高版本中，您可以通过将 <code>DISPATCH_QUEUE_CONCURRENT</code> 指定为队列类型来自己创建 <code>concurrent dispatch queues</code>。另外，有四个预定义的全局并发队列供你的应用程序使用。</p>
<h4 id="主调度队列"><a href="#主调度队列" class="headerlink" title="主调度队列"></a>主调度队列</h4><p><code>main dispatch queue</code>是全局可用的<code>serial queue</code>，它在应用程序的主线程上执行任务。</p>
<p><code>main dispatch queue</code> 与 应用程序的<code>run loop</code>（如果存在）一起工作，将队列任务的执行 与 附加到<code>run loop</code>的其他<code>event sources</code>的执行 交织在一起。 </p>
<p>因为<code>main dispatch queue</code>在应用程序的主线程上运行，所以它通常用作应用程序的关键同步点。尽管你无需创建<code>main dispatch queue</code>，但仍需要确保您的应用程序适当地消耗它。 </p>
<h3 id="dispatch-queues的优点"><a href="#dispatch-queues的优点" class="headerlink" title="dispatch queues的优点"></a><code>dispatch queues</code>的优点</h3><p>在将并发性添加到应用程序时，<code>dispatch queues</code>比线程有几个优势。</p>
<p>1、最直接的好处是<code>work-queue programming model</code>(工作队列编程模型)的简单性。 </p>
<p>使用线程，你必须为要执行的工作以及线程本身的创建和管理编写代码。<code>Dispatch queues</code>使你可以专注于实际要执行的工作，而无需担心线程的创建和管理。相反，系统将为你处理所有线程的创建和管理。优点是系统能够比任何单个应用程序更有效地管理线程。系统可以根据 可用资源 和 当前系统状况 动态缩放线程数。此外，系统通常能够比你自己创建线程更快地开始运行任务。</p>
<p>2、<code>dispatch queues</code>编写代码通常比为线程编写代码容易</p>
<p>虽然你可能认为为<code>dispatch queues</code>改写代码很困难，但是为<code>dispatch queues</code>编写代码通常比为线程编写代码容易。编写代码的关键是 设计独立 且 能够异步运行的任务(实际上，对于线程和<code>dispatch queues</code>都是如此)。</p>
<p>3、<code>dispatch queues</code>的优势在于可预测性</p>
<p>如果有两个任务访问相同的共享资源，但在不同的线程上运行，则每个线程都可以首先修改资源，并且需要使用锁来确保这两个任务不会同时修改该资源。使用<code>dispatch queues</code>，你可以将两个任务都添加到<code>serial dispatch queue</code>中，以确保在任何给定时间只有一个任务修改了资源。这种基于<code>queue-based synchronization</code>(队列的同步)比<code>locks</code>更有效，因为在有争用还是无争用的情况下，<code>locks</code>总是需要昂贵的<code>kernel trap</code>(内核陷阱)，而<code>dispatch queues</code>主要在应用程序的进程空间中工作，并且只有在绝对必要时才调用内核。</p>
<p>虽然你指出在 <code>serial queue</code> 中运行的两个任务不能同时运行是正确的，但你必须记住，如果两个线程同时获得一个<code>lock</code>，则线程提供的任何并发性都会丢失或显着减少。更重要的是，线程模型需要创建两个线程，这两个线程同时占用内核和用户空间内存。<code>Dispatch queues</code> 不会为它们的线程支付相同的内存损失，它们使用的线程会一直保持忙碌，不会阻塞。</p>
<p>4、<code>dispatch queues</code> 的一些要点：</p>
<ul>
<li><p><code>dispatch queues</code> 相对于其他 <code>dispatch queues</code> 并行执行任务。任务的序列化仅限于单个 <code>dispatch queues</code> 中的任务。</p>
</li>
<li><p>系统决定任何一次执行的任务总数。因此，在100个不同的<code>queues</code>中具有100个任务的应用程序可能不会并发执行所有这些任务（除非它具有100个或更多个有效内核）。</p>
</li>
<li><p>在选择启动哪个新任务时，系统会考虑<code>queue priority levels</code>(队列优先级)。可以设置<code>serial queue</code>优先级。</p>
</li>
<li><p><code>queue</code> 中的任务在添加到 <code>queue</code> 时必须准备就绪才能执行。（如果以前使用过<code>Cocoa operation objects</code>，请注意，此行为与<code>model operations</code>使用的行为有所不同。）</p>
</li>
<li><p><code>private dispatch queues</code>(即，串行队列) 是引用计数的对象(<code>reference-counted objects</code>)。请注意，除了将 <code>queue</code> 保留在自己的代码中之外，还可以将<code>dispatch sources</code>附加到 <code>queue</code> 并增加其 <code>retain count</code>。因此，你必须确保取消所有<code>dispatch sources</code>，并且所有<code>retain</code>调用 都与适当的<code>release</code>调用平衡。</p>
</li>
</ul>
<h3 id="队列相关技术"><a href="#队列相关技术" class="headerlink" title="队列相关技术"></a>队列相关技术</h3><p>除了<code>dispatch queues</code>，<code>Grand Central Dispatch</code>还提供了几种使用 <code>queues</code> 的技术来帮助您管理代码。</p>
<h4 id="Dispatch-groups"><a href="#Dispatch-groups" class="headerlink" title="Dispatch groups"></a>Dispatch groups</h4><p><code>dispatch groups</code>(调度组) 是一种监视一组 <code>block</code> 对象是否完成的方法，你可以根据需要同步或异步监视这些<code>block</code>。<code>Groups</code>为依赖于其他任务完成的代码 提供了一种有用的同步机制。</p>
<h4 id="Dispatch-semaphores"><a href="#Dispatch-semaphores" class="headerlink" title="Dispatch semaphores"></a>Dispatch semaphores</h4><p><code>Dispatch semaphores</code>(调度信号量)与传统信号量相似，但通常效率更高。只有在由于<code>semaphore</code>不可用 而需要阻塞调用线程时，才将<code>Dispatch semaphores</code>向下调用到内核。如果<code>semaphore</code>可用，则不进行内核调用。 </p>
<h4 id="Dispatch-sources"><a href="#Dispatch-sources" class="headerlink" title="Dispatch sources"></a>Dispatch sources</h4><p><code>Dispatch sources</code>(调度源) 响应于特定类型的系统事件而生成通知。可以使用 <code>dispatch sources</code> 来监视事件，例如进程通知、信号和描述符事件。发生事件时，<code>dispatch source</code>将任务代码异步提交到指定的<code>dispatch queue</code>进行处理。</p>
<h2 id="使用block执行任务"><a href="#使用block执行任务" class="headerlink" title="使用block执行任务"></a>使用block执行任务</h2><p><code>block</code>对象是一种基于C的语言功能，可以在<code>C</code>、<code>Objective-C</code>和<code>C++</code>代码中使用。<code>block</code>使定义一个独立的工作单元变得容易。尽管它们看起来类似于函数指针，但<code>block</code>实际上是由类似于对象的底层数据结构来表示的，并且由编译器为你创建和管理。编译器将你提供的代码（以及任何相关数据）打包起来，并将其封装为可以存在于堆中并在应用程序中传递的一种形式。</p>
<p><code>block</code>的主要优点之一是它们能够使用其词法范围(<code>lexical scope</code>)之外的变量。 当你在函数或方法中定义一个<code>block</code>时，该<code>block</code>在某些方面就像传统的代码块一样。 例如，一个<code>block</code>可以读取在父作用域中定义的变量的值。<code>block</code>访问的变量被复制到堆上的<code>block</code>数据结构中，以便该<code>block</code>以后可以访问它们。将<code>block</code>添加到<code>dispatch queue</code>时，通常必须以只读格式保留这些值。但是，同步执行的<code>block</code>也可以使用带有<code>__block</code>关键字的变量，以将数据返回到父级的调用范围。 </p>
<p>你可以使用类似于函数指针的语法来声明与代码内联的块(<code>blocks inline</code>)。<code>block</code>和<code>function pointer</code>之间的主要区别在于，<code>block</code>名称的前面带有<code>^</code>符号而不是<code>*</code>符号。像<code>function pointer</code>一样，你可以将参数传递给<code>block</code>并从中接收返回值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^aBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> z) &#123;</span><br><span class="line">    printf(<span class="string">"%d %d %d\n"</span>, x, y, z);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">aBlock(<span class="number">789</span>);   <span class="comment">// prints: 123 456 789</span></span><br></pre></td></tr></table></figure>

<p>以下是设计<code>blocks</code>时应考虑的一些关键准则的总结：</p>
<ul>
<li><p>对于计划使用<code>dispatch queue</code>异步执行的<code>blocks</code>，从父函数或方法中捕获标量变量并在<code>block</code>中使用它们是安全的。但是，你不应该试图捕获大型结构 或 其他由调用上下文分配和删除的基于指针的变量。在执行<code>block</code>时，该指针引用的内存可能会消失。当然，自己分配内存（或对象）并显式地将该内存的所有权交给<code>block</code>是安全的。</p>
</li>
<li><p><code>dispatch queues</code> 复制添加到它们的<code>blocks</code>，并在完成执行时释放<code>blocks</code>。换句话说，在将<code>blocks</code>添加到<code>queue</code>之前，无需显式复制块。</p>
</li>
<li><p>尽管在执行小任务时，<code>queues</code>比原始线程更有效，但是创建<code>blocks</code>并在<code>queues</code>上执行它们仍然有开销。如果一个<code>blocks</code>做的工作太少，则内联执行它可能比将其分派到队列中更便宜。判断某个<code>blocks</code>是否工作量太少的方法是使用性能工具收集每个路径的指标并进行比较。</p>
</li>
<li><p>不要缓存与底层线程相关的数据，并期望可以从不同的<code>block</code>访问这些数据。如果同一队列中的任务需要共享数据，请改用<code>dispatch queue</code>的上下文指针存储数据。</p>
</li>
<li><p>如果你的<code>block</code>创建了多个<code>Objective-C</code>对象，你可能希望将<code>block</code>部分代码的代码包含在<code>@autorelease block</code>中，以处理这些对象的内存管理。 尽管<code>GCD dispatch queues</code>具有自己的<code>autorelease pools</code>，但是它们不保证这些<code>pools</code>何时耗尽。如果您的应用程序受内存限制，则创建自己的<code>autorelease pool</code>可以让你在更定期地为自动释放对象释放内存。</p>
</li>
</ul>
<h2 id="创建和管理-Dispatch-Queues"><a href="#创建和管理-Dispatch-Queues" class="headerlink" title="创建和管理 Dispatch Queues"></a>创建和管理 Dispatch Queues</h2><p>在将任务添加到<code>queue</code>之前，必须确定要使用的队列类型以及打算如何使用它。<code>Dispatch queues</code>可以串行或并行执行任务。此外，如果你对队列有特定的用途，则可以相应地配置<code>queue</code>属性。</p>
<h3 id="获取-Global-Concurrent-Dispatch-Queues"><a href="#获取-Global-Concurrent-Dispatch-Queues" class="headerlink" title="获取 Global Concurrent Dispatch Queues"></a>获取 Global Concurrent Dispatch Queues</h3><p>当你有多个可以并行运行的任务时，<code>concurrent dispatch queue</code>很有用。<code>concurrent queue</code> 仍然是一个 <code>queue</code>，因为它按照<code>first-in, first-out</code>(先进先出)的顺序将任务从队列中取出。但是，<code>concurrent queue</code>可能会在其他先前任务完成之前使其他任务出队。<code>concurrent queue</code>在任何给定时刻执行的实际任务数是可变的，可以随着应用程序条件的变化而动态变化。许多因素会影响<code>concurrent queue</code>执行的任务数量，包括可用内核数、其他进程正在完成的工作量以及其他<code>serial dispatch queues</code>中任务的数量和优先级。</p>
<p>系统为每个应用程序提供4个<code>concurrent dispatch queues</code>。这些<code>queues</code>对于应用程序来说是全局的，仅按优先级进行区分。因为它们是全局的，所以无需显式创建它们，只需要使用 <code>dispatch_get_global_queue</code> 函数请求其中一个队列，如以下示例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过传递常量获取 queue</span></span><br><span class="line"><span class="comment">    DISPATCH_QUEUE_PRIORITY_HIGH  高优先级</span></span><br><span class="line"><span class="comment">    DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line"><span class="comment">    DISPATCH_QUEUE_PRIORITY_LOW 低优先级</span></span><br><span class="line"><span class="comment">    DISPATCH_QUEUE_PRIORITY_BACKGROUND  // 后台队列</span></span><br><span class="line"><span class="comment">    注意：第二个参数保留给以后使用，目前始终为该参数传递0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>尽管<code>dispatch queues</code>是<code>reference-counted objects</code>(引用计数的对象)，但是你无需<code>retain</code>和<code>release</code> <code>global concurrent queues</code>，因为它们在应用程序中是全局的，所以忽略对这些<code>queues</code>调用<code>retain</code>和<code>release</code>。因此，不需要存储对这些<code>queues</code>的引用，只要需要对其中一个队列的引用，就可以调用<code>dispatch_get_global_queue</code> 函数。</p>
<h3 id="创建-Serial-Dispatch-Queues"><a href="#创建-Serial-Dispatch-Queues" class="headerlink" title="创建 Serial Dispatch Queues"></a>创建 Serial Dispatch Queues</h3><p>当你希望任务以特定顺序执行时，<code>Serial queues</code>很有用。<code>serial queue</code>一次只能执行一个任务，并且总是从队列的开头提取任务。可以使用<code>serial queue</code>而不是<code>lock</code>来保护共享资源或可变数据结构。与<code>lock</code>不同，<code>serial queue</code>可确保任务以可预测的顺序执行。而且，只要你将任务异步提交到<code>serial queue</code>，该<code>queue</code>就永远不会死锁(<code>deadlock</code>)。</p>
<p>与创建的<code>concurrent queues</code>不同，你必须显式创建和管理要使用的任何<code>serial queue</code>。可以为应用程序创建任意数量的<code>serial queues</code>，但是应该避免仅仅为了同时执行尽可能多的任务而创建大量的<code>serial queues</code>。如果要同时执行大量任务，请将它们提交到一个<code>global concurrent queues</code>中。创建<code>serial queues</code>时，请尝试确定每个<code>queue</code>的用途，例如保护资源或同步应用程序的某些关键行为。</p>
<p>创建自定义串行队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 参数一：表示 队列名称，用于调试器和性能工具，以跟踪任务的执行方式</span></span><br><span class="line"><span class="comment"> 参数二：为将来使用而保留的，应该为 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="在运行时获取-Common-Queues"><a href="#在运行时获取-Common-Queues" class="headerlink" title="在运行时获取 Common Queues"></a>在运行时获取 Common Queues</h3><p>除了你创建的任何自定义队列之外，系统还会自动创建一个<code>serial queue</code>并将其绑定到应用程序的主线程。</p>
<p><code>GCD</code>提供了一些函数，使你可以从应用程序中访问几个常见的<code>dispatch queues</code>：</p>
<ul>
<li><p>使用 <code>dispatch_get_current_queue</code> 函数进行调试或测试当前队列的身份。从<code>block</code>对象内部调用此函数将返回已提交该<code>block</code>的队列，并且现在可能正在该队列上运行。从<code>block</code>外部调用此函数将为您的应用程序返回<code>default concurrent queue</code>。</p>
</li>
<li><p>使用 <code>dispatch_get_main_queue</code> 函数获取与应用程序的主线程关联的<code>serial dispatch queue</code>。此队列是为<code>Cocoa</code>应用程序以及调用了<code>dispatch_main</code>函数或在主线程上配置<code>run loop</code>的应用程序 自动创建的。</p>
</li>
<li><p>使用 <code>dispatch_get_global_queue</code> 函数获取任何共享的<code>concurrent queues</code>。</p>
</li>
</ul>
<h3 id="Dispatch-Queues的内存管理"><a href="#Dispatch-Queues的内存管理" class="headerlink" title="Dispatch Queues的内存管理"></a>Dispatch Queues的内存管理</h3><p><code>Dispatch queues</code>和其它<code>dispatch objects</code>是<code>reference-counted data types</code>(引用计数的数据类型)。创建<code>serial dispatch queue</code>时，它的初始引用计数为1。可以根据需要使用<code>dispatch_retain</code>和<code>dispatch_release</code>函数来递增和递减该引用计数。当 <code>queue</code> 的引用计数达到零时，系统将异步释放该<code>queue</code>。</p>
<p><code>retain</code>和<code>release</code> <code>dispatch objects</code>很重要，以确保它们在使用时仍保留在内存中。与内存管理的<code>Cocoa</code>对象一样，一般规则是，如果你打算使用传递给代码的<code>queue</code>，则应在使用该<code>queue</code>之前保留该<code>queue</code>，并在不再需要它时<code>release</code>它。这种基本模式可确保<code>queue</code>在你使用期间一直保留在内存中。</p>
<blockquote>
<p>注意：你不需要保留或释放任何<code>global dispatch queues</code>，包括<code>concurrent dispatch queues</code>或<code>main dispatch queue</code>。<code>retain</code>或<code>release``queues</code>的任何尝试都将被忽略。</p>
</blockquote>
<h3 id="使用-Queue-存储自定义上下文信息"><a href="#使用-Queue-存储自定义上下文信息" class="headerlink" title="使用 Queue 存储自定义上下文信息"></a>使用 Queue 存储自定义上下文信息</h3><p>所有<code>dispatch objects</code>(包括<code>dispatch queues</code>)都允许你将自定义上下文数据与该对象相关联。要在给定对象上设置和获取此数据，请使用<code>dispatch_set_context</code>和<code>dispatch_get_context</code>函数。系统不会以任何方式使用你的自定义数据，你可以在适当的时间分配和取消分配数据。</p>
<p>对于<code>queues</code>，可以使用上下文数据存储指向<code>Objective-C</code>对象或其他数据结构的指针，该指针或数据结构有助于识别<code>queues</code>或其在代码中的预期用途。可以使用<code>queue</code>的<code>finalizer</code>函数在释放上下文数据之前将其从<code>queue</code>中释放(或取消关联)。</p>
<h3 id="为Queue提供清理功能"><a href="#为Queue提供清理功能" class="headerlink" title="为Queue提供清理功能"></a>为Queue提供清理功能</h3><p>创建<code>serial dispatch queue</code>后，可以附加<code>finalizer</code>函数，以在释放<code>queue</code>时执行任何自定义清理。<code>Dispatch queues</code>是引用计数对象，可以使用<code>dispatch_set_finalizer_f</code>函数指定当<code>queue</code>的引用计数达到零时要执行的函数。可以使用此函数来清理与<code>queue</code>关联的上下文数据，并且仅当上下文指针不为<code>NULL</code>时才调用此函数。</p>
<h2 id="向Queue添加任务"><a href="#向Queue添加任务" class="headerlink" title="向Queue添加任务"></a>向Queue添加任务</h2><p>要执行任务，必须将其分派到适当的<code>dispatch queue</code>。可以同步或异步分配任务，也可以单个或成组分配任务。一旦进入队列，该队列就会根据其约束条件和队列中已经存在的任务，负责尽快执行任务。</p>
<h3 id="向-Queue-添加单个任务"><a href="#向-Queue-添加单个任务" class="headerlink" title="向 Queue 添加单个任务"></a>向 Queue 添加单个任务</h3><p>向<code>queue</code>添加任务有两种方法：<code>asynchronously</code>(异步)或<code>synchronously</code>(同步)。</p>
<p>如果可能，使用<code>dispatch_async</code>和<code>dispatch_async_f</code>函数进行异步执行优于同步替代方案。当你向<code>queue</code>添加<code>block</code>对象或函数时，无法知道该代码何时执行。因此，异步添加<code>block</code>或函数使你可以安排代码的执行，并继续从调用线程执行其他工作。如果你正在从应用程序的主线程调度任务，这一点尤其重要，这可能是为了响应某些用户事件。</p>
<p>尽管你应该尽可能异步地添加任务，但是有时仍然需要同步添加任务以防止出现竞争条件或其他同步错误。在这些情况下，可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数将任务添加到<code>queue</code>中。这些函数将阻塞当前执行线程，直到指定任务完成执行为止。</p>
<h4 id="向并发队列添加任务"><a href="#向并发队列添加任务" class="headerlink" title="向并发队列添加任务"></a>向并发队列添加任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueC = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueC, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步函数-并发队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueC, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步函数-并发队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line">同步函数-并发队列-&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000037c01c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">异步函数-并发队列-&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003798780</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向串行队列添加任务"><a href="#向串行队列添加任务" class="headerlink" title="向串行队列添加任务"></a>向串行队列添加任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueS = dispatch_queue_create(<span class="string">"com.test.MyCustomQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueS, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步函数-串行队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueS, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步函数-串行队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line">同步函数-串行队列-&lt;<span class="built_in">NSThread</span>: <span class="number">0x6000036641c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">异步函数-串行队列-&lt;<span class="built_in">NSThread</span>: <span class="number">0x600003624380</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向主队列添加任务"><a href="#向主队列添加任务" class="headerlink" title="向主队列添加任务"></a>向主队列添加任务</h4><ul>
<li>只能以异步的方式向主队列添加任务</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步函数-主队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印：异步函数-主队列-&lt;NSThread: 0x6000003583c0&gt;&#123;number = 1, name = main&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>决不能从计划传递给函数的同一 <code>queue</code> 中执行的任务调用<code>dispatch_sync</code>或<code>dispatch_sync_f</code>函数。这对于<code>serial queues</code>特别重要，<code>serial queues</code>必然会发生死锁，但对于<code>concurrent queues</code>也应该避免。</p>
</blockquote>
<p>造成死锁的情况如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主线程执行如下函数会造成死锁崩溃</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步函数-主队列-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queueS = dispatch_queue_create(<span class="string">"com.test.myQueue1"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queueS, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 在同一queue 中 同步添加任务，会造成死锁崩溃</span></span><br><span class="line">    <span class="comment">// dispatch_queue_t queueS = dispatch_get_current_queue();</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queueS, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"xxcv"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="完成任务时执行-Completion-Block"><a href="#完成任务时执行-Completion-Block" class="headerlink" title="完成任务时执行 Completion Block"></a>完成任务时执行 Completion Block</h3><p>从本质上讲，分派到<code>queue</code>的任务独立于创建它们的代码运行。但是，当任务完成时，应用程序可能仍然希望得到通知，以便它能够合并结果。在传统的异步编程中，你可以使用回调机制来执行此操作，但是在<code>dispatch queues</code>中，可以使用<code>completion block</code>。</p>
<p><code>completion block</code>只是您在原始任务结束时分派到<code>queue</code>中的另一段代码。调用代码通常在启动任务时将<code>completion block</code>作为参数提供。所有任务代码所要做的就是在完成工作时将指定的<code>block</code>或函数提交给指定的<code>queue</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务完成，调用完成块</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="同时执行循环迭代"><a href="#同时执行循环迭代" class="headerlink" title="同时执行循环迭代"></a>同时执行循环迭代</h3><p><code>concurrent dispatch queues</code> 可能提高性能的一个地方是，你有一个执行固定次数迭代的循环。如下for循环，该循环每次迭代中都完成了一些工作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在每次迭过程中执行的工作与在所有其他迭代过程中<strong>执行的工作不同</strong>，并且<strong>每个连续循环完成的顺序不重要</strong>，则可以用调用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数来替换循环。这些函数在每次循环迭代一次将指定的<code>block</code>或函数提交给<code>queue</code>。 因此，当分派到<code>concurrent queue</code>时，可以同时执行多个循环迭代。</p>
<p>在调用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>时，可以指定<code>serial queue</code>或<code>concurrent queue</code>。传递<code>concurrent queue</code>使你可以同时执行多个循环迭代，这是使用这些函数的最常用方法。尽管使用<code>serial queue</code>是允许的，并且对代码做了正确的事情，但是使用这样的<code>queue</code>与保留循环相比没有真正的性能优势。</p>
<blockquote>
<p>与常规的for循环一样，<code>dispatch_apply</code>和<code>dispatch_apply_f</code>函数只有在完成所有循环迭代之后才返回。因此，当从已经在队列上下文中执行的代码中调用它们时，应该小心。如果作为参数传递给函数的队列是一个<code>serial queue</code>，并且与执行当前代码的队列相同，则调用这些函数将使<code>queue</code>死锁。</p>
<p>因为它们有效地阻塞了当前线程，所以从主线程调用这些函数时也应小心，因为它们可能阻止事件处理循环及时响应事件。如果循环代码需要大量的处理时间，则可能需要从其他线程调用这些函数。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_apply(<span class="number">100</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t i) &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行循环体任务</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu---%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_leave(downloadGroup);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"循环执行完成---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>应该确保你的任务代码在每次迭代中完成了合理的工作量。与分派给<code>queue</code>的任何<code>block</code>或函数一样，调度代码执行也会有开销。如果循环的每次迭代仅执行少量工作，则调度代码的开销 可能会超过 将代码调度到<code>queue</code>可能带来的性能优势。如果在测试期间发现这是正确的，则可以使用<code>striding</code>(跨步)来增加每次循环迭代期间执行的工作量。 使用<code>striding</code>，可以将原始循环的多个迭代组合到一个<code>block</code>中，并按比例减少迭代计数。例如，如果最初执行100次迭代，但决定使用4的步幅，则现在从每个块执行4次循环迭代，你的迭代计数为25。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">100</span>, stride = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">dispatch_apply(count / stride, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t idx) &#123;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始执行循环体任务</span></span><br><span class="line">    size_t j = idx * stride;</span><br><span class="line">    size_t j_stop = j + stride;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zu---%@"</span>, j++, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125; <span class="keyword">while</span> (j &lt; j_stop);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_leave(downloadGroup);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"循环执行完成---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="在主线程上执行任务"><a href="#在主线程上执行任务" class="headerlink" title="在主线程上执行任务"></a>在主线程上执行任务</h3><p><code>Grand Central Dispatch</code>提供了一个特殊的<code>dispatch queue</code>，用于在应用程序的主线程上执行任务。所有应用程序均会自动提供此<code>queue</code>，并由在其主线程上设置<code>run loop</code>的任何应用程序自动耗尽。如果不创建<code>Cocoa</code>应用程序，并且不想显式设置<code>run loop</code>，则必须调用<code>dispatch_main</code>函数显式地耗尽<code>main dispatch queue</code>。你仍然可以将任务添加到队列中，但是如果您不调用此函数，则这些任务将永远不会执行。</p>
<p>可以通过调用<code>dispatch_get_main_queue</code>函数来获取应用程序主线程的<code>dispatch queue</code>。添加到此<code>queue</code>的任务在主线程上串行执行。因此，可以将此队列用作在应用程序其他部分中完成工作的同步点。 </p>
<h3 id="在任务中使用Objective-C对象"><a href="#在任务中使用Objective-C对象" class="headerlink" title="在任务中使用Objective-C对象"></a>在任务中使用Objective-C对象</h3><p><code>GCD</code>为<code>Cocoa</code>内存管理技术提供了内置支持，因此可以在提交给<code>dispatch queues</code>的<code>blocks</code>中自由使用<code>Objective-C</code>对象。每个<code>dispatch queue</code>都维护自己的<code>autorelease pool</code>，以确保自动释放的对象在某个时刻被释放。<code>queues</code>并不保证它们何时真正释放这些对象。</p>
<p>如果您的应用程序受内存限制，而<code>block</code>创建了多个自动释放的对象，则创建自己的<code>autorelease pool</code>是确保及时释放对象的唯一方法。如果<code>block</code>创建了数百个对象，则可能要创建多个<code>autorelease pool</code>或定期清空你的<code>pool</code>。</p>
<h2 id="挂起和恢复队列"><a href="#挂起和恢复队列" class="headerlink" title="挂起和恢复队列"></a>挂起和恢复队列</h2><p>可以通过挂起一个<code>queue</code>来临时阻止它执行<code>block</code>对象。可以使用<code>dispatch_suspend</code>函数挂起<code>dispatch queue</code>，然后使用<code>dispatch_resume</code>函数将其恢复。调用<code>dispatch_suspend</code>会使队列的挂起引用计数增加，而调用<code>dispatch_resume</code>会使引用计数减少。当引用计数大于零时，队列保持挂起状态。因此，你必须平衡所有<code>suspend</code>的调用与匹配的<code>resume</code>调用，以恢复处理<code>block</code>。</p>
<blockquote>
<p><code>Suspend</code>(暂停)和<code>resume</code>(恢复)调用是异步的，仅在执行<code>block</code>之间生效。挂起一个队列不会导致已经执行的<code>block</code>停止。</p>
</blockquote>
<h2 id="使用-Dispatch-Semaphores-调节有限资源的使用"><a href="#使用-Dispatch-Semaphores-调节有限资源的使用" class="headerlink" title="使用 Dispatch Semaphores 调节有限资源的使用"></a>使用 Dispatch Semaphores 调节有限资源的使用</h2><p>如果要提交给<code>dispatch queues</code>的任务访问某个有限资源，则可能要使用<code>dispatch semaphore</code>(调度信号量)来调节同时访问该资源的任务数。<code>dispatch semaphore</code>的工作方式类似于常规信号量，但有一个例外。当资源可用时，获取<code>dispatch semaphore</code> 的时间比获取传统<code>system semaphore</code>的时间要短。这是因为在这种特殊情况，<code>Grand Central Dispatch</code>不会调用内核，它唯一调用内核的时间是当资源不可用时，系统需要停止线程，直到信号量发出信号。</p>
<p>使用调度信号量的语义如下：</p>
<ol>
<li><p>创建<code>semaphore</code>时（使用<code>dispatch_semaphore_create</code>函数），可以指定一个正整数，表示可用资源的数量。</p>
</li>
<li><p>在每个任务中，调用<code>dispatch_semaphore_wait</code>等待<code>semaphore</code>。</p>
</li>
<li><p>等待调用返回时，获取资源并进行工作。</p>
</li>
<li><p>处理完资源后，请释放该资源，并通过调用<code>dispatch_semaphore_signal</code>函数来发出<code>semaphore</code>。</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用资源浴室为2间</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下面安排10个人去洗澡</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 如果资源数量为0，会阻塞当前线程。根据等待时间进行等待</span></span><br><span class="line">        <span class="comment">// dispatch_time_t timeOut = dispatch_time(DISPATCH_TIME_NOW, 3);</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%d个人开始洗澡，时间为： %@"</span>, i, [<span class="built_in">NSDate</span> date]);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建信号量时，请指定可用资源的数量。该值成为<code>semaphore</code>(信号量)的初始计数变量。每次等待<code>semaphore</code>(信号量)时，<code>dispatch_semaphore_wait</code>函数都会将对变量的计数减1。如果结果值为负，则该函数会通知内核阻止您的线程。 另一方面，<code>dispatch_semaphore_signal</code>函数将<code>count</code>变量增加1，以指示资源已释放。如果有任务被阻塞并等待资源，则其中一个任务随后将被解除阻塞并允许执行其工作。</p>
<h2 id="等待排队的任务组"><a href="#等待排队的任务组" class="headerlink" title="等待排队的任务组"></a>等待排队的任务组</h2><p><code>Dispatch groups</code>(调度组)是一种阻塞线程，直到一个或多个任务完成执行的一种方法。可以在所有指定任务完成之前无法取得进展的地方使用它。</p>
<p>使用方式一：在分派了多个任务以计算一些数据之后，使用一个组来等待这些任务，然后在完成后处理结果；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_notify(group, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务完成"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用方式二：使用<code>dispatch groups</code>的另一种方法是替代线程连接。可以将相应的任务添加到<code>dispatch group</code>并等待整个组，而不是启动几个子线程，然后再与每个子线程联接。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 向组中添加一项任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 同步任务完成的任务</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当组内的任务未完成时，会阻塞当前线程。</span></span><br><span class="line"><span class="comment">// dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></span><br></pre></td></tr></table></figure>

<h2 id="Dispatch-Queues和线程安全"><a href="#Dispatch-Queues和线程安全" class="headerlink" title="Dispatch Queues和线程安全"></a>Dispatch Queues和线程安全</h2><p>在 <code>dispatch queues</code> 的上下文中谈论线程安全性似乎很奇怪，但是线程安全性仍然是一个相关主题。每当你在应用程序中实现并发时，你都应该了解以下几点：</p>
<ul>
<li><p><code>Dispatch queues</code>本身是线程安全的。换句话说，可以从系统上的任何线程将任务提交到<code>dispatch queue</code>，而无需先对该<code>queue</code>进行 锁定 或 同步对该<code>queue</code>访问。</p>
</li>
<li><p>不要从一个正在执行的任务中调用<code>dispatch_sync</code>函数，这个任务和你传递给你的函数调用的是同一个队列。这样做将导致队列死锁。如果需要<code>dispatch</code>到当前<code>queue</code>，请使用<code>dispatch_async</code>函数异步进行。</p>
</li>
<li><p>避免从提交到<code>dispatch queue</code>的任务中获取<code>locks</code>。虽然从任务中使用<code>lock</code>是安全的，但是当你获取<code>lock</code>时，如果该<code>lock</code>不可用，则可能会完全阻塞<code>serial queue</code>。同样，对于<code>concurrent queues</code>，等待<code>lock</code>可能会阻止其他任务执行。如果需要同步部分代码，请使用<code>serial dispatch queue</code>而不是<code>lock</code>。</p>
</li>
<li><p>尽管您可以获得有关运行任务的基础线程的信息，但最好避免这样做。</p>
</li>
</ul>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1" target="_blank" rel="noopener">Dispatch Queues</a></p>
<p><a href="https://segmentfault.com/a/1190000003101343" target="_blank" rel="noopener">iOS 详细介绍 GCD</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/23/Threads-%E4%BA%94-GCD-Dispatch-Queues/">http://yoursite.com/2020/10/23/Threads-%E4%BA%94-GCD-Dispatch-Queues/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/23/Threads-%E5%85%AD-GCD-Dispatch-Sources/"><i class="fa fa-chevron-left">  </i><span>Threads(六)GCD - Dispatch Sources</span></a></div><div class="next-post pull-right"><a href="/2020/10/20/Threads-%E5%9B%9B-Operation-Queues/"><span>Threads(四)Operation Queues</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>