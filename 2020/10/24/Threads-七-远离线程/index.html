<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(七)远离线程"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(七)远离线程 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#用-Dispatch-Queues-替换-Threads"><span class="toc-number">1.</span> <span class="toc-text">用 Dispatch Queues 替换 Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消除-Lock-Based-Code"><span class="toc-number">2.</span> <span class="toc-text">消除 Lock-Based Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-Asynchronous-Lock"><span class="toc-number">2.1.</span> <span class="toc-text">实现 Asynchronous Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步执行关键部分"><span class="toc-number">2.2.</span> <span class="toc-text">同步执行关键部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改进循环代码"><span class="toc-number">3.</span> <span class="toc-text">改进循环代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#替换-Thread-Joins"><span class="toc-number">4.</span> <span class="toc-text">替换 Thread Joins</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更改-Producer-Consumer-实现"><span class="toc-number">5.</span> <span class="toc-text">更改 Producer-Consumer 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#替换-Semaphore-代码"><span class="toc-number">6.</span> <span class="toc-text">替换 Semaphore 代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#替换-Run-Loop-Code"><span class="toc-number">7.</span> <span class="toc-text">替换 Run-Loop Code</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与-POSIX-Threads-的兼容性"><span class="toc-number">8.</span> <span class="toc-text">与 POSIX Threads 的兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">9.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(七)远离线程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>有许多方法可以使现有的线程代码适合于利用<code>Grand Central Dispatch</code>和<code>operation objects</code>。尽管并非在所有情况下都可能远离线程，但是在你进行切换的地方，性能（以及代码的简单性）可能会显着提高。具体来说，使用<code>dispatch queues</code>和<code>operation queues</code>代替线程具有多个优点：</p>
<a id="more"></a>

<ul>
<li>它减少了你的应用程序为 将<code>thread stacks</code>(线程栈)存储在应用程序的内存空间 中而付出的内存损失。</li>
<li>它消除了创建和配置线程所需的代码。</li>
<li>它消除了管理和调度线程上的工作所需的代码。</li>
<li>它简化了你必须编写的代码。</li>
</ul>
<p>本章提供了一些技巧和指南，说明有关如何替换现有的基于线程的代码，而使用<code>dispatch queues</code>和<code>operation queues</code>来实现相同类型行为。</p>
<h2 id="用-Dispatch-Queues-替换-Threads"><a href="#用-Dispatch-Queues-替换-Threads" class="headerlink" title="用 Dispatch Queues 替换 Threads"></a>用 Dispatch Queues 替换 Threads</h2><p>若要了解如何用 <code>dispatch queues</code> 替换线程，请首先考虑目前在应用程序中使用线程的一些方式：</p>
<ul>
<li><p><code>Single task threads</code>(单任务线程)。创建一个线程来执行单个任务，并在任务完成后释放该线程。</p>
</li>
<li><p><code>Worker threads</code>(工作线程)。创建一个或多个辅助线程，并为每个线程指定特定的任务，定期将任务分配给每个线程。</p>
</li>
<li><p><code>Thread pools</code>(线程池)。创建一个通用线程池，并为每个线程设置<code>run loops</code>。当你有任务要执行时，请从池中获取一个线程，然后将任务分派给该线程。如果没有可用线程，则将任务排队并等待线程可用。</p>
</li>
</ul>
<p>尽管这些技术看似截然不同，但它们实际上只是同一原理的变体。在每种情况下，都使用线程来执行应用程序必须执行的某些任务。它们之间的唯一区别是用于 <strong>管理线程</strong> 和 <strong>任务排队</strong> 的代码。使用 <code>dispatch queues</code> 和 <code>operation queues</code>，可以消除所有线程和线程通信代码，而只专注于要执行的任务。</p>
<p>如果你正在使用上述线程模型之一，则应该已经对应用程序执行的任务类型有一个很好的了解。尝试将任务封装在一个<code>operation object</code>或一个<code>block object</code>中，然后将其分派到适当的<code>queue</code>中，而不是将任务提交给你的自定义线程。对于不是特别有争议的任务（即不带<code>locks</code>的任务），应该能够进行以下直接替换：</p>
<ul>
<li>对于单个任务线程，将任务封装在<code>block</code>或<code>operation object</code>中，然后将其提交到<code>concurrent queue</code>(并发队列)。</li>
<li>对于辅助线程，你需要确定是使用<code>serial queue</code>还是<code>concurrent queue</code>。如果使用工作线程来同步特定任务集的执行，请使用<code>serial queue</code>。如果确实使用工作线程执行没有相互依赖性的任意任务，请使用<code>concurrent queue</code>。</li>
<li>对于<code>thread pools</code>，将你的任务封装在一个<code>block</code>或<code>operation object</code>中，然后将它们分派到<code>concurrent queue</code>中以执行。</li>
</ul>
<p>当然，像这样的简单替换不一定在所有情况下都有效。如果你正在执行的任务争用共享资源，那么理想的解决方案是尝试首先删除或最小化该争用。如果有一些方法可以重构或重新构造代码以消除对共享资源的相互依赖性，那当然更好。</p>
<p>但是，如果这样做是不可能的或效率可能较低，则仍然可以利用<code>queues</code>的方法。<code>queues</code>的一大优点是它们提供了一种更<code>predictable</code>(可预测)的方式来执行代码。这种可预测性意味着，仍有许多方法可以在不使用<code>locks</code>或其他重量级同步机制的情况下同步代码的执行。除了使用<code>locks</code>，你还可以使用<code>queues</code>来执行许多相同的任务：</p>
<ul>
<li><p>如果有必须按特定顺序执行的任务，请将其提交给<code>serial dispatch queue</code>。如果你更喜欢使用<code>operation queues</code>，请使用<code>operation object</code> <code>dependencies</code>(依赖项)来确保这些对象按特定顺序执行。</p>
</li>
<li><p>如果当前正在使用<code>locks</code>来保护共享资源，请创建一个<code>serial queue</code>以执行任何修改该资源的任务。然后，<code>serial queue</code>将你现有的<code>locks</code>替换为同步机制。</p>
</li>
<li><p>如果使用线程联接来等待后台任务完成，请考虑改用<code>dispatch groups</code>。还可以使用<code>NSBlockOperation</code>对象或<code>operation object</code> <code>dependencies</code>(依赖项)来实现类似的组完成行为。</p>
</li>
<li><p>如果您使用 <code>producer-consumer algorithm</code>(生产者－消费者算法) 来管理有限的资源池，请考虑将实现更改为如下 <code>Changing Producer-Consumer Implementations</code>。</p>
</li>
<li><p>如果要使用线程从<code>descriptors</code>(描述符)读取、写入，或监视文件操作，请使用<code>dispatch sources</code>。</p>
</li>
</ul>
<p>一定要记住，<code>queues</code>不是替换<code>threads</code>的灵丹妙药。<code>queues</code>提供的<code>asynchronous programming model</code>(异步编程模型)在延迟不是问题的情况下是合适的。即使<code>queues</code>提供了配置队列中任务执行优先级的方法，但较高的执行优先级并不能保证在特定时间执行任务。因此，在需要最小延迟的情况下（例如在音频和视频播放中），线程仍然是一个更合适的选择。</p>
<h2 id="消除-Lock-Based-Code"><a href="#消除-Lock-Based-Code" class="headerlink" title="消除 Lock-Based Code"></a>消除 Lock-Based Code</h2><p>对于线程代码，<code>locks</code>是同步访问线程之间共享的资源的传统方法之一。但是，使用<code>locks</code>是有代价的。即使在无争议的情况下，也总是会受到与取<code>locks</code>相关的性能处罚。并且在有争议的情况下，一个或多个线程在等待<code>lock</code>释放时可能会被无限时间阻塞。</p>
<p>用<code>queues</code>替换<code>lock-based code</code>(基于锁的代码)可以消除许多与<code>locks</code>相关的惩罚，还可以简化剩余的代码。与其使用使用<code>lock</code>来保护共享资源，不如创建一个<code>queue</code>来序列化访问该资源的任务。<code>Queues</code> 不会施加与<code>locks</code>相同的惩罚。例如，任务排队不需要捕获到内核中以获取互斥。</p>
<p>在对任务进行排队时，你必须做出的主要决定是<code>synchronously</code>(同步)还是<code>asynchronously</code>(异步)进行。异步提交任务可以使当前线程在执行任务时继续运行。同步提交任务会阻塞当前线程，直到任务完成。这两个选项都有适当的用途，尽管在可能的情况下异步提交任务无疑是有利的。</p>
<h3 id="实现-Asynchronous-Lock"><a href="#实现-Asynchronous-Lock" class="headerlink" title="实现 Asynchronous Lock"></a>实现 Asynchronous Lock</h3><p><code>asynchronous lock</code>(异步锁)是一种保护共享资源方法，它不阻止任何修改该资源的的代码。当需要修改数据结构时，可以使用<code>asynchronous lock</code>，作为代码正在执行的其他一些工作的副作用。使用传统线程，通常实现此代码的方式是对共享资源进行锁定，进行必要的更改，释放该锁定，然后继续执行任务的主要部分。但是，使用<code>dispatch queues</code>，调用代码可以异步进行修改，而无需等待这些更改完成。</p>
<p>如下是一个<code>asynchronous lock</code>实现的示例。在此示例中，受保护的资源定义了自己的<code>serial dispatch queue</code>。调用代码将一个<code>block object</code>提交到此<code>queue</code>，其中包含需要对资源进行的修改。因为<code>queue</code>本身是串行执行<code>blocks</code>的，所以可以确保对资源的更改按接收顺序进行；但是，由于任务是异步执行的，因此调用线程不会阻塞。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(obj-&gt;serial_queue, ^&#123;</span><br><span class="line">   <span class="comment">// Critical section</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="同步执行关键部分"><a href="#同步执行关键部分" class="headerlink" title="同步执行关键部分"></a>同步执行关键部分</h3><p>如果在给定任务完成之前当前代码无法继续，则可以使用<code>dispatch_sync</code>函数同步提交任务。此函数将任务添加到<code>dispatch queue</code>中，然后阻塞当前线程，直到任务完成执行。<code>dispatch queue</code>本身可以是<code>serial</code>(串行)或<code>concurrent</code>(并发)队列，具体取决于您的需求。 但是，由于此函数会阻塞当前线程，因此仅应在必要时使用它。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(my_queue, ^&#123;</span><br><span class="line">   <span class="comment">// 关键部分</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你已经在使用<code>serial queue</code>来保护共享资源，则与异步分发相比，同步分派到该队列不会更多地保护共享资源。同步分派的唯一原因是防止当前代码在关键部分结束之前继续执行。例如，如果您想从共享资源中获取一些值并立即使用它，则需要同步调度。如果当前代码不需要等待关键部分完成，或者可以简单地将其他后续任务提交到同一串行队列，则通常首选异步提交。</p>
<h2 id="改进循环代码"><a href="#改进循环代码" class="headerlink" title="改进循环代码"></a>改进循环代码</h2><p>如果代码有循环，并且每次循环执行的工作都与其他迭代中完成的工作无关，则可以考虑使用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数重新实现该<code>Loop Code</code>(循环代码)。这些函数将循环的每次迭代分别提交给<code>dispatch queue</code>进行处理。与<code>concurrent queue</code>一起使用时，此功能使你可以同时执行循环的多次迭代。</p>
<p><code>dispatch_apply</code>和<code>dispatch_apply_f</code>函数是同步函数调用，它们阻塞当前执行线程，直到所有循环迭代完成为止。当提交到<code>concurrent queue</code>时，不能保证循环迭代的执行顺序。运行每次迭代的线程可能会阻塞，导致给定的迭代在它周围的其他迭代之前或之后完成。因此，用于每次循环迭代的<code>block</code>对象或函数必须是可重入的。</p>
<p>如下用<code>dispatch-based</code>的等效项替换for循环：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(count, queue, ^(size_t i) &#123;</span><br><span class="line">   printf(<span class="string">"%u\n"</span>, i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>尽管前面的示例是一个简单的示例，但是它演示了使用<code>dispatch queues</code>替换循环的基本技术。尽管这可能是提高基于循环的代码性能的好方法，但仍必须谨慎地使用此技术。尽管<code>dispatch queues</code>的开销非常低，但是在线程上调度每个循环迭代仍然会产生成本。因此，应该确保你的循环代码能够完成足够的工作以保证成本。你到底需要做多少工作，这是您必须使用性能工具来衡量的。</p>
<p>在每个循环迭代中增加工作量的一个简单方法是使用<code>striding</code>(跨步)。使用<code>striding</code>(跨步)，你可以重写<code>block</code>代码以执行原始循环的多个迭代。然后，可以按比例减少为<code>dispatch_apply</code>函数指定的计数值。</p>
<p>如下向for循环添加<code>striding</code>(跨步)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stride = <span class="number">137</span>;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">dispatch_apply(count / stride, queue, ^(size_t idx)&#123;</span><br><span class="line">    size_t j = idx * stride;</span><br><span class="line">    size_t j_stop = j + stride;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       printf(<span class="string">"%u\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)j++);</span><br><span class="line">    &#125;<span class="keyword">while</span> (j &lt; j_stop);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">size_t i;</span><br><span class="line"><span class="keyword">for</span> (i = count - (count % stride); i &lt; count; i++)</span><br><span class="line">   printf(<span class="string">"%u\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i);</span><br></pre></td></tr></table></figure>

<p>使用<code>strides</code>(跨步)有一定的性能优势。特别是，相对于<code>stride</code>(跨度)，当循环迭代的原始数量较高时，<code>strides</code>(跨度)会带来好处。并发调度更少的<code>blocks</code>意味着执行这些块的代码所花费的时间比调度它们所花费的时间要多。但是，与任何性能指标一样，您可能必须使用<code>striding value</code>(跨步值)才能为你的代码找到最有效的值。</p>
<h2 id="替换-Thread-Joins"><a href="#替换-Thread-Joins" class="headerlink" title="替换 Thread Joins"></a>替换 Thread Joins</h2><p><code>Thread Joins</code>(线程连接)允许生成一个或多个线程，然后让当前线程等待这些线程完成。为了实现<code>thread join</code>，父线程创建一个子线程作为<code>joinable thread</code>(可连接线程)。如果父线程在没有子线程的结果就无法继续进行时，它与子线程连接。该过程将阻塞父线程，直到子线程完成其任务并退出为止，此时，父线程可以从子线程收集结果并继续自己的工作。如果父级需要与多个子线程联接，则<strong>一次只连接一个</strong>子线程。</p>
<p><code>Dispatch groups</code>(调度组)提供的语义类似于<code>thread joins</code>(线程连接)的语义，但具有一些其他优势。与<code>thread joins</code>一样，<code>dispatch groups</code>是阻塞线程直到一个或多个子任务完成执行的一种方式。与<code>thread joins</code>不同，<code>dispatch group</code>同时等待其所有子任务。并且由于<code>dispatch group</code>使用<code>dispatch queues</code>执行工作，所以效率很高。</p>
<p>要使用<code>dispatch group</code>来执行<code>joinable threads</code>执行的相同工作，请执行以下操作：</p>
<ol>
<li>使用<code>dispatch_group_create</code>函数创建一个新的<code>dispatch group</code>。</li>
<li>使用<code>dispatch_group_async</code>或<code>dispatch_group_async_f</code>函数将任务添加到组中。提交给组的每个任务代表你通常在<code>joinable thread</code>上执行的工作。</li>
<li>当当前线程无法再向前推进时，请调用<code>dispatch_group_wait</code>函数以在组上等待。该功能将阻塞当前线程，直到该组中的所有任务完成执行为止。</li>
</ol>
<p>如果要使用 <code>operation objects</code> 来实现任务，则还可以使用<code>dependencies</code>(依赖项)来实现<code>thread joins</code>(线程连接)。无需让父线程等待一个或多个任务完成，你可以将父代码移动到<code>operation object</code>。然后，你将在父<code>operation object</code>和任意数量的子<code>operation object</code>之间建立依赖关系，以建立可连接线程通常执行的工作。依赖于其他<code>operation object</code>会阻止父<code>operation object</code>在所有操作完成之前执行。</p>
<h2 id="更改-Producer-Consumer-实现"><a href="#更改-Producer-Consumer-实现" class="headerlink" title="更改 Producer-Consumer 实现"></a>更改 Producer-Consumer 实现</h2><p><code>producer-consumer model</code>(生产者－消费者模型)使你可以管理有限数量的动态产生的资源。当<code>producer</code>(生产者)创建新的资源（或工作）时，一个或多个<code>consumers</code>(消费者)等待这些资源（或工作）准备就绪并消费它们。 实现<code>producer-consumer model</code>的典型机制是<code>conditions</code>(条件)或 <code>semaphores</code>(信号量)。</p>
<p>1、使用<code>conditions</code>(条件)，生产者线程 通常执行以下操作：</p>
<ul>
<li><code>Lock</code>(锁定)与<code>condition</code>(条件)关联的互斥锁（使用<code>pthread_mutex_lock</code>）。</li>
<li>生产要消耗的资源或工作。</li>
<li>向条件变量发出要消耗的<code>Signal</code>(信号)（使用<code>pthread_cond_signal</code>）</li>
<li>解锁互斥锁（使用<code>pthread_mutex_unlock</code>）。</li>
</ul>
<p>2、反过来，相应的 消费者线程 执行以下操作：</p>
<ul>
<li><p><code>Lock</code>(锁定)与条件关联的互斥锁（使用<code>pthread_mutex_lock</code>）。</p>
</li>
<li><p>设置<code>while</code>循环以执行以下操作：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a、检查是否确实有工作要做。</span><br><span class="line">b、如果没有工作要做（或没有可用资源），请调用 pthread_cond_wait 阻止当前线程，直到出现相应的信号</span><br></pre></td></tr></table></figure>

<ul>
<li>获取生产者提供的工作（或资源）。</li>
<li>解锁互斥锁（使用<code>pthread_mutex_unlock</code>）。</li>
<li>处理工作。</li>
</ul>
<p>使用<code>dispatch queues</code>，你可以将生产者和使用者实现简化为一个调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">   <span class="comment">// Process a work item.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当<code>producer</code>(生产者)有工作要做时，所有要做的就是将工作添加到<code>queue</code>中，并让<code>queue</code>处理该项目。前面代码中唯一更改的部分是队列类型。如果<code>producer</code>生成的任务需要按特定顺序执行，则可以使用<code>serial queue</code>。如果生产者生成的任务可以同时执行，则可以将它们添加到<code>concurrent queue</code>中，并让系统同时执行尽可能多的任务。</p>
<h2 id="替换-Semaphore-代码"><a href="#替换-Semaphore-代码" class="headerlink" title="替换 Semaphore 代码"></a>替换 Semaphore 代码</h2><p>如果当前正在使用<code>semaphores</code>(信号量)来限制对共享资源的访问，则应考虑使用<code>dispatch semaphores</code>。传统的<code>semaphores</code>总是要求调用内核来测试<code>semaphore</code>(信号量)。相反，<code>dispatch semaphores</code>(调度信号量)会在用户空间中快速测试<code>semaphore</code>(信号量)状态，并仅在测试失败并且需要阻塞调用线程时才捕获到内核中。在无争议的情况下，此行为导致<code>dispatch semaphores</code>比传统<code>semaphores</code>快得多。但是，在所有其他方面，<code>dispatch semaphores</code>(调度信号量)提供的行为与传统<code>semaphores</code>(信号量)相同。</p>
<h2 id="替换-Run-Loop-Code"><a href="#替换-Run-Loop-Code" class="headerlink" title="替换 Run-Loop Code"></a>替换 Run-Loop Code</h2><p>如果你使用<code>run loops</code>来管理一个或多个线程上正在执行的工作，则可能会发现<code>queues</code>(队列)的实现和维护更加简单。设置自定义<code>run loop</code>涉及设置底层线程和<code>run loop</code>本身。<code>run-loop code</code>包括设置一个或多个<code>run loop sources</code>(运行循环源)以及编写回调以处理到达这些<code>sources</code>的事件。与其所有这些工作，不如简单地创建一个<code>serial queue</code>并分派任务到它。因此，你可以用一行代码替换所有线程和<code>run-loop</code>创建代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t myNewRunLoop &#x3D; dispatch_queue_create(&quot;com.apple.MyQueue&quot;, NULL);</span><br></pre></td></tr></table></figure>

<p>因为<code>queue</code>自动执行添加到<code>queue</code>中的所有任务，所以不需要额外的代码来管理<code>queue</code>。你不必创建或配置线程，也不必创建或附加任何<code>run-loop sources</code>。此外，你只需将任务添加到<code>queue</code>中，即可在<code>queue</code>上执行新类型的工作。要对<code>run loop</code>执行相同的操作，将需要修改现有的<code>run loop source</code>或创建一个新的<code>run loop source</code>来处理新数据。</p>
<p><code>run loops</code>的一种常见配置是处理异步到达<code>network socket</code>(网络套接字)的数据。可以将<code>dispatch source</code>(调度源)附加到所需的<code>queue</code>，而不是为此类型的行为配置<code>run loop</code>。与传统的<code>run loop sources</code>相比，<code>Dispatch sources</code>还提供了更多的数据处理选项。除了处理<code>timer</code>和<code>network port events</code>之外，还可以使用<code>dispatch sources</code>来读取和写入文件，监视文件系统对象，监视进程以及监视信号。甚至可以定义自定义<code>dispatch sources</code>，并从代码的其他部分异步触发它们。</p>
<h2 id="与-POSIX-Threads-的兼容性"><a href="#与-POSIX-Threads-的兼容性" class="headerlink" title="与 POSIX Threads 的兼容性"></a>与 POSIX Threads 的兼容性</h2><p>因为 <code>Grand Central Dispatch</code> 管理着你提供的任务和运行这些任务的线程之间的关系，所以通常应该避免从任务代码中调用 <code>POSIX thread</code> 例程。如果确实由于某种原因需要调用它们，则应非常谨慎地调用哪些例程。本节向你说明在排队的任务中哪些例程可以安全调用，哪些例程不安全 该列表并不完整，但是应该告诉您什么是安全的，什么不是安全的。</p>
<p>通常，你的应用程序不得删除或更改它未创建的对象或数据结构。因此，使用<code>dispatch queue</code>执行的块对象不得调用以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach</span><br><span class="line">pthread_cancel</span><br><span class="line">pthread_join</span><br><span class="line">pthread_kill</span><br><span class="line">pthread_exit</span><br></pre></td></tr></table></figure>

<p>尽管可以在任务运行时修改线程的状态，但是必须在任务返回之前将线程返回到其原始状态。 因此，只要将线程返回到其原始状态，就可以安全地调用以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_setcancelstate</span><br><span class="line">pthread_setcanceltype</span><br><span class="line">pthread_setschedparam</span><br><span class="line">pthread_sigmask</span><br><span class="line">pthread_setspecific</span><br></pre></td></tr></table></figure>

<p>用于执行给定块的基础线程可以在调用之间变化。 因此，您的应用程序不应依赖以下函数，这些函数在块的调用之间返回可预测的结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_self</span><br><span class="line">pthread_getschedparam</span><br><span class="line">pthread_get_stacksize_np</span><br><span class="line">pthread_get_stackaddr_np</span><br><span class="line">pthread_mach_thread_np</span><br><span class="line">pthread_from_mach_thread_np</span><br><span class="line">pthread_getspecific</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Blocks</code>必须捕获并抑制其中抛出的任何<code>language-level exceptions</code>(语言级别的异常)。 在执行<code>Blocks</code>期间发生的其他错误应类似地由该块处理或用于通知应用程序的其他部分。</p>
</blockquote>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1" target="_blank" rel="noopener">Migrating Away from Threads</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/24/Threads-%E4%B8%83-%E8%BF%9C%E7%A6%BB%E7%BA%BF%E7%A8%8B/">http://yoursite.com/2020/10/24/Threads-%E4%B8%83-%E8%BF%9C%E7%A6%BB%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/27/Runloop-%E4%BA%8C-Runloop-%E7%9A%84%E4%BD%BF%E7%94%A8/"><i class="fa fa-chevron-left">  </i><span>Runloop(二)Runloop 的使用</span></a></div><div class="next-post pull-right"><a href="/2020/10/23/Threads-%E5%85%AD-GCD-Dispatch-Sources/"><span>Threads(六)GCD - Dispatch Sources</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>