<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(四)Operation Queues"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(四)Operation Queues | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperation"><span class="toc-number">1.</span> <span class="toc-text">NSOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发与非并发操作"><span class="toc-number">2.</span> <span class="toc-text">并发与非并发操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperation-子类的基本使用"><span class="toc-number">3.</span> <span class="toc-text">NSOperation 子类的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NSInvocationOperation"><span class="toc-number">3.1.</span> <span class="toc-text">NSInvocationOperation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSBlockOperation"><span class="toc-number">3.2.</span> <span class="toc-text">NSBlockOperation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义NSOperation"><span class="toc-number">4.</span> <span class="toc-text">自定义NSOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行主要任务"><span class="toc-number">4.1.</span> <span class="toc-text">执行主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应取消事件"><span class="toc-number">4.2.</span> <span class="toc-text">响应取消事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将自定义Operation配置为并发"><span class="toc-number">4.3.</span> <span class="toc-text">将自定义Operation配置为并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保持遵循-KVO"><span class="toc-number">4.4.</span> <span class="toc-text">保持遵循 KVO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义Operation的执行行为"><span class="toc-number">5.</span> <span class="toc-text">自定义Operation的执行行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置互操作依赖项"><span class="toc-number">5.1.</span> <span class="toc-text">配置互操作依赖项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更改Operation的执行优先级"><span class="toc-number">5.2.</span> <span class="toc-text">更改Operation的执行优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更改基础线程优先级"><span class="toc-number">5.3.</span> <span class="toc-text">更改基础线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-Completion-Block"><span class="toc-number">5.4.</span> <span class="toc-text">配置 Completion Block</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operation-Object实施的技巧"><span class="toc-number">6.</span> <span class="toc-text">Operation Object实施的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管理-Operation-Object-中的内存"><span class="toc-number">6.1.</span> <span class="toc-text">管理 Operation Object 中的内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#避免线程存储-Per-Thread-Storage"><span class="toc-number">6.1.1.</span> <span class="toc-text">避免线程存储(Per-Thread Storage)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据需要保留对Operation-Object的引用"><span class="toc-number">6.1.2.</span> <span class="toc-text">根据需要保留对Operation Object的引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理错误和异常"><span class="toc-number">6.2.</span> <span class="toc-text">处理错误和异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定Operation-Objects的适当范围"><span class="toc-number">7.</span> <span class="toc-text">确定Operation Objects的适当范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行Operations"><span class="toc-number">8.</span> <span class="toc-text">执行Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#把-Operations-添加到-Operation-Queue-执行"><span class="toc-number">8.1.</span> <span class="toc-text">把 Operations 添加到 Operation Queue 执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Operation-添加到-Operation-Queue-的方法"><span class="toc-number">8.1.1.</span> <span class="toc-text">Operation 添加到 Operation Queue 的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动执行-Operations"><span class="toc-number">8.2.</span> <span class="toc-text">手动执行 Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取消操作"><span class="toc-number">8.3.</span> <span class="toc-text">取消操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待操作完成"><span class="toc-number">8.4.</span> <span class="toc-text">等待操作完成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#挂起和恢复队列"><span class="toc-number">8.5.</span> <span class="toc-text">挂起和恢复队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">9.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(四)Operation Queues</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><ul>
<li><p><code>Cocoa operations</code>是一种面向对象的方式，用于封装要异步执行的工作。</p>
</li>
<li><p><code>Operation</code>被设计成可以与<code>operation queue</code>一起使用，也可以单独使用。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li>由于<code>Operation</code>是基于<code>Objective-C</code>的，所以在<code>MacOS</code>和<code>iOS</code>基于<code>Cocoa</code>的应用程序中最常使用。</li>
</ul>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><ul>
<li><p>在<code>Foundation</code>框架中，<code>operation object</code>是<code>NSOperation</code>类的一个实例，用于封装你希望应用程序执行的工作，适用于 <code>iOS 2.0+</code>。</p>
</li>
<li><p><code>NSOperation</code>是一个抽象基类，它提供了大量的基础结构，以最大程度地减少你必须在自己的子类中完成的工作量。必须对<code>NSOperation</code>进行子类化才能做任何有用的工作。</p>
</li>
<li><p><code>operation object</code>是一个单发(<code>single-shot</code>)对象，即，它只执行一次任务，而不能再使用它执行一次。</p>
</li>
<li><p><code>Foundation</code>框架提供了两个<code>NSOperation</code>的子类，可以在现有代码中按原样使用。如下表所示：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>NSInvocationOperation</td>
<td>用于初始化一个<code>operation</code>，这个<code>operation</code>包括调用一个<code>object</code>上的<code>selector</code>。如果你具有已执行所需任务的现有方法，则可以使用此类。此类实现了一个非并发操作。</td>
</tr>
<tr>
<td>NSBlockOperation</td>
<td>用于并发的执行一个或多个<code>block</code>对象的类。只有当所有相关<code>block</code>都已完成执行时，<code>operation</code>本身才被视为已完成。</td>
</tr>
<tr>
<td>custom NSOperation</td>
<td>子类化<code>NSOperation</code>可以让你完全控制自己操作的实现，包括改变操作执行 和 报告其状态的默认方式的能力。</td>
</tr>
</tbody></table>
<p>所有<code>NSOperation</code>对象都支持以下关键功能：</p>
<ul>
<li><p>支持在<code>operation</code>对象之间建立 <code>graph-based dependencies</code>(基于图的依赖关系、执行顺序图)。这些<code>dependencies</code>(依赖关系)会阻止给定<code>operations</code>运行，直到它所依赖的所有操作都已运行完毕。</p>
</li>
<li><p>支持可选的<code>completion block</code>，该<code>block</code>在<code>operations</code>的主任务完成后执行。</p>
</li>
<li><p>支持使用<code>KVO</code>通知监听 <code>operations</code> 执行状态的变化。</p>
</li>
<li><p>支持对<code>operations</code>进行优先级排序，从而影响它们相对执行顺序。</p>
</li>
<li><p>支持取消语义(<code>cancel</code>)，允许在执行<code>operation</code>时暂停操作。</p>
</li>
</ul>
<p><code>Operations</code>旨在帮助你提高应用程序中的并发水平。<code>Operations</code>也是将应用程序的行为组织并封装为简单的离散块 (<code>discrete chunks</code>) 的好方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSOperation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name   <span class="comment">// operation的名称，便于调试时识别它</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing;    <span class="comment">// 表示operation当前是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="built_in">BOOL</span> finished;      <span class="comment">// 表示operation是否已完成其任务的执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isAsynchronous) <span class="built_in">BOOL</span> asynchronous;  <span class="comment">// 表示operation是否异步执行其任务。对于相对于当前线程异步运行的操作，此属性的值为YES，对于在当前线程上同步运行的操作，此属性的值为NO。默认值为NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isReady) <span class="built_in">BOOL</span> ready;    <span class="comment">// 表示是否可以立即执行operation。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Operation之间的依赖关系。应避免创建任何循环依赖关系，会导致死锁</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSOperation</span> *&gt; *dependencies;</span><br><span class="line">- (<span class="keyword">void</span>)addDependency:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line">- (<span class="keyword">void</span>)removeDependency:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start;   <span class="comment">// 开始执行操作</span></span><br><span class="line">- (<span class="keyword">void</span>)main;    <span class="comment">// 执行接收方的非并发任务</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 表示Operation是否已取消，默认值为NO。调用cancel方法会将其值置为YES。</span></span><br><span class="line"><span class="comment">// 取消操作不会主动停止接收器的代码执行。操作对象负责定期调用此方法，并在方法返回YES时停止自身。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>);   <span class="comment">// Operation执行完后执行的block</span></span><br><span class="line"><span class="comment">// 阻止当前线程的执行，直到操作对象完成其任务为止。</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSOperationQueuePriority</span> queuePriority;   <span class="comment">// 操作队列中操作的执行优先级</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSQualityOfService</span> qualityOfService  <span class="comment">// 将系统资源授予操作的相对重要性</span></span><br></pre></td></tr></table></figure>

<h2 id="并发与非并发操作"><a href="#并发与非并发操作" class="headerlink" title="并发与非并发操作"></a>并发与非并发操作</h2><p>1、<code>operations</code> 和 <code>operation queue</code></p>
<p>通常，通过将<code>operations</code>添加到<code>operation queue</code>来执行它们，但这样做不是必需的。也可以通过调用<code>operation object</code>的<code>start</code>方法手动执行它，但这样做不能保证<code>operation</code>与其余代码同时运行。<code>NSOperation</code>类的<code>isConcurrent</code>方法告诉你<code>operation</code>相对于调用 其<code>start</code>方法的线程而言，是同步运行还是异步运行。默认情况下，该方法返回<code>NO</code>，这意味着<code>operation</code>在调用线程中同步运行。</p>
<p>2、关于 <code>concurrent operation</code>(并发操作)</p>
<p>如果你想实现一个<code>concurrent operation</code>(并发操作)，即相对于调用线程异步运行的<code>operation</code>，你必须编写其它的代码来异步启动<code>operation</code>。例如，你可以生成一个单独的线程、调用一个异步系统函数、或者执行任何其他操作，以确保<code>start</code>方法启动任务并立即返回，而且很可能是在任务完成之前返回。</p>
<p>大多数开发人员不需要实现 <code>concurrent operation objects</code>(并发操作对象)。<br>如果总是将 <code>operation</code> 添加到 <code>operation queue</code> 中，你就不需要实现 <code>concurrent operation</code>(并发操作)。当你将<code>nonconcurrent operation</code>(非并发操作)提交给<code>operation queue</code>(操作队列)时，<code>queue</code> 本身会创建一个线程，在该线程上运行<code>operation</code>。因此，向 <code>operation queue</code> 添加 <code>nonconcurrent operation</code> 仍然会导致<code>operation</code>对象代码的异步执行。只有在需要 异步执行 <code>operation</code> 而不将其添加到 <code>operation queue</code> 的情况下，才需要定义 <code>concurrent operation</code>。</p>
<h2 id="NSOperation-子类的基本使用"><a href="#NSOperation-子类的基本使用" class="headerlink" title="NSOperation 子类的基本使用"></a>NSOperation 子类的基本使用</h2><h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><p><code>NSInvocationOperation</code>对象在运行时，它将调用你在指定对象上指定的 <code>selector</code>。这个类实现了一个<code>non-concurrent operation</code>(非并发操作)。</p>
<p>使用此类可以避免为应用程序中的每个任务定义大量自定义<code>operation objects</code>。特别是如果你正在修改现有应用程序，并且已经拥有执行必要任务所需的对象和方法的情况下。当你要调用的方法可能会根据情况发生变化时，也可以使用它。例如，您可以使用<code>invocation operation</code> 执行根据用户输入动态选择的 <code>selector</code>。</p>
<p><code>NSInvocationOperation</code> 只能用于<code>OC</code>，没有<code>swift</code>对应的类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *oper = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download:) object:<span class="string">@"开始下载"</span>];</span><br><span class="line">oper.completionBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行完毕, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">[oper start];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印： </span></span><br><span class="line"><span class="comment">// 开始下载, &lt;NSThread: 0x600002dd6900&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// 执行完毕, &lt;NSThread: 0x6000028d8700&gt;&#123;number = 5, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><p><code>NSBlockOperation</code>充当一个或多个<code>block</code>对象并发执行的包装器(<code>wrapper</code>)。</p>
<p>此类为已经在使用 <code>operation queues</code> 并且不想同时创建 <code>dispatch queues</code>(调度队列) 的应用程序提供了面向对象的包装器。还可以使用 <code>block operations</code> 来利用<code>dispatch queues</code>(调度队列)中可能不具备的 操作依赖项、KVO通知 和 其他功能。</p>
<p>当你创建一个 <code>block operation</code> 时，通常在初始化时添加至少一个<code>block</code>，稍后根据需要添加更多的<code>block</code>。当需要执行 <code>NSBlockOperation</code> 对象时，该对象将所有 <code>block</code> 提交给默认优先级的并发调度队列(<code>concurrent dispatch queue</code>)。然后，该对象将等待所有 <code>block</code> 执行完成。当最后一个块完成执行时，<code>operation object</code> 将自己标记为<code>finished</code>。</p>
<p>因此，您可以使用 <code>block operation</code> 来跟踪一组正在执行的 <code>block</code>，就像使用线程连接来合并来自多个线程的结果一样。不同的是，因为 <code>block operation</code> 本身运行在单独的线程上，所以应用程序的其他线程可以在等待 <code>block operation</code> 完成时继续工作。</p>
<p>如果需要让 <code>NSBlockOperation</code> 串行执行 <code>block</code> 对象，则必须将它们直接提交到所需的分派队列(<code>dispatch queue</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> operation = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"init---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"add1---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"add2---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation.completionBlock = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"completion---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="keyword">init</span>--- &lt;<span class="type">NSThread</span>: <span class="number">0x600002956980</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">add1--- &lt;<span class="type">NSThread</span>: <span class="number">0x60000297ac80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">add2--- &lt;<span class="type">NSThread</span>: <span class="number">0x6000029c41c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">completion--- &lt;<span class="type">NSThread</span>: <span class="number">0x6000029c41c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h2><p>如果<code>block operation</code> 和 <code>invocation operation</code> 不能完全满足应用程序的需求，则可以直接将<code>NSOperation</code>子类化，并添加所需的任何行为。 自定义<code>NSOperation</code>需要做的额外工作量，取决于你要实现的是<code>nonconcurrent</code>(非并发)还是<code>concurrent</code>(并发)<code>operation</code>。具体可以查看Apple的示例代码<a href="https://developer.apple.com/library/archive/samplecode/NSOperationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS10004184" target="_blank" rel="noopener">NSOperationSample</a></p>
<p>定义 <code>nonconcurrent operation</code> (非并发操作)比定义 <code>concurrent operation</code> (并发操作) 简单得多。对于非并发操作，您所要做的就是执行主要任务并适当响应取消事件；现有类基础设施为您完成所有其他工作。对于并发操作，您必须用自定义代码替换一些现有基础设施。</p>
<h3 id="执行主要任务"><a href="#执行主要任务" class="headerlink" title="执行主要任务"></a>执行主要任务</h3><p>每个<code>Operation</code>对象至少实现以下方法：</p>
<ul>
<li>自定义<code>initialization</code>方法，用来将操作对象放入已知状态。</li>
<li><code>main</code>方法，用于执行任务。</li>
</ul>
<p>也可根据需要实现其它方法，例如：</p>
<ul>
<li>计划在<code>main</code> 方法中调用的自定义方法</li>
<li>用于设置数据值，访问<code>Operation</code>结果的方法</li>
<li><code>NSCoding</code>协议的方法，对<code>Operation</code>对象归档和解归档</li>
</ul>
<h3 id="响应取消事件"><a href="#响应取消事件" class="headerlink" title="响应取消事件"></a>响应取消事件</h3><p><code>Operation</code>在执行其任务时，取消操作可能随时发生，尽管<code>NSOperation</code>提供了<code>cancel</code>方法，但是识别取消事件是必要的。如果一个 <code>operation</code> 被直接终止，可能没有办法回收已分配的资源。因此，<code>operation objects</code> 需要检查取消事件，当它们在操作过程中发生时，优雅地退出。</p>
<p>为了让 <code>operation object</code> 支持 <code>cancel</code> 操作，需要在自定义代码中定期的调用 <code>isCancelled</code> 判断是否返回。<code>isCancelled</code>方法本身是非常轻量级的，可以频繁调用，而不会对性能造成很大的影响。</p>
<p>通常，在<code>Custom Operation</code>的代码中以下位置调用 <code>isCancelled</code> 方法：</p>
<ul>
<li>在你执行任何实际工作之前；</li>
<li>在循环的每次迭代期间至少一次，如果每次迭代相对较长，则更频繁；</li>
<li>在代码中相对容易中止操作的任何位置；</li>
</ul>
<h3 id="将自定义Operation配置为并发"><a href="#将自定义Operation配置为并发" class="headerlink" title="将自定义Operation配置为并发"></a>将自定义Operation配置为并发</h3><p><code>Operation objects</code> 默认以同步方式执行，也就是说，它们在调用其<code>start</code>方法的线程中执行其任务。由于操作队列为非并发操作提供了线程，因此大多数操作仍然异步运行。</p>
<p>为了实现并发<code>Operation</code>，通常需要重写如下表方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>（必需）concurrent operations必须重写此方法，，并用它们自己的自定义实现替换默认行为。要手动执行操作，需要调用其start方法。因此，此方法的实现是操作的起点，也是设置执行任务的线程或其他执行环境的地方。您的实现在任何时候都不能调用super。</td>
</tr>
<tr>
<td>main</td>
<td>(可选)此方法通常用于实现与操作对象关联的任务。尽管可以在start方法中执行任务，但使用此方法实现任务可以使设置代码和任务代码更清晰地分离。</td>
</tr>
<tr>
<td>isExecuting isFinished</td>
<td>（必需）并发操作负责设置其执行环境并向外部客户报告该环境的状态。因此，并发操作必须维护一些状态信息，以便知道它何时在执行其任务以及何时完成了该任务。然后它必须使用这些方法报告该状态。 <br><br>这些方法的实现必须是安全的，才能同时从其他线程调用。更改这些方法报告的值时，还必须为预期的密钥路径生成适当的KVO通知。</td>
</tr>
<tr>
<td>isConcurrent</td>
<td>（必需）若要将操作标识为并发操作，请重写此方法并返回“是”。</td>
</tr>
</tbody></table>
<p>1、Custom nonconcurrent Operations</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZMOperation</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*strArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZMOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithData: (<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)arr &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.strArray = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行接收方的非并发任务。重写此方法以执行所需的任务。</span></span><br><span class="line"><span class="comment">// 此方法将在NSOperation提供的 autorelease pool 中自动执行，因此您不需要在实现中创建自己的 autorelease pool块。</span></span><br><span class="line"><span class="comment">// 如果要实现并发操作，则不需要重写此方法；但如果计划从自定义start方法调用它，则可以这样做。</span></span><br><span class="line">- (<span class="keyword">void</span>)main&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> isDone = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (![<span class="keyword">self</span> isCancelled] &amp;&amp; !isDone) &#123;    <span class="comment">// 执行任务前判断是否 取消操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.strArray.count; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;   <span class="comment">// 每次迭代期间是否 取消操作</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, <span class="keyword">self</span>.strArray[i], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="keyword">self</span>.strArray.count - <span class="number">1</span>) &#123;     <span class="comment">// 任务结束后</span></span><br><span class="line">                isDone = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZMOperation *operation = [[ZMOperation alloc] initWithData:@[<span class="string">@"111"</span>, <span class="string">@"222"</span>, <span class="string">@"333"</span>]];</span><br><span class="line">operation.completionBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"completion---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">[operation start];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="comment">// 111, &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// 222, &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// 333, &lt;NSThread: 0x6000017ea940&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// XPC connection interrupted</span></span><br><span class="line"><span class="comment">// completion---&lt;NSThread: 0x6000017d3d80&gt;&#123;number = 3, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<p>2、Custom concurrent Operations</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyOperation</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span>  executing;</span><br><span class="line">    <span class="built_in">BOOL</span>  finished;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        executing = <span class="literal">NO</span>;</span><br><span class="line">        finished = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// 任务开始前，检查是否 取消操作</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// operation被取消，将任务置为完成</span></span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// operation未被取消，则开始执行任务</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">    executing = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">   <span class="keyword">@try</span> &#123;</span><br><span class="line">       <span class="comment">// 开始执行operation</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.strArray.count; i++) &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;   <span class="comment">// 每次迭代期间是否 取消操作</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, <span class="keyword">self</span>.strArray[i], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">           [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [<span class="keyword">self</span> completeOperation];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">@catch</span>(...) &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完成操作</span></span><br><span class="line">- (<span class="keyword">void</span>)completeOperation &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line"> </span><br><span class="line">    executing = <span class="literal">NO</span>;</span><br><span class="line">    finished = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isConcurrent &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> executing;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class="line">operation.strArray = @[<span class="string">@"111"</span>, <span class="string">@"222"</span>, <span class="string">@"333"</span>];</span><br><span class="line">operation.completionBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"completion---%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">[operation start];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// 111, &lt;NSThread: 0x600003f191c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 222, &lt;NSThread: 0x600003f191c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 333, &lt;NSThread: 0x600003f191c0&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// completion---&lt;NSThread: 0x600003f361c0&gt;&#123;number = 3, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="保持遵循-KVO"><a href="#保持遵循-KVO" class="headerlink" title="保持遵循 KVO"></a>保持遵循 KVO</h3><p>NSOperation类的以下<code>key path</code>(关键路径)遵循<code>KVO</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">isCancelled</span><br><span class="line">isConcurrent</span><br><span class="line">isExecuting</span><br><span class="line">isFinished</span><br><span class="line">isReady</span><br><span class="line">dependencies</span><br><span class="line">queuePriority</span><br><span class="line">completionBlock</span><br></pre></td></tr></table></figure>

<p>例如：重写 <code>start</code> 时，需要关注 <code>isExecuting</code>、<code>isFinished</code> 仍然遵循 <code>KVO</code> 要求</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">operation.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"isFinished"</span>, options: [.new], context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(keyPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="自定义Operation的执行行为"><a href="#自定义Operation的执行行为" class="headerlink" title="自定义Operation的执行行为"></a>自定义Operation的执行行为</h2><p><code>operation objects</code>的配置发生在创建它们后，但在将它们添加到队列(<code>queue</code>)之前。下面描述的配置类型可以应用于所有<code>operation objects</code>，无论您是自己将<code>NSOperation</code>子类化还是使用现有子类。</p>
<h3 id="配置互操作依赖项"><a href="#配置互操作依赖项" class="headerlink" title="配置互操作依赖项"></a>配置互操作依赖项</h3><p><code>Dependencies</code>(依赖项)是 <strong>序列化</strong> 不同<code>operation objects</code>的执行的一种方式。</p>
<p>依赖于其他<code>operation</code>的<code>operation</code> 在 其依赖 的所有<code>operation</code> 完成执行之前不能开始执行。因此，可以使用依赖关系在两个 <code>operation object</code> 之间创建简单的一对一依赖关系，或者构建复杂的对象依赖关系图(<code>dependency graphs</code>)。</p>
<p>要在两个<code>operation object</code>之间建立依赖关系，需要使用 <code>NSOperation</code> 的<code>addDependency:</code> 方法。此方法创建从当前<code>operation object</code>到指定为参数的目标<code>operation</code>的单向依赖关系。这种依赖性意味着在目标对象完成执行之前，当前对象无法开始执行。</p>
<p><code>Operation object</code>管理它们自己的依赖关系，因此可以在<code>operation</code>之间创建依赖关系并将它们全部添加到不同的<code>queue</code> 中。注意，不能在 <code>operation</code> 之间创建循环依赖关系，这样做将阻止受影响的<code>operation</code> 永远运行。</p>
<p>当<code>operation</code>的所有依赖项都已完成执行后，<code>operation object</code>通常可以执行了。 （如果自定义<code>isReady</code>方法的行为，则<code>operation</code>的就绪状态由您设置的条件决定。）如果 <code>operation object</code> 在队列中，则该队列可随时开始执行该操作。如果计划手动执行该<code>operation</code>，则由您调用该<code>operation</code>的<code>start</code>方法。</p>
<blockquote>
<p>注意：必须在运行<code>operation</code>或将其添加到<code>operation queue</code>之前配置依赖项，之后添加的依赖项可能不会阻止给定的 <code>operation object</code> 运行。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue1 = <span class="type">OperationQueue</span>()</span><br><span class="line"><span class="keyword">let</span> downOper1 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"downOper1---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> downOper2 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"downOper2---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> queue2 = <span class="type">OperationQueue</span>()</span><br><span class="line"><span class="keyword">let</span> upOper1 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"upOper1---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> upOper2 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"upOper2---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在不同operation之间建立依赖关系</span></span><br><span class="line"><span class="comment">// 执行顺序图为：upOper2 -&gt; upOper1 -&gt; downOper2 - &gt; downOper1</span></span><br><span class="line">downOper1.addDependency(downOper2)</span><br><span class="line">downOper2.addDependency(upOper1)</span><br><span class="line">upOper1.addDependency(upOper2)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 把operation分别添加到不同的queue中</span></span><br><span class="line">queue1.addOperation(downOper1)</span><br><span class="line">queue1.addOperation(downOper2)</span><br><span class="line">queue2.addOperation(upOper1)</span><br><span class="line">queue2.addOperation(upOper2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">upOper2--- &lt;<span class="type">NSThread</span>: <span class="number">0x600000fdc5c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">upOper1--- &lt;<span class="type">NSThread</span>: <span class="number">0x600000fc8f40</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line">downOper2--- &lt;<span class="type">NSThread</span>: <span class="number">0x600000fc8f40</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line">downOper1--- &lt;<span class="type">NSThread</span>: <span class="number">0x600000f3bb40</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更改Operation的执行优先级"><a href="#更改Operation的执行优先级" class="headerlink" title="更改Operation的执行优先级"></a>更改Operation的执行优先级</h3><p>对于添加到队列中的<code>operations</code>，执行顺序 首先 由排队操作(<code>queued operations</code>)的就绪状态决定，然后 由它们的相对优先级(<code>relative priority</code>)决定。</p>
<ul>
<li><p>是否准备就绪取决于<code>operation</code>对其他<code>operations</code>的依赖性，但是<code>priority level</code>(优先级)是<code>operation</code>对象本身的属性。</p>
</li>
<li><p><code>Priority levels</code>仅适用于同一<code>operation queue</code>中的<code>operation</code>。在不同的队列中的<code>low-priority operations</code>仍然可以在<code>high-priority operations</code>之前执行。</p>
</li>
<li><p><code>Priority levels</code>不能替代依赖关系。</p>
</li>
</ul>
<p><code>Priority levels</code>确定<code>operation queue</code>开始仅执行当前准备就绪的那些<code>operations</code>的顺序。例如，如果队列同时包含<code>high-priority</code>和<code>low-priority</code>的<code>operation</code>，并且两个<code>operation</code>都准备就绪，则该队列首先执行<code>high-priority operation</code>。但是，如果<code>high-priority operation</code>尚未准备就绪，但<code>low-priority operation</code>已准备就绪，则队列首先执行<code>low-priority operation</code>。如果要阻止某个<code>operation</code>在另一<code>operation</code>完成之前开始，则必须使用依赖项（如配置互操作依赖项中所述）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">OperationQueue</span>()</span><br><span class="line"><span class="keyword">let</span> operation1 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation1---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation1.queuePriority = .low</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> operation2 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation2---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation2.queuePriority = .normal</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> operation3 = <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"operation3---"</span>, <span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line">operation3.queuePriority = .high</span><br><span class="line">    </span><br><span class="line">queue.addOperation(operation1)</span><br><span class="line">queue.addOperation(operation2)</span><br><span class="line">queue.addOperation(operation3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line">operation3--- &lt;<span class="type">NSThread</span>: <span class="number">0x600001d1de00</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line">operation2--- &lt;<span class="type">NSThread</span>: <span class="number">0x600001d3edc0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line">operation1--- &lt;<span class="type">NSThread</span>: <span class="number">0x600001d3fbc0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更改基础线程优先级"><a href="#更改基础线程优先级" class="headerlink" title="更改基础线程优先级"></a>更改基础线程优先级</h3><p>系统中的线程策略(<code>Thread policies</code>)本身由内核管理，但是通常，优先级较高的线程比低优先级的线程有更多的运行机会。</p>
<p>在<code>operation object</code>中，将线程优先级指定为<code>0.0～1.0</code>的浮点值，其中0.0是最低优先级，而1.0是最高优先级。如果未指定显式线程优先级，则<code>operation</code>将以默认线程优先级0.5运行。</p>
<p>要设置<code>operation</code>的线程优先级，则必须先调用<code>operation object</code>的<code>setThreadPriority:</code>方法，然后再将其添加到队列（或手动执行）。在执行<code>operation</code>时，默认的<code>start</code>方法使用您指定的值来修改当前线程的优先级。此新优先级仅在<code>operation</code>的<code>main</code>方法期间有效。所有其他代码（包括<code>operation</code> 的 <code>completion block</code>）均以默认线程优先级运行。如果创建<code>concurrent operation</code>，并因此重写了<code>start</code>方法，则必须自己配置线程优先级。</p>
<h3 id="配置-Completion-Block"><a href="#配置-Completion-Block" class="headerlink" title="配置 Completion Block"></a>配置 Completion Block</h3><p>一个 <code>operation</code> 可以在其主要任务完成执行时执行<code>completion block</code>，通过<code>NSOperation</code> 的 <code>setCompletionBlock:</code> 方法。</p>
<p>可以使用<code>completion block</code>来执行不属于主要任务的任何工作。 例如，您可以使用此块来通知感兴趣的客户端操作本身已完成。 并发操作对象可以使用此<code>block</code>来生成其最终的<code>KVO</code>通知。</p>
<h2 id="Operation-Object实施的技巧"><a href="#Operation-Object实施的技巧" class="headerlink" title="Operation Object实施的技巧"></a>Operation Object实施的技巧</h2><p>尽管<code>Operation Object</code>很容易实现，但在编写代码时，有几件事您应该注意。以下部分描述了在为<code>Operation Object</code>编写代码时应考虑的因素。</p>
<h3 id="管理-Operation-Object-中的内存"><a href="#管理-Operation-Object-中的内存" class="headerlink" title="管理 Operation Object 中的内存"></a>管理 <code>Operation Object</code> 中的内存</h3><p>以下各节描述了<code>operation object</code>中良好内存管理的关键元素。关于Objective-C程序中内存管理的一般信息，请参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">《高级内存管理编程指南》</a>。</p>
<h4 id="避免线程存储-Per-Thread-Storage"><a href="#避免线程存储-Per-Thread-Storage" class="headerlink" title="避免线程存储(Per-Thread Storage)"></a>避免线程存储(Per-Thread Storage)</h4><p>尽管大多数<code>operations</code>在线程上执行，但对于<code>nonconcurrent operations</code>，该线程通常由<code>operation queue</code>提供。如果<code>operation queue</code>为你提供了线程，你应该认为该线程属于该队列，而不是你您的<code>operation</code>所触及。具体地说，绝不应该将任何数据与 不是自己创建或管理的线程 相关联。</p>
<p><code>operation queue</code>管理的线程来来往往取决于系统和应用程序的需求。因此，使用<code>per-thread storage</code>(线程的存储)在<code>operation</code>之间传递数据是不可靠的，而且很可能失败。</p>
<p>对于<code>operation object</code>，在任何情况下都不应该使用<code>per-thread storage</code>。初始化<code>operation</code>对象时，应为该对象提供完成其工作所需的一切。因此，<code>operation object</code>本身提供了所需的上下文存储。所有传入和传出的数据都应存储在此处，直到它们可以集成回应用程序中或者不再需要。</p>
<h4 id="根据需要保留对Operation-Object的引用"><a href="#根据需要保留对Operation-Object的引用" class="headerlink" title="根据需要保留对Operation Object的引用"></a>根据需要保留对Operation Object的引用</h4><p>仅仅因为<code>operation object</code>是异步运行的，你不应该假设你可以创建它们而忽略它们。它们仍然只是对象，由你来管理代码所需的对它们的任何引用。如果您需要在<code>operation</code>完成后从中检索结果数据，这一点尤其重要。</p>
<p>你应该始终保留自己对<code>operations</code>的引用的原因是，你以后可能没有机会向队列请求对象。队列尽一切努力尽可能快的调度和执行<code>operation</code>。 在许多情况下，队列在添加后几乎立即开始执行<code>operation</code>。当你自己的代码返回到队列以获取对<code>operation</code>的引用时，，该<code>operation</code>可能已经完成并从队列中删除。</p>
<h3 id="处理错误和异常"><a href="#处理错误和异常" class="headerlink" title="处理错误和异常"></a>处理错误和异常</h3><p>因为<code>operations</code>本质上是应用程序中离散的实体(<code>discrete entities</code>)，所以它们负责处理出现的任何错误或异常。<code>NSOperation</code> 类提供的默认<code>start</code>方法不会捕获异常。你自己的代码应该总是直接捕获和抑制异常。它还应该检查错误代码，并根据需要通知应用程序的适当部分。如果重写了<code>start</code>方法，则必须以类似的方式捕获自定义实现中的任何异常，以防止它们离开底层线程的作用域。</p>
<p>你应该准备好处理以下几种错误情况:</p>
<p>1、检查和处理<code>UNIX errno-style</code>的错误代码。</p>
<p>2、检查方法和函数返回的显式错误代码。</p>
<p>3、捕获由你自己的代码或其他系统框架抛出的异常。</p>
<p>4、捕获由<code>NSOperation</code>类本身抛出的异常，它在以下情况下抛出异常:</p>
<ul>
<li>当<code>operation</code>尚未准备好执行，但调用了它的<code>start</code>方法时</li>
<li>当<code>operation</code>正在执行或完成时(可能是因为它被取消了)，它的<code>start</code>方法被再次调用</li>
<li>尝试向已经执行或已完成的<code>operation</code>添加<code>completion block</code>时</li>
<li>当你试图检索被取消的<code>NSInvocationOperation</code>对象的结果时</li>
</ul>
<p>如果你的自定义代码确实遇到了异常或错误，则应该采取任何必要的步骤将该错误传播到应用程序的其余部分。<code>NSOperation</code>类不提供显式方法来将错误结果代码或异常传递给应用程序的其他部分。因此，如果这些信息对应用程序很重要，则必须提供必要的代码。</p>
<h2 id="确定Operation-Objects的适当范围"><a href="#确定Operation-Objects的适当范围" class="headerlink" title="确定Operation Objects的适当范围"></a>确定Operation Objects的适当范围</h2><p>尽管可以向<code>operation queue</code>中添加任意数量的<code>operation</code>，但这样做通常是不切实际的。与任何对象一样，<code>NSOperation</code>类的实例消耗内存，并具有与其执行相关的实际成本。如果你的每个 <code>operation objects</code> 仅执行少量工作，并且你创建了数以万计的<code>operation objects</code>，那么你可能会发现调度操作(<code>dispatching operations</code>)所花的时间比实际工作要多。而且，如果你的应用程序已经受到内存限制(<code>memory-constrained</code>)，你可能会发现仅仅在内存中包含成千上万个<code>operation objects</code>可能会进一步降低性能。</p>
<ul>
<li><p>有效使用<code>operations</code>的关键是 在需要做的工作量 和 保持计算机繁忙 之间找到一个适当的平衡。<br>尽量确保你的<code>operations</code>完成了合理的工作量。例如，如果你的应用程序创建了100个<code>operation objects</code>以对100个不同的值执行相同的任务，那么请考虑创建10个<code>operation objects</code>来分别处理10个值。</p>
</li>
<li><p>还应该避免一次性向<code>queue</code>中添加大量<code>operations</code>，或者避免将<code>operation objects</code>连续添加到队列中的速度快于处理对象的速度。与其用<code>operation objects</code>充斥队列，不如成批创建这些对象。当一个批处理完成执行时，使用<code>completion block</code>告诉应用程序创建一个新的批处理。当你有很多工作要做时，你希望队列中充满足够的操作，从而使计算机保持忙碌，但您不希望一次创建这么多操作，从而使应用程序耗尽内存。</p>
</li>
</ul>
<p>当然，您创建的<code>operation objects</code>的数量以及在每个对象中执行的工作量是可变的，并且完全取决于您的应用程序。 您应该经常使用<code>Instruments</code>之类的工具来帮助您在效率和速度之间找到适当的平衡。 有关可用于收集代码指标的工具和其他性能工具的概述，请参见<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" target="_blank" rel="noopener">性能概述</a>。</p>
<h2 id="执行Operations"><a href="#执行Operations" class="headerlink" title="执行Operations"></a>执行Operations</h2><h3 id="把-Operations-添加到-Operation-Queue-执行"><a href="#把-Operations-添加到-Operation-Queue-执行" class="headerlink" title="把 Operations 添加到 Operation Queue 执行"></a>把 Operations 添加到 Operation Queue 执行</h3><ul>
<li><p>执行<code>operations</code>的最简单方法是使用<code>operation queue</code>，它是<code>NSOperationQueue</code>类的实例。</p>
</li>
<li><p>应用程序负责创建和维护它打算使用的任何<code>operation queues</code>。</p>
</li>
<li><p>一个应用程序可以有任意数量的<code>queues</code>，但是在给定的时间点上执行的<code>operations</code>数量是有实际限制的。</p>
</li>
<li><p><code>operation queues</code>与系统协同工作，将 <code>concurrent operations</code> 的数量限制为适合可用内核和系统负载的值。因此，创建额外的<code>queues</code>并不意味着你可以执行额外的<code>operations</code>。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *selOper = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operationAction) object:<span class="literal">nil</span>];</span><br><span class="line">selOper.completionBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"selOper-completion--: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *blockOper = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block init--:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[blockOper addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block add--:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">blockOper.completionBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOper-completion--: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、创建 operation queue 并发执行 operation</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[queue addOperation:selOper];</span><br><span class="line">[queue addOperation:blockOper];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)operationAction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"target-selector--: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// target-selector--: &lt;NSThread: 0x6000006c0340&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// block init--:&lt;NSThread: 0x6000006e5100&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// block add--:&lt;NSThread: 0x6000006e0080&gt;&#123;number = 6, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// blockOper-completion--: &lt;NSThread: 0x6000006c0340&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// selOper-completion--: &lt;NSThread: 0x6000006e0080&gt;&#123;number = 6, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<p>2、返回与主线程相关的operation queue</p>
<ul>
<li>该 queue 在应用程序的主线程上一次执行一个operation</li>
<li>该 queue 在run loop common中执行这些操作</li>
<li>队列的underlyingQueue属性的值是主线程的调度队列，不能将此属性设置为其他值。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br><span class="line">[queue addOperation:selOper];</span><br><span class="line">[queue addOperation:blockOper];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// target-selector--: &lt;NSThread: 0x600002632940&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// selOper-completion--: &lt;NSThread: 0x60000267f980&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// block init--:&lt;NSThread: 0x600002632940&gt;&#123;number = 1, name = main&#125;</span></span><br><span class="line"><span class="comment">// block add--:&lt;NSThread: 0x600002663e00&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// blockOper-completion--: &lt;NSThread: 0x600002663e00&gt;&#123;number = 5, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>mainQueue</code> 进行线程间通讯</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *blockOper = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http:2.jpg"</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回到主线程刷新UI</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.imgView.image = image;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[queue addOperation:blockOper];</span><br></pre></td></tr></table></figure>

<p>3、返回启动当前 operation 的 operation queue</p>
<p>可以在运行的 operation object 中使用此方法来获取对启动它的 operation queue的引用。从正在运行的 operation 的上下文外部调用这个方法通常会返回 nil。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationAction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"target-selector--: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前 operation queue 添加 operation</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *oper = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(otherOperationAction) object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> currentQueue];</span><br><span class="line">    [queue addOperation:oper];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)otherOperationAction &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"other target-selector--: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[queue addOperation:selOper];</span><br><span class="line">[queue addOperation:blockOper];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="comment">// block add--:&lt;NSThread: 0x6000001f6540&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// target-selector--: &lt;NSThread: 0x6000001bb240&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// block init--:&lt;NSThread: 0x6000001bae00&gt;&#123;number = 4, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// blockOper-completion--: &lt;NSThread: 0x6000001f6540&gt;&#123;number = 5, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// selOper-completion--: &lt;NSThread: 0x6000001bb240&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// other target-selector--: &lt;NSThread: 0x6000001bae00&gt;&#123;number = 4, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Operation-添加到-Operation-Queue-的方法"><a href="#Operation-添加到-Operation-Queue-的方法" class="headerlink" title="Operation 添加到 Operation Queue 的方法"></a>Operation 添加到 Operation Queue 的方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(Operation)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOperations</span><span class="params">([Operation], waitUntilFinished: Bool)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>

<p>如上方法中的每一个都将一个<code>operation</code>（或多个<code>operation</code>）排队，并通知队列它应该开始处理它们。 在大多数情况下，<code>operations</code>在添加到<code>queue</code>后不久执行，但是<code>operation queue</code>可能会由于以下任何原因而延迟排队操作的执行。 具体来说，如果排队的操作(<code>queued operations</code>)依赖于尚未完成的其他<code>operations</code>，则执行可能会延迟。 如果<code>operation queue</code>本身已挂起或已经在执行其最大数量的并发操作，则执行也可能会延迟。</p>
<blockquote>
<p>注意：<br>在将<code>operation object</code>添加到<code>queue</code>之前，应该对<code>operation object</code>进行所有必要的配置和修改，因为一旦添加了<code>operation object</code>，该<code>operation</code>就可以在任何时间运行，对于进行更改以达到预期的效果而言可能为时已晚。</p>
<p>尽管<code>NSOperationQueue</code>类是为并发执行操作而设计的，但是可以强制单个队列一次仅运行一个<code>operation</code>。使用<code>setMaxConcurrentOperationCount：</code>方法可以配置<code>operation queue object</code>的最大并发操作数。将值1传递给此方法将导致队列一次仅执行一个<code>operation</code>。尽管一次只能执行一个<code>operation</code>，但是执行的顺序仍然基于其他因素，例如每个操作的就绪性及其分配的优先级。因此，序列化<code>operation queue</code>提供的行为与<code>Grand Central Dispatch</code>中的 串行调度队列(<code>serial dispatch queue</code>) 所提供的行为完全不同。如果<code>operation objects</code>的执行顺序对您很重要，则应在将<code>operations</code>添加到<code>queue</code>之前使用依赖关系来建立顺序。</p>
</blockquote>
<h3 id="手动执行-Operations"><a href="#手动执行-Operations" class="headerlink" title="手动执行 Operations"></a>手动执行 Operations</h3><p>尽管<code>operation queues</code>是运行<code>operation object</code>的最方便的方法，但是也可以在没有 <code>queue</code> 的情况下执行 <code>operations</code>。 但是，如果选择手动执行<code>operations</code>，则应在代码中采取一些预防措施。 特别是，<code>operation</code>必须准备就绪可以运行，并且必须始终使用其<code>start</code>方法启动它。</p>
<p>在<code>operation</code>的<code>isReady</code>方法返回<code>YES</code>之前，该<code>operation</code>被认为无法运行行。 <code>isReady</code>方法已集成到<code>NSOperation</code>类的依赖管理系统(<code>dependency management system</code>)中，以提供<code>operation</code>依赖关系的状态。 只有清除了其依赖性后，<code>operation</code>才可以自由地开始执行操作。</p>
<p>手动执行<code>operation</code>时，应始终使用<code>start</code>方法开始执行。你使用此方法，而不是<code>main</code>方法或其他方法，因为<code>start</code>方法在实际运行自定义代码之前会执行多项安全检查。 特别是，默认的<code>start</code>方法将生成<code>KVO</code>通知，<code>operations</code>需要这个通知才能正确处理它们的依赖关系。 如果该<code>operation</code>已被取消，则此方法还可以正确地避免执行该<code>operation</code>，如果你的<code>operation</code>实际上尚未准备好运行，则该方法将引发异常。</p>
<p>如果你的应用程序定义了并发操作对象(<code>concurrent operation objects</code>)，则还应该在启动它们之前考虑调用<code>isConcurrent</code>操作方法。 如果此方法返回<code>NO</code>，则您的本地代码可以决定是在当前线程中同步执行<code>operation</code>，还是首先创建单独的线程。 但是，实施这种检查完全取决于你。</p>
<p>如下手动执行 <code>Operation</code> 前需要做的检查，如果方法返回false，则可以安排Timer稍后再执行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performOperation</span><span class="params">(<span class="number">_</span> oper: Operation)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> oper.isReady &amp;&amp; oper.isCancelled == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> oper.isConcurrent == <span class="literal">false</span> &#123;</span><br><span class="line">            oper.start()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Thread</span>.detachNewThread &#123;</span><br><span class="line">                oper.start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> oper.isCancelled &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.willChangeValue(forKey: <span class="string">"isExecuting"</span>)</span><br><span class="line">        <span class="keyword">self</span>.willChangeValue(forKey: <span class="string">"isFinished"</span>)</span><br><span class="line">        executing = <span class="literal">false</span></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>.didChangeValue(forKey: <span class="string">"isExecuting"</span>)</span><br><span class="line">        <span class="keyword">self</span>.didChangeValue(forKey: <span class="string">"isFinished"</span>)</span><br><span class="line">        </span><br><span class="line">        res = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h3><p>一旦添加到<code>operation queue</code>，<code>operation object</code>实际上就归<code>queue</code>所有，并且无法删除。 让一个<code>operation</code>退出队列的唯一方法是取消它。可以通过调用单个<code>operation object</code>的<code>cancel</code>方法来取消它，也可以通过调用<code>queue object</code>的<code>cancelAllOperations</code>方法来取消队列中的所有<code>operation objects</code>。</p>
<p>只有在确定不再需要<code>operations</code>时，才应取消<code>operations</code>。发出 <code>cancel</code> 命令会将<code>operation object</code>置于<code>&quot;canceled&quot;</code>状态，这将阻止它运行。 因为取消的<code>operation</code>仍被认为是<code>“finished”</code>的，所以依赖于此<code>operations</code>的对象将收到相应的<code>KVO</code>通知以清除该依赖关系。 因此，响应于一些重要事件（如应用程序退出或用户特别请求取消）而 取消所有排队的<code>operations</code> 比 选择性地取消<code>operations</code> 更为常见。</p>
<h3 id="等待操作完成"><a href="#等待操作完成" class="headerlink" title="等待操作完成"></a>等待操作完成</h3><p>为了获得最佳性能，你应该将<code>operations</code>设计为尽可能异步，使应用程序在执行<code>operations</code>时可以自由地做其他工作。如果创建<code>operation</code>的代码也处理该<code>operation</code>的结果，则可以使用<code>NSOperation</code>的<code>waitUntilFinished</code>方法阻止该代码，直到<code>operation finishes</code>。 一般来说，如果你可以改进，最好避免调用此方法。 阻塞当前线程可能是一个方便的解决方案，但是它的确在代码中引入了更多的序列化，并限制了总体并发量。</p>
<blockquote>
<p>你永远不要等待应用程序主线程中的<code>operation</code>，你只应该从辅助线程或其他<code>operation</code>中这样做。阻塞主线程会阻止应用程序响应用户事件，并可能使应用程序看起来没有响应。</p>
</blockquote>
<p>除了等待单个<code>operation</code>完成之外，还可以通过调用<code>NSOperationQueue</code>的<code>waitUntilAllOperationsAreFinished</code>方法来等待队列中的所有操作。当等待整个队列完成时，请注意，应用程序的其他线程仍然可以向队列添加<code>operations</code>，从而延长等待时间。</p>
<h3 id="挂起和恢复队列"><a href="#挂起和恢复队列" class="headerlink" title="挂起和恢复队列"></a>挂起和恢复队列</h3><p>如果要暂时停止<code>operations</code>的执行，可以使用<code>setSuspended:</code>方法挂起相应的<code>operation queue</code>。暂停(或挂起)<code>queue</code>不会导致已经在执行的<code>operations</code>在其任务中间暂停。 它只是防止新<code>operations</code>被安排执行。你可以挂起一个<code>queue</code>以响应用户暂停任何正在进行的工作的请求，因为期望用户最终可能希望恢复该工作。</p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1" target="_blank" rel="noopener">Operation Queues</a></p>
<p><a href="https://mp.weixin.qq.com/s/_FCjo4OTd9qrrpicJRV9VA" target="_blank" rel="noopener">NSBlockOperation 面试与正确用法</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/20/Threads-%E5%9B%9B-Operation-Queues/">http://yoursite.com/2020/10/20/Threads-%E5%9B%9B-Operation-Queues/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/23/Threads-%E4%BA%94-GCD-Dispatch-Queues/"><i class="fa fa-chevron-left">  </i><span>Threads(五)GCD - Dispatch Queues</span></a></div><div class="next-post pull-right"><a href="/2020/10/18/Threads-%E4%B8%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>Threads(三)并发编程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>