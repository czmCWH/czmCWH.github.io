<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Threads(三)并发编程"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Threads(三)并发编程 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要并发编程？"><span class="toc-number">1.</span> <span class="toc-text">为什么需要并发编程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发和应用程序设计"><span class="toc-number">2.</span> <span class="toc-text">并发和应用程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远离线程"><span class="toc-number">3.</span> <span class="toc-text">远离线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Queues-调度队列"><span class="toc-number">3.1.</span> <span class="toc-text">Dispatch Queues(调度队列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Sources-调度源"><span class="toc-number">3.2.</span> <span class="toc-text">Dispatch Sources(调度源)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operation-Queues-操作队列"><span class="toc-number">3.3.</span> <span class="toc-text">Operation Queues(操作队列)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步设计技术"><span class="toc-number">4.</span> <span class="toc-text">异步设计技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义应用程序的预期行为"><span class="toc-number">4.1.</span> <span class="toc-text">定义应用程序的预期行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分解出可执行的工作单元"><span class="toc-number">4.2.</span> <span class="toc-text">分解出可执行的工作单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#确定您需要的队列"><span class="toc-number">4.3.</span> <span class="toc-text">确定您需要的队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提高效率的技巧"><span class="toc-number">4.4.</span> <span class="toc-text">提高效率的技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能影响"><span class="toc-number">5.</span> <span class="toc-text">性能影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发和其它技术"><span class="toc-number">6.</span> <span class="toc-text">并发和其它技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenCL和并发"><span class="toc-number">6.1.</span> <span class="toc-text">OpenCL和并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何时使用线程"><span class="toc-number">6.2.</span> <span class="toc-text">何时使用线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">7.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Threads(三)并发编程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="为什么需要并发编程？"><a href="#为什么需要并发编程？" class="headerlink" title="为什么需要并发编程？"></a>为什么需要并发编程？</h2><p>并发性(<code>Concurrency</code>)是指多个事情同时发生的概念。随着多核CPU的激增，以及意识到每个处理器中的核心数量只会增加，软件开发人员需要新的方法来利用它们。</p>
<a id="more"></a>

<p>虽然像<code>MacOS</code>和<code>iOS</code>这样的操作系统能够并行运行多个程序，但这些程序大多数是在后台运行，执行的任务几乎不需要连续处理器时间。当前的前台应用程序既能吸引用户的注意力，又能使计算机保持忙碌。如果应用程序有很多工作要做，但是只占用了可用内核的一小部分，那么这些额外的处理资源就会被浪费。</p>
<p>过去，将并发引入应用程序需要创建一个或多个附加线程。不幸的是，编写线程代码具有挑战性，线程是一种必须手动管理的低级工具。考虑到应用程序的最佳线程数量可以根据当前系统负载和底层硬件动态变化，实现正确的线程解决方案变得极其困难，甚至不可能实现。此外，通常与线程一起使用的同步机制会增加软件设计的复杂性和风险，而没有任何性能改进保证。</p>
<p>与传统的基于线程的系统和应用程序相比，osx和iOS都采用了更异步的方法来执行并发任务。<strong>应用程序不需要直接创建线程，只需要定义特定的任务，然后让系统执行它们。通过让系统管理线程，应用程序获得了原始线程无法实现的可伸缩性。应用程序开发人员还可以获得更简单、更高效的编程模型。</strong></p>
<h2 id="并发和应用程序设计"><a href="#并发和应用程序设计" class="headerlink" title="并发和应用程序设计"></a>并发和应用程序设计</h2><p>在早期的计算中，计算机每单位时间内所能执行的最大工作量取决于CPU的时钟速度(<code>clock speed of the CPU</code>)。但随着技术的进步和处理器设计变得更加紧凑，热量和其他物理约束开始限制处理器的最大时钟速度。因此，芯片制造商寻找其他方法来提高芯片的整体性能。他们确定的解决方案是增加每个芯片上的处理器内核数量。</p>
<p>通过增加内核数量，单个芯片每秒可以执行更多指令，而无需提高CPU速度或更改芯片大小或散热特性。<strong>唯一的问题是如何利用额外的内核</strong>。</p>
<p>为了利用多核的优势，一台计算机需要能够同时执行多项任务的软件。对于像<code>OS X</code>和<code>iOS</code>这样的现代多任务操作系统，在任何给定的时间都可能运行上百个或更多的程序，因此在不同的内核上调度每个程序应该是可能的。然而，这些程序中的大多数是系统守护进程，要么是消耗很少实时处理时间的后台应用程序。相反，<strong>真正需要的是单个应用程序能够更有效地利用额外的内核方法。</strong></p>
<p>应用程序使用多核的传统方法是创建多个线程。但是，随着内核数量的增加，线程解决方案会出现一些问题。<strong>最大的问题是线程代码无法很好地扩展到任意数量的内核。</strong>你不能创建与内核一样多的线程，并且期望程序运行良好。你需要知道的是可以有效使用的内核数量，这对于应用程序自己进行计算是一件很有挑战性的事情。即使你设法得到正确的数字，仍然有一个挑战，对于如此多的线程进行编程，使它们高效运行，并防止它们相互干扰。</p>
<p>因此，总结一下这个问题：</p>
<ul>
<li>应用程序需要有一种方法来利用数量可变的计算机内核。</li>
<li>单个应用程序执行的工作量还需要能够动态扩展，以适应不断变化的系统条件。</li>
<li>解决方案必须足够简单，以避免增加利用这些核心所需的工作量。</li>
</ul>
<p>好消息是，<code>Apple’s operating systems</code>为所有这些问题提供了解决方案，下面将介绍构成该解决方案的技术。</p>
<h2 id="远离线程"><a href="#远离线程" class="headerlink" title="远离线程"></a>远离线程</h2><p>尽管<code>threads</code>已经存在了许多年，并且还在继续使用它们，但它们并不能解决以可扩展的方式执行多个任务的普遍问题。使用<code>threads</code>，创建可扩展解决方案的负担完全由开发人员承担。你必须决定要创建多少个线程，并随着系统条件的变化动态地调整该数量。另一个问题是，您的应用程序承担了与创建和维护其使用的任何线程相关的大部分成本。</p>
<p><code>OS X</code>和<code>iOS</code>采用<strong>异步设计方法</strong>来解决并发问题，而不是依赖于<code>threads</code>。异步函数(<code>Asynchronous functions</code>)在操作系统中已经存在多年，通常用于启动可能需要很长时间的任务，比如从磁盘读取数据。调用时，异步函数会在后台执行一些工作以启动正在运行的任务，但在该任务实际完成之前返回。通常，这项工作涉及获取后台线程，在该线程上启动所需的任务，然后在任务完成时向调用者发送通知(通常通过回调函数)。在过去，如果要执行的操作不存在异步函数，则必须编写自己的异步函数并创建自己的线程。但是现在，<code>OS X</code>和<code>iOS</code>提供了允许你异步执行任何任务而无需自己管理线程的技术。</p>
<p>异步启动任务的技术之一是<code>Grand Central Dispatch (GCD)</code>。这项技术将你通常在自己的应用程序中编写的线程管理代码带入系统级别。你只需定义要执行的任务，并将它们添加到适当的调度队列中。<code>GCD</code>负责创建所需的线程，并安排任务在这些线程上运行。由于线程管理现在是系统的一部分，<code>GCD</code>为任务管理和执行提供了一种整体方法，比传统线程提供了更好的效率。</p>
<p><code>Operation queue</code>(操作队列)是<code>Objective-C</code>对象，其行为非常类似于调度队列。你定义要执行的任务，然后将它们添加到<code>Operation queue</code>中，<code>Operation queue</code>处理这些任务的调度和执行。与<code>GCD</code>类似，<code>Operation queue</code>为您处理所有线程管理，确保任务在系统上尽可能快速高效地执行。</p>
<h3 id="Dispatch-Queues-调度队列"><a href="#Dispatch-Queues-调度队列" class="headerlink" title="Dispatch Queues(调度队列)"></a>Dispatch Queues(调度队列)</h3><ul>
<li><p><code>dispatch queue</code>是一种基于c的机制，用于执行自定义任务。</p>
</li>
<li><p><code>dispatch queue</code> 可以 串行 或 并发地执行任务，但始终以先进先出的顺序执行(换句话说，<code>dispatch queue</code>总是以添加到队列的相同顺序排队和启动任务)。</p>
</li>
<li><p><code>serial dispatch queue</code>(串行调度队列)一次只运行一个任务，等待任务完成后再出列并启动新任务。</p>
</li>
<li><p><code>concurrent dispatch queue</code>(并发调度队列)可以启动尽可能多的任务，而不必等待已经启动的任务完成。</p>
</li>
</ul>
<p><code>Dispatch queues</code>的好处：<br>1、它们提供了一个简单明了的编程接口。<br>2、它们提供了自动和整体的线程池管理。<br>3、它们提供了调谐装配(<code>tuned assembly</code>)的速度。<br>4、它们具有更高的内存效率（因为线程堆栈不会在应用程序内存中停留）。<br>5、它们不会被困在负载下的内核中。<br>6、将任务异步分派到调度队列不会导致队列死锁。<br>7、他们在竞争中优雅地扩展。<br>8、串行调度队列为锁和其他同步原语(<code>synchronization primitives</code>)提供了更有效的替代方法。</p>
<p>提交给<code>dispatch queues</code>的任务必须封装在函数或<code>Block</code>对象中。<code>Block</code>对象是<code>OSXV10.6</code>和<code>iOS4.0</code>中引入的一种<code>C</code>语言特性，在概念上类似于函数指针。通常不是在自己的语法作用域中定义<code>Block</code>，而是在另一个函数或方法中定义<code>Block</code>，这样它们就可以访问该函数或方法中的其他变量。<strong><code>Block</code>也可以移出其原始作用域并复制到堆上，这是将它们提交到调度队列时发生的情况。</strong>所有这些语义 使得用相对较少的代码 实现非常动态的任务成为可能。</p>
<p><code>dispatch queues</code>是 <code>GCD</code>技术的一部分，也是<code>C runtime</code>的一部分，适用于 <code>iOS 8.0+</code>。</p>
<h3 id="Dispatch-Sources-调度源"><a href="#Dispatch-Sources-调度源" class="headerlink" title="Dispatch Sources(调度源)"></a>Dispatch Sources(调度源)</h3><ul>
<li><p><code>Dispatch Sources</code>是一种基于<code>C</code>的机制，它是<code>GCD</code>技术的一部分，用于异步处理特定类型的系统事件。</p>
</li>
<li><p><code>Dispatch Sources</code>封装了关于特定类型的系统事件的信息，并在事件发生时将特定的<code>Block</code>对象或函数提交给<code>dispatch queue</code>。</p>
</li>
</ul>
<p>可以使用<code>Dispatch Sources</code>来监视以下类型的系统事件:</p>
<ul>
<li>Timers 定时器</li>
<li>Signal handlers 信号处理程序</li>
<li>Descriptor-related events 描述符相关事件</li>
<li>Process-related events 进程相关事件</li>
<li>Mach port events</li>
<li>你触发的Custom events</li>
</ul>
<h3 id="Operation-Queues-操作队列"><a href="#Operation-Queues-操作队列" class="headerlink" title="Operation Queues(操作队列)"></a>Operation Queues(操作队列)</h3><p><code>Cocoa</code>中的<code>Operation Queues</code>等价于并发的<code>Dispatch queues</code>，它由<code>NSOperationQueue</code>类实现，适用于<code>iOS 2.0+</code>。</p>
<p><code>Dispatch queues</code>总是按照先进先出的顺序执行任务，而<code>Operation Queues</code>在确定任务的执行顺序时会考虑其他因素。在这些因素中，最主要的是一个给定的任务是否依赖于其他任务的完成。你可以在定义任务时配置依赖项，并可以使用它们来为任务创建复杂的执行顺序图。</p>
<p>提交给<code>Operation Queues</code>的任务必须是<code>NSOperation</code>类的实例。<code>operation</code>对象封装了您想要执行的工作和执行它所需的任何数据。由于<code>NSOperation</code>类本质上是一个抽象基类，因此您通常会定义自定义子类来执行任务。然而，<code>Foundation</code>框架确实包含一些具体的子类，可以创建并使用它们来执行任务。</p>
<p><code>Operation</code>对象会生成 <code>KVO通知</code>，这是监视任务进度的有用方法。尽管<code>Operation Queues</code>总是并发执行操作，但你可以使用依赖项确保在需要时串行执行这些操作。</p>
<h2 id="异步设计技术"><a href="#异步设计技术" class="headerlink" title="异步设计技术"></a>异步设计技术</h2><p>在考虑重新设计代码以支持并发之前，您应该问问自己是否有必要这样做。并发性可以确保主线程可以自由地响应用户事件，从而提高代码的响应能力。它甚至可以通过利用更多核心在相同时间内完成更多工作来提高代码的效率。但是，它也会增加开销，并增加代码的总体复杂性，使编写和调试代码变得更加困难。</p>
<p>因为并发性增加了复杂性，所以您不能在产品周期结束时将并发性移植到应用程序上。正确地执行它需要仔细考虑 应用程序执行的任务 以及 用于执行这些任务的数据结构。如果操作不当，您可能会发现代码比以前运行得更慢，对用户的响应也较慢。因此，在设计周期的开始阶段花一些时间来设置一些目标并考虑需要采取的方法是值得的。</p>
<p>每个应用程序都有不同的需求和它执行的不同任务集。文档不可能确切地告诉您如何设计应用程序及其相关任务。但是，下面的部分试图提供一些指导，以帮助您在设计过程中做出正确的选择。</p>
<h3 id="定义应用程序的预期行为"><a href="#定义应用程序的预期行为" class="headerlink" title="定义应用程序的预期行为"></a>定义应用程序的预期行为</h3><p>在考虑向应用程序添加并发性之前，您应该始终从定义应用程序的正确行为开始。了解应用程序的预期行为，可以为你以后验证设计提供一种方法。它还应该让您了解通过引入并发性可能获得的预期性能好处。</p>
<p>您应该做的第一件事是枚举应用程序执行的任务以及与每个任务关联的对象或数据结构。最初，您可能希望从用户选择菜单项或单击按钮时执行的任务开始。这些任务提供离散的行为，并有一个明确的起点和终点。您还应该列举应用程序在没有用户交互的情况下可能执行的其他类型的任务，例如基于计时器的任务。</p>
<p>在您获得高级任务列表后，开始将每个任务进一步分解为成功完成任务必须采取的一系列步骤。在这个级别上，您应该主要关注需要对任何数据结构和对象进行的修改，以及这些修改如何影响应用程序的整体状态。还应该注意对象和数据结构之间的依赖关系。例如，如果一项任务涉及对对象数组进行相同的更改，那么对一个对象的更改是否会影响其他对象就值得注意了。如果对象可以相互独立地修改，那么可以在这里同时进行修改。</p>
<h3 id="分解出可执行的工作单元"><a href="#分解出可执行的工作单元" class="headerlink" title="分解出可执行的工作单元"></a>分解出可执行的工作单元</h3><p>根据对应用程序任务的理解，您应该已经能够确定代码可以从并发中受益的地方。如果更改任务中一个或多个步骤的顺序会改变结果，则可能需要继续串行地执行这些步骤。但是，如果更改顺序对输出没有影响，则应考虑同时执行这些步骤。在这两种情况下，您都定义了表示要执行的一个或多个步骤的可执行工作单元。然后，这个工作单元将成为您使用<code>block</code>或<code>operation object</code>封装的内容，并分派到适当队列中。</p>
<p>对于您确定的每个可执行工作单元，不要过于担心被执行的工作量，至少在最初是这样。尽管启动线程(<code>spinning up a thread</code>)总是有成本，但<code>dispatch queues</code>和<code>operation queues</code>的优势之一是，在许多情况下，这些成本比传统线程要小得多。因此，与使用线程相比，使用队列可以更有效地执行较小的工作单元。当然，您应该始终度量您的实际性能，并根据需要调整任务的大小，但在最初，任何任务都不应该被认为太小。</p>
<h3 id="确定您需要的队列"><a href="#确定您需要的队列" class="headerlink" title="确定您需要的队列"></a>确定您需要的队列</h3><p>现在，您的任务已经被分解为不同的工作单元，并使用<code>block</code>对象或<code>operation object</code>进行封装，现在您需要定义将用于执行该代码的队列。对于给定的任务，检查您创建的<code>block</code>或<code>operation object</code>以及正确执行任务必须执行它们的顺序。</p>
<p>如果使用<code>block</code>实现任务，则可以将<code>block</code>添加到串行或并发<code>dispatch queues</code>中。如果需要特定的顺序，则始终将<code>block</code>添加到串行<code>dispatch queues</code>中。如果不需要特定的顺序，则可以将这些<code>block</code>添加到一个并发<code>dispatch queues</code>中，或者将它们添加到几个不同的<code>dispatch queues</code>中，具体取决于您的需要。</p>
<p>如果使用<code>operation object</code>实现任务，则选择队列通常比配置对象有趣。要串行地执行操作对象，必须配置相关对象之间的依赖关系。依赖关系阻止一个操作在其所依赖的对象完成其工作之前执行。</p>
<h3 id="提高效率的技巧"><a href="#提高效率的技巧" class="headerlink" title="提高效率的技巧"></a>提高效率的技巧</h3><p>除了简单地将代码分解成更小的任务并将它们添加到队列中，还有其他方法可以使用队列提高代码的总体效率：</p>
<ul>
<li><p>如果内存使用是一个因素，请考虑直接在任务中计算值。<br>如果您的应用程序已经受到内存限制，那么现在直接计算值可能比从主内存加载缓存值快。计算值直接使用给定处理器内核的寄存器和缓存，这比主内存快得多。当然，只有在测试表明这是性能上的胜利时，才应该这样做。</p>
</li>
<li><p>尽早确定串行任务，尽可能让它们更加并行。<br>如果由于任务依赖某个共享资源而必须串行执行，请考虑更改体系结构以删除该共享资源。您可以考虑为每个需要一个资源的客户端制作资源副本，或者完全消除该资源。</p>
</li>
<li><p>避免使用锁<br><code>dispatch queues</code> 和 <code>operation queues</code>提供的支持使得在大多数情况下不需要锁。与其使用锁来保护某些共享资源，不如指定一个串行队列(或使用操作对象依赖关系)以正确的顺序执行任务。</p>
</li>
<li><p>尽可能依靠系统框架<br>实现并发的最佳方法是<strong>利用系统框架提供的内置并发</strong>。许多框架在内部使用线程和其他技术来实现并发行为。在定义任务时，请查看现有框架是否定义了一个函数或方法，该函数或方法完全按照您的期望并发完成。使用该API可以节省您的工作，并且更有可能为您提供尽可能高的并发性。</p>
</li>
</ul>
<h2 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h2><p><code>Operation queues</code>, <code>dispatch queues</code>, 和 <code>dispatch sources</code>使您可以更轻松地同时执行更多代码。但是，这些技术并不能保证提高应用程序的效率或响应能力。您仍然有责任以既有效满足您的需求，又不会给应用程序的其他资源带来不当负担的方式使用队列。例如，虽然您可以创建10000个<code>operation objects</code>并将它们提交到<code>operation queue</code>，但这样做会导致应用程序分配潜在的大量内存，这可能会导致分页并降低性能。</p>
<p>在为代码引入任何数量的并发之前，无论是使用<code>queues</code>还是<code>threads</code>，您都应该收集一组反映应用程序当前性能的基线指标(<code>baseline metrics</code>)。在引入更改之后，，您应该收集更多的指标，并将它们与基线指标进行比较，以查看应用程序的整体效率是否有所提高。如果并发性的引入降低了应用程序的效率或响应能力，则应该使用可用的性能工具来检查潜在的原因。</p>
<p>有关性能和可用性能工具的介绍，以及指向更高级性能相关主题的链接，请参考<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" target="_blank" rel="noopener">Performance Overview 性能概述</a></p>
<h2 id="并发和其它技术"><a href="#并发和其它技术" class="headerlink" title="并发和其它技术"></a>并发和其它技术</h2><p>将代码分解为模块化任务(<code>modular tasks</code>)是尝试和提高应用程序并发性最佳方法。然而，这种设计方法可能无法满足每个应用程序在每种情况下的需要。根据您的任务，可能还有其他选项可以为应用程序的整体并发性提供额外的改进。本节概述了在设计中要考虑使用的其他一些技术。</p>
<h3 id="OpenCL和并发"><a href="#OpenCL和并发" class="headerlink" title="OpenCL和并发"></a>OpenCL和并发</h3><p>在<code>OSX</code>中，开放计算语言（<code>OpenCL</code>）是一种基于标准的技术，用于在计算机的图形处理器上执行通用计算。如果您有一组定义良好、希望应用于大型数据集的计算，那么<code>OpenCL</code>是一种很好的技术。例如，可以使用<code>OpenCL</code>对图像的像素执行过滤计算，或者使用<code>OpenCL</code>同时对多个值执行复杂的数学计算。换言之，<code>OpenCL</code>更多地针对可以并行操作数据的问题集。</p>
<p>尽管<code>OpenCL</code>很适合执行大规模数据并行操作，但它不适合更通用的计算。准备数据和所需的工作内核并将其传输到图形卡需要大量的精力，以便可以通过<code>GPU</code>对其进行操作。同样，检索<code>OpenCL</code>生成的任何结果都需要大量的工作。因此，任何与系统交互的任务通常不建议与<code>OpenCL</code>一起使用。例如，您不会使用<code>OpenCL</code>来处理来自文件或网络流的数据。相反，使用<code>OpenCL</code>执行的工作必须更加自成一体，这样才能将其传输到图形处理器并独立计算。</p>
<p>有关<code>OpenCL</code>以及如何使用它的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/OpenCL_MacProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008312" target="_blank" rel="noopener">OpenCL Programming Guide for Mac</a>。</p>
<h3 id="何时使用线程"><a href="#何时使用线程" class="headerlink" title="何时使用线程"></a>何时使用线程</h3><p>虽然<code>operation queues</code>和<code>dispatch queues</code>是并发执行任务的首选方式，但它们不是万能的。根据应用程序的不同，有时可能仍需要创建自定义线程。如果您确实创建了自定义线程，那么您应该努力自己创建尽可能少的线程，并且您应该仅将这些线程用于无法以其他方式实现的特定任务。</p>
<p>线程仍然是实现必须实时运行的代码的好方法。<code>Dispatch queues</code>会尽可能快地运行它们的任务，但不能解决实时约束问题。如果您需要从后台运行的代码中获得更可预测的行为，线程仍然可以提供更好的选择。</p>
<p>与任何线程编程一样，您应该始终明智地使用线程，并且只在绝对必要时使用线程。有关线程包以及如何使用它们的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW20" target="_blank" rel="noopener">Threading Programming Guide</a>。</p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="noopener">Concurrency Programming Guide</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">Blocks Programming Topics</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/InputControl/InputControl.html#//apple_ref/doc/uid/10000062i" target="_blank" rel="noopener">Introduction to Run Loops</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW20" target="_blank" rel="noopener">Threading Programming Guide</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/18/Threads-%E4%B8%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">http://yoursite.com/2020/10/18/Threads-%E4%B8%89-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/20/Threads-%E5%9B%9B-Operation-Queues/"><i class="fa fa-chevron-left">  </i><span>Threads(四)Operation Queues</span></a></div><div class="next-post pull-right"><a href="/2020/10/15/Threads-%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/"><span>Threads(二)线程技术</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>