<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Runloop(二)Runloop 的使用"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Runloop(二)Runloop 的使用 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-对象"><span class="toc-number">1.</span> <span class="toc-text">RunLoop 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-runloop"><span class="toc-number">1.1.</span> <span class="toc-text">获取 runloop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-Run-Loop"><span class="toc-number">1.2.</span> <span class="toc-text">配置 Run Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动-Run-Loop"><span class="toc-number">1.3.</span> <span class="toc-text">启动 Run Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#退出-Run-Loop"><span class="toc-number">1.4.</span> <span class="toc-text">退出 Run Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全和运行循环对象"><span class="toc-number">1.5.</span> <span class="toc-text">线程安全和运行循环对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置-Run-Loop-Sources"><span class="toc-number">2.</span> <span class="toc-text">配置 Run Loop Sources</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义-Custom-Input-Source"><span class="toc-number">2.1.</span> <span class="toc-text">定义 Custom Input Source</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-Timer-Sources"><span class="toc-number">2.2.</span> <span class="toc-text">配置 Timer Sources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-Port-Based-Input-Source"><span class="toc-number">2.3.</span> <span class="toc-text">配置 Port-Based Input Source</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-NSMachPort"><span class="toc-number">2.3.1.</span> <span class="toc-text">配置 NSMachPort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-NSMessagePort"><span class="toc-number">2.3.2.</span> <span class="toc-text">配置 NSMessagePort</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">3.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Runloop(二)Runloop 的使用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Thread-runloop/">Thread &amp; runloop</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><code>run loop object</code>提供了用于将<code>input sources</code>、<code>timers</code> 和 <code>run-loop observers</code>添加到你的<code>run loop</code>然后运行它的主接口。每个线程都有一个与之关联的<code>run loop object</code>。在<code>Cocoa</code>中，这个对象是<code>NSRunLoop</code>类的一个实例。在低级应用程序(<code>low-level application</code>)中，它是一个指向<code>CFRunLoopRef</code>不透明类型的指针。</p>
<h2 id="RunLoop-对象"><a href="#RunLoop-对象" class="headerlink" title="RunLoop 对象"></a>RunLoop 对象</h2><h3 id="获取-runloop"><a href="#获取-runloop" class="headerlink" title="获取 runloop"></a>获取 runloop</h3><p>要获得当前线程的运行循环，可以使用以下方法之一:</p>
<ol>
<li>在<code>Cocoa</code>应用程序中，使用<code>NSRunLoop</code>的<code>currentRunLoop</code>类方法来检索<code>NSRunLoop</code>对象。</li>
<li>使用<code>CFRunLoopGetCurrent</code>函数。</li>
</ol>
<a id="more"></a>

<p><code>NSRunLoop</code> 类定义了一个 <code>getCFRunLoop</code> 方法，它返回一个可以传递给<code>Core Foundation</code> 例程的 <code>CFRunLoopRef</code> 类型。可以根据需要混合调用<code>NSRunLoop</code> 对象和 <code>CFRunLoopRef</code> 不透明类型。</p>
<h3 id="配置-Run-Loop"><a href="#配置-Run-Loop" class="headerlink" title="配置 Run Loop"></a>配置 Run Loop</h3><p>在辅助线程上运行 <code>run loop</code> 之前，必须向其添加至少一个 <code>input source</code> 或 <code>timer</code>。如果 <code>run loop</code> 没有任何要监视的源，那么在尝试运行它时，它会立即退出。</p>
<p>除了安装<code>sources</code>之外，还可以设置<code>run loop observers</code>，并使用它们来检测 <code>run loop</code> 的不同执行阶段。要安装<code>run loop observers</code>，请创建<code>CFRunLoopObserverRef</code>不透明类型，然后使用<code>CFRunLoopAddObserver</code>函数将其添加到<code>run loop</code>中。<code>run loop observers</code> 必须使用 <code>Core Foundation</code> 创建，即使对于 <code>Cocoa</code> 应用程序也是如此。</p>
<p>如下是创建一个 <code>run loop observer</code> 并添加到 <code>run loop</code>的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span><br><span class="line">    [<span class="keyword">self</span> threadMain];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 由于应用使用 garbage collection，所以不需要 autorelease pool</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建一个 run loop observer 并添加到 run loop</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span>  context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span>    observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">            kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;myObserverCallBack, &amp;context);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (observer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span>    cfLoop = [myRunLoop getCFRunLoop];</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建并安排 timer.</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span></span><br><span class="line">                selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSInteger</span>    loopCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 运行 runloop 10次，让计时器触发</span></span><br><span class="line">        [myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在为<code>long-lived thread</code>(长生命周期线程)配置 <code>run loop</code> 时，最好至少添加一个<code>input source</code> 来接收消息。尽管你可以在只附加一个 <code>timer</code> 的情况下启动<code>run loop</code>，但一旦<code>timer</code>触发，它通常会失效，然后会导致<code>run loop</code>退出。附加一个重复<code>timer</code>可以使<code>run loop</code>保持较长时间运行，但需要定期触发<code>timer</code>来唤醒线程，这实际上是轮询的另一种形式。相比之下，<code>input source</code>会等待事件发生，使线程保持睡眠状态直到事件发生。</p>
<h3 id="启动-Run-Loop"><a href="#启动-Run-Loop" class="headerlink" title="启动 Run Loop"></a>启动 Run Loop</h3><p>只有应用程序中的子线程才需要启动<code>run loop</code>。<code>run loop</code>必须至少有一个要监视的<code>input source</code> 或 <code>timer</code>。如果没有附加，则<code>run loop</code>将立即退出。</p>
<p>有以下几种方式来启动<code>run loop</code>：</p>
<ul>
<li>无条件地，(<code>run</code> 函数）</li>
<li>设置时间限制，(<code>runUntilDate:</code> 函数)</li>
<li>以特定的模式，(<code>runMode:beforeDate:</code> 函数)</li>
</ul>
<p>无条件地启动<code>run loop</code>是最简单的选择，但也是最不可取的。无条件地运行<code>run loop</code>会将线程放入一个永久循环中，这使你几乎无法控制<code>run loop</code>本身。你可以添加和删除<code>input source</code> 或 <code>timer</code>，但是停止运行循环的唯一方法是终止它。也无法在自定义模式下运行<code>run loop</code>。</p>
<p>与其无条件地运行<code>run loop</code>，不如使用<code>timeout value</code>(超时值)运行<code>run loop</code>。使用<code>timeout value</code>时，<code>run loop</code>将运行直到事件到达或分配的时间过期为止。如果事件到达，则将该事件分派到处理程序进行处理，然后退出<code>run loop</code>。然后，你的代码可以重新启动<code>run loop</code>以处理下一个事件。如果分配的时间到期了，可以简单地重新启动<code>run loop</code>或使用该时间进行任何必要的内务处理。</p>
<p>除了<code>timeout value</code>外，还可以使用特定<code>mode</code>运行<code>run loop</code>。模式和超时值不是互斥的，可以在启动<code>run loop</code>时同时使用。模式限制向<code>run loop</code>传递事件的源(<code>sources</code>)的类型。</p>
<p>如下例子运行 runloop：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不使用 garbage collection，请在此处设置 autorelease pool </span></span><br><span class="line">    <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加 sources、timers 到 run loop 中，并进行任何其他设置</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动 run loop，但在处理完每个 source 后返回.</span></span><br><span class="line">        SInt32    result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果 source 显式停止了 run loop，或者没有 sources 或 timers，则继续并exit</span></span><br><span class="line">        <span class="keyword">if</span> ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</span><br><span class="line">            done = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 检查此处是否存在任何其他退出条件，并根据需要设置done变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!done);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在这里清理代码。请务必释放任何分配的 autorelease pools</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以递归运行<code>run loop</code>。换句话说，可以从<code>input source</code>或<code>timer</code>的处理程序例程中调用<code>CFRunLoopRun</code>，<code>CFRunLoopRunInMode</code>或任何<code>NSRunLoop</code>方法来启动<code>run loop</code>。这样做时，可以使用任何要运行嵌套<code>run loop</code>的模式，包括外部<code>run loop</code>使用的模式。</p>
<h3 id="退出-Run-Loop"><a href="#退出-Run-Loop" class="headerlink" title="退出 Run Loop"></a>退出 Run Loop</h3><p>在处理事件之前，有两种方法可以使<code>run loop</code>退出：</p>
<ul>
<li>配置<code>run loop</code>以使用<code>timeout value</code>运行。</li>
<li>告诉<code>run loop</code>停止。</li>
</ul>
<p>如果你可以管理<code>timeout value</code>的话，使用<code>timeout value</code>当然是首选的。指定<code>timeout value</code>可以让<code>run loop</code>在退出之前完成其所有正常处理，包括向<code>run loop observers</code>发送通知。</p>
<p>使用 <code>CFRunLoopStop</code> 函数显式地停止<code>run loop</code>会产生类似于超时的结果。<code>run loop</code>发送所有剩余的运行循环通知，然后退出。区别在于，可以在无条件启动的<code>run loop</code>上使用此技术。</p>
<p>虽然删除<code>run loop</code>的 <code>input sources</code> 和 <code>timers</code> 也可能导致 <code>run loop</code> 退出，但这不是停止 <code>run loop</code> 的可靠方法。一些系统例程将 <code>input sources</code> 添加到 <code>run loop</code> 以处理所需的事件。因为你的代码可能不知道这些<code>input sources</code>，所以它将无法删除它们，这将无法使 <code>run loop</code> 退出。</p>
<h3 id="线程安全和运行循环对象"><a href="#线程安全和运行循环对象" class="headerlink" title="线程安全和运行循环对象"></a>线程安全和运行循环对象</h3><p>线程安全性取决于你用于操作<code>run loop</code>的 API。<code>Core Foundation</code>中的函数通常是线程安全的，可以从任何线程调用。但是，如果执行的操作更改了 <code>run loop</code> 的配置，则仍然最好从拥有 <code>run loop</code> 的线程进行更改。</p>
<p><code>Cocoa</code>的<code>NSRunLoop</code>类并不像它的<code>Core Foundation</code>对应的类那样本质上是线程安全的。如果你使用<code>NSRunLoop</code>类来修改你的<code>run loop</code>，则只能从拥有那个<code>run loop</code>的同一个线程中进行修改。将 <code>input sources</code> 或 <code>timers</code> 添加到属于不同线程的<code>run loop</code>中可能会导致代码崩溃或异常行为。</p>
<h2 id="配置-Run-Loop-Sources"><a href="#配置-Run-Loop-Sources" class="headerlink" title="配置 Run Loop Sources"></a>配置 Run Loop Sources</h2><p>以下各节展示了如何在 <code>Cocoa</code> 和 <code>Core Foundation</code> 中设置不同类型的 <code>input sources</code> 的示例。</p>
<h3 id="定义-Custom-Input-Source"><a href="#定义-Custom-Input-Source" class="headerlink" title="定义 Custom Input Source"></a>定义 Custom Input Source</h3><p>创建<code>Custom Input Source</code>(自定义输入源)需要定义以下内容:</p>
<ul>
<li>希望 <code>input source</code> 处理的信息。</li>
<li>一个调度程序例程(<code>scheduler routine</code>)，让感兴趣的 <code>clients</code> 知道如何联系你的 <code>input source</code>。</li>
<li>用于执行任何 <code>clients</code> 发送的请求的<code>handler routine</code>(处理程序例程)。</li>
<li>取消例程(<code>cancellation routine</code>)使<code>input source</code>无效。</li>
</ul>
<p>因为你创建了一个 <code>Custom Input Source</code> 来处理自定义信息，所以实际的配置设计得很灵活。调度程序(<code>scheduler</code>)、处理程序(<code>handler</code>)和取消例程(<code>cancellation routines</code>)是 <code>custom input source</code> 几乎总是需要的<code>key routines</code>(关键例程)。但是，<code>input source</code>的其余大部分行为发生在这些处理程序例程之外。例如，由你定义将数据传递到<code>input source</code>和将<code>input source</code>的存在与其他线程通信的机制。</p>
<p>如下图显示了 <code>Custom Input Source</code> 的配置示例。在此示例中，应用程序的主线程维护对<code>input source</code>、该<code>input source</code>的自定义命令缓冲区以及安装该<code>input source</code>的<code>run loop</code>的引用。</p>
<p>当主线程有需要要移交给<code>worker thread</code>的任务时，它会向<code>command buffer</code>(命令缓冲区)发布命令，以及<code>worker thread</code>启动任务所需的任何信息。(由于主线程和<code>worker thread</code>的<code>input source</code>都可以访问<code>command buffer</code>，因此必须同步访问。)发布命令后，主线程会向<code>input source</code>发出信号，并唤醒<code>worker thread</code>的<code>run loop</code>。收到唤醒命令后，<code>run loop</code>将调用<code>input source</code>的<code>handler</code>，该<code>handler</code>将处理在<code>command buffer</code>中找到的命令。</p>
<img src="/2020/10/27/Runloop-%E4%BA%8C-Runloop-%E7%9A%84%E4%BD%BF%E7%94%A8/16043727762991.jpg" class="" title="This is an example image">

<p>可以从官方文档上找到上图中解释的<code>custom input source</code>的实现，以及你需要实现的关键代码。</p>
<h3 id="配置-Timer-Sources"><a href="#配置-Timer-Sources" class="headerlink" title="配置 Timer Sources"></a>配置 Timer Sources</h3><p>要创建<code>timer source</code>，你要做的就是创建一个<code>timer object</code>并将其安排在<code>run loop</code>上。在<code>Cocoa</code>中，使用<code>NSTimer</code>类创建新的<code>timer objects</code>，在<code>Core Foundation</code>中，使用<code>CFRunLoopTimerRef</code>不透明类型。在内部，<code>NSTimer</code>类只是<code>Core Foundation</code>的扩展，它提供了一些便利功能，例如使用同一方法创建和安排计时器的功能。</p>
<p>在<code>Cocoa</code>中，可以使用以下两种方法之一同时创建和安排计时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br><span class="line">scheduledTimerWithTimeInterval:invocation:repeats:</span><br></pre></td></tr></table></figure>

<p>上面方法创建<code>timer</code>，并以默认模式（<code>NSDefaultRunLoopMode</code>）将其添加到当前线程的<code>run loop</code>中。如果需要，可以手动安排<code>timer</code>，方法是创建<code>NSTimer</code>对象，然后使用<code>NSRunLoop</code>的<code>addTimer:forMode:</code>方法将其添加到<code>run loop</code>中。这两种技术都做着基本相同的事情，但是可以为你提供对<code>timer</code>配置的不同级别的控制。例如，如果你创建<code>timer</code>并将其手动添加到<code>run loop</code>中，则可以使用默认模式以外的其他模式来执行此操作。</p>
<p>如下使用 NSTimer 创建和调度计时器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始延迟为1秒，但此后每0.1秒定期触发一次</span></span><br><span class="line"><span class="built_in">NSDate</span>* futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSTimer</span>* myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:<span class="number">0.1</span></span><br><span class="line">                        target:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer1:)</span><br><span class="line">                        userInfo:<span class="literal">nil</span></span><br><span class="line">                        repeats:<span class="literal">YES</span>];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始0.2秒延迟后开始触发一次，然后每隔0.2秒触发一次</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span></span><br><span class="line">                        target:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer2:)</span><br><span class="line">                        userInfo:<span class="literal">nil</span></span><br><span class="line">                        repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<h3 id="配置-Port-Based-Input-Source"><a href="#配置-Port-Based-Input-Source" class="headerlink" title="配置 Port-Based Input Source"></a>配置 Port-Based Input Source</h3><p><code>Cocoa</code> 和 <code>Core Foundation</code> 都提供了<code>port-based objects</code>，用于在线程之间或进程之间进行通信。以下各节说明如何使用几种不同类型的<code>port</code>来设置<code>port</code>通信。</p>
<h4 id="配置-NSMachPort"><a href="#配置-NSMachPort" class="headerlink" title="配置 NSMachPort"></a>配置 NSMachPort</h4><p>要与 <code>NSMachPort</code> 对象建立本地连接，请创建<code>port object</code>并将其添加到主线程的<code>run loop</code>中。启动辅助线程时，将同一对象传递给线程的<code>entry-point function</code>(入口点函数)。辅助线程可以使用相同的对象将消息发送回主线程。</p>
<h4 id="配置-NSMessagePort"><a href="#配置-NSMessagePort" class="headerlink" title="配置 NSMessagePort"></a>配置 NSMessagePort</h4><p>要与 <code>NSMessagePort</code> 对象建立本地连接，不能简单地在线程之间传递端口对象。远程消息端口必须按名称获取。要在 <code>Cocoa</code> 中实现此功能，需要使用特定名称注册你的本地端口，然后将该名称传递给远程线程，以便它可以获取适当的端口对象以进行通信。</p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Threading Programming Guide * Run Loops</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSRunLoop/Description.html#//apple_ref/occ/instm/NSRunLoop/runUntilDate:" target="_blank" rel="noopener">NSRunLoop</a></p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">YYKit大佬 深入理解RunLoop</a></p>
<p><a href="https://www.cnblogs.com/kenshincui/p/6823841.html" target="_blank" rel="noopener">iOS刨根问底-深入理解RunLoop</a></p>
<p><a href="https://xiaozhuanlan.com/topic/3748612095" target="_blank" rel="noopener">iOS 各个线程 Autorelease 对象的内存管理</a></p>
<p><a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">runloop 孙源优酷视频</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/27/Runloop-%E4%BA%8C-Runloop-%E7%9A%84%E4%BD%BF%E7%94%A8/">http://yoursite.com/2020/10/27/Runloop-%E4%BA%8C-Runloop-%E7%9A%84%E4%BD%BF%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/10/24/Threads-%E4%B8%83-%E8%BF%9C%E7%A6%BB%E7%BA%BF%E7%A8%8B/"><span>Threads(七)远离线程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>