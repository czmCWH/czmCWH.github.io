<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Core Graphics绘图(二)"><meta name="keywords" content="iOS,Core Graphics"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Core Graphics绘图(二) | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#颜色空间-Color-Spaces"><span class="toc-number">1.</span> <span class="toc-text">颜色空间(Color Spaces)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相关概念"><span class="toc-number">1.1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#颜色管理"><span class="toc-number">1.1.1.</span> <span class="toc-text">颜色管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#颜色"><span class="toc-number">1.1.2.</span> <span class="toc-text">颜色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#色调，饱和度和值（或亮度）"><span class="toc-number">1.1.3.</span> <span class="toc-text">色调，饱和度和值（或亮度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加色法和减色法"><span class="toc-number">1.1.4.</span> <span class="toc-text">加色法和减色法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Color-Spaces-颜色空间"><span class="toc-number">1.1.5.</span> <span class="toc-text">Color Spaces(颜色空间)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#颜色空间"><span class="toc-number">1.2.</span> <span class="toc-text">颜色空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#device-color-spaces"><span class="toc-number">1.2.1.</span> <span class="toc-text">device color spaces</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#渲染意图-Rending-Intent"><span class="toc-number">1.3.</span> <span class="toc-text">渲染意图(Rending Intent)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变换-Transforms"><span class="toc-number">2.</span> <span class="toc-text">变换(Transforms)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Patterns-模式、样式"><span class="toc-number">3.</span> <span class="toc-text">Patterns(模式、样式)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#colored-Patterns-着色模式-和-Stencil-Uncolored-Patterns-未着色模式"><span class="toc-number">3.1.</span> <span class="toc-text">colored Patterns(着色模式) 和 Stencil (Uncolored) Patterns(未着色模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tiling-平铺"><span class="toc-number">3.2.</span> <span class="toc-text">Tiling(平铺)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Patterns如何工作"><span class="toc-number">3.3.</span> <span class="toc-text">Patterns如何工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Patterns-进行绘制"><span class="toc-number">3.4.</span> <span class="toc-text">使用 Patterns 进行绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阴影-Shadows"><span class="toc-number">4.</span> <span class="toc-text">阴影(Shadows)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渐变色-Gradients"><span class="toc-number">5.</span> <span class="toc-text">渐变色(Gradients)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CGShading-和-CGGradient"><span class="toc-number">5.1.</span> <span class="toc-text">CGShading 和 CGGradient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGGradient的使用"><span class="toc-number">5.2.</span> <span class="toc-text">CGGradient的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGShading的使用"><span class="toc-number">5.3.</span> <span class="toc-text">CGShading的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#透明层-Transparency-Layers"><span class="toc-number">6.</span> <span class="toc-text">透明层(Transparency Layers)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">7.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">16</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Core Graphics绘图(二)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Graphics-Animation/">Graphics &amp; Animation</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="颜色空间-Color-Spaces"><a href="#颜色空间-Color-Spaces" class="headerlink" title="颜色空间(Color Spaces)"></a>颜色空间(Color Spaces)</h2><p>设备(显示器、打印机、扫描仪、照相机)对待颜色的方式不同。每个设备都有自己的颜色范围，设备可以准确的生成这些颜色。在一台设备上产生的颜色可能无法在另一台设备上产生。</p>
<p>Quartz中的颜色由相应颜色空间的一组值表示。Alpha是Graphics States(图形状态)的参数，Quartz使用它来确定如何将新绘制的对象组合到现有页面。</p>
<a id="more"></a>

<p>Quartz的Graphics States(图形状态)使用默认混合模式(blend mode)，使用公式将源色和目标色的成分结合起来，进行alpha混合:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context?.setBlendMode(.normal)</span><br></pre></td></tr></table></figure>

<p><code>destination = (alpha * source) + (1 - alpha) * destination</code></p>
<p>source是新绘制组件的颜色；destination是背景颜色的一个组成部分。每个新绘制的形状或图像都执行此公式。</p>
<p>我们可以为接受颜色的地方提供一个alpha值作为最终颜色的组成部分；也可以使用 <code>context?.setAlpha(0.5)</code> 函数设置全局alpha值；如果同时设置两者，则Quartz会将alpha颜色分量乘以全局alpha值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="comment">// 设置全局alpha值。使得页面上的对象和其本身都透明</span></span><br><span class="line"><span class="comment">//   context?.setAlpha(0.5)</span></span><br><span class="line"></span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">    context?.setFillColor(<span class="type">UIColor</span>.green.cgColor)</span><br><span class="line">    <span class="comment">// 为路径的单独颜色设置alpha，只会作用于当前路径</span></span><br><span class="line"><span class="comment">//        context?.setFillColor(UIColor.green.withAlphaComponent(0.5).cgColor)</span></span><br><span class="line">    context?.fillPath()</span><br><span class="line">        </span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">75</span>, y: <span class="number">75</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    context?.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line"><span class="comment">//        context?.setFillColor(UIColor.red.withAlphaComponent(0.5).cgColor)</span></span><br><span class="line">    context?.fillPath()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 绘制透明矩形，该方法以显式清除图形上下文的alpha通道。例如，在为图标创建透明蒙版或使窗口背景透明时，可能要执行此操作。</span></span><br><span class="line">    <span class="comment">// 如果提供的上下文是window 或者 bitmap contexts，则 Core Graphics 会清楚rect所表示的矩形</span></span><br><span class="line">    <span class="comment">// 如果是其它类型，Core Graphics以依赖于设备的方式填充矩形。</span></span><br><span class="line">    <span class="comment">// 注意，不应该在 window 或者 bitmap contex ts 以外的上下文中使用此函数。</span></span><br><span class="line">    <span class="comment">// context?.clear(CGRect(x: 75, y: 75, width: 50, height: 50))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="颜色管理"><a href="#颜色管理" class="headerlink" title="颜色管理"></a>颜色管理</h4><p>颜色管理：是在设备之间保持颜色一致的过程。不同的成像设备（如扫描仪、显示器和打印机）在不同的颜色空间中工作，并且每个设备都有不同的色域（设备可以显示的颜色范围）。</p>
<p>由于种种因素(设备类型、使用年限、不同的打印技术、墨水纸张等等)，从单个显示器上的RGB颜色转换为使用特定墨水和纸张类型的单个打印机上的CMYK颜色可能会导致不可预测的结果。</p>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>颜色：是一种感觉，因此也是一种主观体验。颜色的感觉是视觉的一个组成部分，是由人眼对光线的敏感性引起的。颜色感觉也受到大脑处理信息的方式的影响，而且是因人而异的。因此，颜色感知是一种非常复杂的现象。</p>
<p>计算机使您能够数字化地控制颜色，并且已经开发了许多外设来获取、显示和再现颜色。因此，需要一种机制来维持环境中的颜色控制，这种环境可以包括不同的计算机操作系统和硬件，以及连接到计算机的各种设备和媒体。</p>
<h4 id="色调，饱和度和值（或亮度）"><a href="#色调，饱和度和值（或亮度）" class="headerlink" title="色调，饱和度和值（或亮度）"></a>色调，饱和度和值（或亮度）</h4><p>颜色被描述为具有三个维度。这些维度是色调、饱和度和值。</p>
<ul>
<li>色调：是颜色的名称，它使颜色在光谱中处于正确的位置。</li>
<li>饱和度：是指颜色的强度程度，或颜色的强度。例如：粉色是不饱和红色的一个例子。</li>
<li>值（或亮度）：描述从彩色图像反射或透射的光的强度的差异。</li>
</ul>
<h4 id="加色法和减色法"><a href="#加色法和减色法" class="headerlink" title="加色法和减色法"></a>加色法和减色法</h4><p>加色法，是指红、绿、蓝(RGB三原色)三种光它们按不同比例相加而混合出其他色彩的一种方法。</p>
<p>减色法，是指着色剂如油墨或染料组合的过程。各种含量着色剂会吸收或“减去”照明对象的白光光谱的一部分，物体的颜色是不被物体吸收的颜色的光。</p>
<p>显示器使用加色法，输出打印设备使用减色法。</p>
<h4 id="Color-Spaces-颜色空间"><a href="#Color-Spaces-颜色空间" class="headerlink" title="Color Spaces(颜色空间)"></a>Color Spaces(颜色空间)</h4><p>颜色空间描述不同的外围设备如何表示颜色以及用于表示颜色的值。它述了一种环境，在这种环境中，颜色被表示、排序、比较或计算。</p>
<p>颜色空间定义了一维、二维、三维或四维的环境，其组成部分(或颜色组成部分)代表强度值。颜色组成部分也称为 颜色通道。</p>
<p>例如，RGB空间是一种三维颜色空间，它是根据红色、绿色和蓝色的强度相互促进来确定一种颜色。红、绿和蓝是它的颜色通道。</p>
<p>Apple 的 ColorSync技术 直接支持几种不同的颜色空间，让你在最适合你需要的任何颜色数据中都很方便。ColorSync颜色空间可以分为几个组或基族，它们是:</p>
<ul>
<li>Gray spaces：用于灰度显示和打印</li>
<li>RGB-based color spaces：主要用于显示器和扫描仪</li>
<li>CMYK-based color spaces：主要用于彩色打印</li>
<li>Device-independent color spaces：如L<em>a</em>b，主要用于颜色比较、色差和颜色转换</li>
<li>Named color spaces：主要用于打印和图形设计</li>
<li>Heterogeneous HiFi color spaces：也称为多通道颜色空间，主要用于涉及使用红橙色、绿色和蓝色的新印刷工艺，也用于专色，例如金和银金属</li>
</ul>
<p>基本族中的所有颜色空间通过非常简单的数学公式相互关联，或者仅在存储格式的细节上有所不同。</p>
<h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>Quartz支持色彩管理系统使用的标准颜色空间(standard color spaces)、用于与设备无关的颜色空间(device-independent color spaces)、还支持通用(generic)、索引(indexed)和模式( pattern color spaces)颜色空间。</p>
<p>iOS不支持device-independent、generic color spaces，iOS程序只使用 device color spaces。</p>
<h4 id="device-color-spaces"><a href="#device-color-spaces" class="headerlink" title="device color spaces"></a>device color spaces</h4><p>设备颜色空间主要由iOS应用程序使用，通过使用以下功能之一来创建设备色彩空间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于设备相关的灰度颜色空间</span></span><br><span class="line"><span class="keyword">let</span> graySpace = <span class="type">CGColorSpaceCreateDeviceGray</span>()</span><br><span class="line"><span class="comment">// 用于设备依赖的RGB颜色空间</span></span><br><span class="line"><span class="keyword">let</span> rgbSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line"><span class="comment">// 用于设备依赖的CMYK颜色空间</span></span><br><span class="line"><span class="keyword">let</span> cmykSpace = <span class="type">CGColorSpaceCreateDeviceCMYK</span>()</span><br></pre></td></tr></table></figure>

<p>Quartz提供了一组用于设置填充颜色(fill color)，笔触颜色(stroke color)，颜色空间(color spaces)和Alpha的功能。这些颜色参数都应用于图形状态(Graphics States)，这意味着设置之后，该设置将一直有效，直到设置为另一个值。</p>
<p>一个颜色必须有一个关联的颜色空间，否则Quartz将不知道如何解释颜色值。并且还需要为绘图目标提供适当的颜色空间。</p>
<p>Quartz提供了便捷的方法为设备颜色空间设置颜色：</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15983400650229.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">50</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">    context?.closePath()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 通过创建颜色空间来设置颜色</span></span><br><span class="line"><span class="comment">//      let rgbSpace = CGColorSpaceCreateDeviceRGB()</span></span><br><span class="line"><span class="comment">//      let values:[CGFloat] = [0.3, 1.0, 0.9, 1.0]</span></span><br><span class="line"><span class="comment">//      let color = CGColor(colorSpace: rgbSpace, components: values)!</span></span><br><span class="line"><span class="comment">//      context?.setFillColor(color)</span></span><br><span class="line">        </span><br><span class="line">    context?.setLineWidth(<span class="number">2.0</span>)</span><br><span class="line">    <span class="comment">// 通过 Quartz 提供的便捷的方法来设置颜色</span></span><br><span class="line">    context?.setStrokeColor(red: <span class="number">237</span>/<span class="number">225.0</span>, green: <span class="number">101</span>/<span class="number">255.0</span>, blue: <span class="number">90</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.setFillColor(red: <span class="number">245</span>/<span class="number">255.0</span>, green: <span class="number">187</span>/<span class="number">255.0</span>, blue: <span class="number">65</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.drawPath(using: .fillStroke)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渲染意图-Rending-Intent"><a href="#渲染意图-Rending-Intent" class="headerlink" title="渲染意图(Rending Intent)"></a>渲染意图(Rending Intent)</h3><p>渲染意图指定Quartz如何将颜色从源颜色空间映射到图形上下文的目标颜色空间范围内的颜色。如果没有明确的设置，Quartz默认对位图(采样)图像采用 <code>.perceptual</code>，其它所有绘图采用 <code>.relativeColorimetric</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置渲染意图</span></span><br><span class="line"><span class="comment"> * .defaultIntent 使用默认的渲染意图。</span></span><br><span class="line"><span class="comment"> * .absoluteColorimetric 绝对色度渲染意图。</span></span><br><span class="line"><span class="comment"> * .relativeColorimetric 相对色度渲染意图。</span></span><br><span class="line"><span class="comment"> * .perceptual 感知渲染意图。</span></span><br><span class="line"><span class="comment"> * .saturation 饱和度渲染意图。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">context?.setRenderingIntent(.relativeColorimetric)</span><br></pre></td></tr></table></figure>


<h2 id="变换-Transforms"><a href="#变换-Transforms" class="headerlink" title="变换(Transforms)"></a>变换(Transforms)</h2><p>Quartz 2D绘图模型定义了两个完全独立的坐标空间：用户空间(表示文档页面)和设备空间(表示设备的原生分辨率)。</p>
<p>用户空间坐标是浮点数，与设备空间中像素的分辨率无关。当您想打印或显示文档时，Quartz将用户空间坐标映射到设备空间坐标。因此，您不必重写应用程序或编写额外代码来调整应用程序的输出，以在不同设备上实现最佳显示。</p>
<p>当前变换矩阵(current transformation matrix，又称CTM)，可以通过操作CTM来修改默认用户空间，Quartz 提供了内置的变换函数。在绘制图像之前，可以操纵CTM旋转，缩放或平移页面，从而变换要绘制的对象。</p>
<p>如下在图形上下文中绘制一张图片：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="comment">/* 在指定区域内绘制图像，</span></span><br><span class="line"><span class="comment">     * rect：会不成比例的缩放图片，以适应rect参数指定的边界。</span></span><br><span class="line"><span class="comment">     * byTiling：为true，会以rect为起点，把图片平铺上下文的整个区域。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context?.draw((<span class="type">UIImage</span>(named: <span class="string">"butterfly"</span>)?.cgImage!)!, <span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">50</span>, y:<span class="number">0</span> , width: <span class="number">100</span>, height: <span class="number">200</span>), byTiling: <span class="literal">true</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15983433267209.jpg" class="" title="This is an example image">


<p>可以发现图片是颠倒的，这是因为 Quartz 2D的图形绘制引擎坐标是左下角为原点，y轴向上。和UIKit坐标系坐标轴上下相反，所以图片上下颠倒。下面通过修改 CTM 属性来调整图片的绘制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="keyword">let</span> imgRect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y:<span class="number">0</span> , width: <span class="number">100</span>, height: <span class="number">180</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平移，为旋转作准备</span></span><br><span class="line">    context?.translateBy(x: imgRect.width + imgRect.origin.x * <span class="number">2</span>, y: imgRect.size.height + imgRect.origin.y * <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 以上下文的坐标原点(左上角)进行旋转。由于UIkit坐标系先对于 Quartz 2D 坐标系颠倒了y轴，所以旋转角度为正值顺时针旋转，负值逆时针</span></span><br><span class="line">    context?.rotate(by: <span class="type">CGFloat</span>.pi)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 把图片进行缩放，避免变形</span></span><br><span class="line">    context?.scaleBy(x: <span class="number">1.0</span>, y: <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    context?.draw((<span class="type">UIImage</span>(named: <span class="string">"butterfly"</span>)?.cgImage!)!, <span class="keyword">in</span>: imgRect, byTiling: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15983457217493.jpg" class="" title="This is an example image">

<blockquote>
<p>注意，我们通过 CTM 进行平移、旋转、缩放操作时，它们执行的顺序不一样，会导致不同结果。</p>
</blockquote>
<p>Quartz中 仿射变换(CGAffineTransform) 可以实现与 CTM函数 相同的变换操作，使用仿射变换函数构造矩阵，调用函数CGContextConcatCTM应用于CTM，达到变换效果。</p>
<p>如下操作通过放射变换达到与CTM等价的效果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="keyword">let</span> imgRect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y:<span class="number">0</span> , width: <span class="number">100</span>, height: <span class="number">180</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> transform = <span class="type">CGAffineTransform</span>(translationX: imgRect.origin.x * <span class="number">2</span> + imgRect.size.width, y: imgRect.origin.y * <span class="number">2</span> + imgRect.size.height)</span><br><span class="line">    transform = transform.rotated(by: <span class="type">CGFloat</span>.pi)</span><br><span class="line">    transform = transform.scaledBy(x: <span class="number">1.0</span>, y: <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 使用指定的矩阵转换上下文中的用户坐标系统</span></span><br><span class="line">    context?.concatenate(transform)</span><br><span class="line">        </span><br><span class="line">    context?.draw((<span class="type">UIImage</span>(named: <span class="string">"butterfly"</span>)?.cgImage!)!, <span class="keyword">in</span>: imgRect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，连接矩阵的顺序很重要——矩阵乘法不是可交换的。也就是说，矩阵A乘以矩阵B的结果不一定等于矩阵B乘以矩阵A的结果。</p>
</blockquote>
<h2 id="Patterns-模式、样式"><a href="#Patterns-模式、样式" class="headerlink" title="Patterns(模式、样式)"></a>Patterns(模式、样式)</h2><ul>
<li><code>Pattern</code> 是在图形上下文中重复绘制的一系列绘图操作。可以像使用颜色一样使用Pattern。</li>
</ul>
<p>使用 <code>Pattern</code> 绘制时，<code>Quartz</code> 将页面划分为一组模式单元格，每个单元格的大小与模式图像相同，并使用提供的回调绘制每个单元格。</p>
<ul>
<li><code>pattern cell</code> 是 <code>pattern</code> 的基本组成部分。</li>
</ul>
<p>当您绘制 <code>pattern cell(模式单元格)</code> 时，<code>Quartz</code> 使用 <code>pattern space</code> 作为坐标系统。模式空间是一个抽象空间，它通过创建 <code>pattern</code> 时指定的转换矩阵映射到默认用户空间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在此回调函数中绘制 Colored Pattern Cell</span></span><br><span class="line"><span class="comment"> * pointer 是与 pattern 相关联的私有数据的通用指针</span></span><br><span class="line"><span class="comment"> * context 表示绘制图案单元的图形上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> callBacks = <span class="type">CGPatternCallbacks</span>(version: <span class="number">1</span>, drawPattern: &#123; (pointer, context) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(pointer?.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>) ?? <span class="number">111</span>)   <span class="comment">// 打印两次分别输出：321 和 0</span></span><br><span class="line">&#125;) &#123; (pointer) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"释放资源"</span>)</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> arr = <span class="number">321</span></span><br><span class="line"><span class="comment">///创建 pattern 对象</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - info: 一个指针，指向 pattern 绘制函数中使用数据的私有存储的指针</span></span><br><span class="line"><span class="comment">///   - bounds: 在模式空间中指定pattern cell的边界框</span></span><br><span class="line"><span class="comment">///   - matrix: 一个CGAffineTransform矩阵，表示从模式空间到使用模式的上下文的默认用户空间的转换</span></span><br><span class="line"><span class="comment">///   - xStep: pattern cell 之间的水平间距。如果pattern cell之间水平间距为0，则此值应设置为 pattern cell的width</span></span><br><span class="line"><span class="comment">///   - yStep: pattern cell 之间的垂直间距。</span></span><br><span class="line"><span class="comment">///   - tiling: 一个 CGPatternTiling 常量，指定的平铺模式。</span></span><br><span class="line"><span class="comment">///   - isColored: 定模式单元格是着色模式(true)还是模板模式(false)</span></span><br><span class="line"><span class="comment">///   - callbacks: 指向模式回调函数表的指针，该函数由 CGPatternCallbacks 创建</span></span><br><span class="line"><span class="keyword">let</span> pattern = <span class="type">CGPattern</span>(info: &amp;arr, bounds: rect, matrix: <span class="type">CGAffineTransform</span>.identity, xStep: <span class="number">40</span>, yStep: <span class="number">40</span>, tiling: <span class="type">CGPatternTiling</span>.constantSpacing, isColored: <span class="literal">false</span>, callbacks: &amp;callBacks);</span><br></pre></td></tr></table></figure>

<h3 id="colored-Patterns-着色模式-和-Stencil-Uncolored-Patterns-未着色模式"><a href="#colored-Patterns-着色模式-和-Stencil-Uncolored-Patterns-未着色模式" class="headerlink" title="colored Patterns(着色模式) 和 Stencil (Uncolored) Patterns(未着色模式)"></a>colored Patterns(着色模式) 和 Stencil (Uncolored) Patterns(未着色模式)</h3><p><code>colored Patterns</code>有与之相关的内在颜色，是在模式单元格创建过程中指定的，而不是在模式绘制过程中指定的。</p>
<p><code>Stencil (Uncolored) Patterns</code>：当<code>pattern cell</code>被定义时，没有颜色与它相关联。颜色是在模式绘制过程中指定的，而不是在模式单元格创建过程中指定的。</p>
<h3 id="Tiling-平铺"><a href="#Tiling-平铺" class="headerlink" title="Tiling(平铺)"></a>Tiling(平铺)</h3><p>平铺是将模式单元格(pattern cell)呈现到页面的一部分的过程。当 <code>Quartz</code> 向设备呈现 <code>pattern</code> 时，<code>Quartz</code> 可能需要调整 <code>pattern</code> 以适应设备空间。因为用户空间单位和设备像素之间存在差异，所以在用户空间中定义的“pattern cell”在呈现到设备时可能不完全适合。<br>Quartz 有三个平铺选项，用来调整 pattern：</p>
<p>1、<code>CGPatternTiling.noDistortion</code><br>以稍微调整 <code>pattern cell</code> 之间的间距为代价，但不超过一个设备像素。称为：无失真。</p>
<p>2、<code>CGPatternTiling.constantSpacingMinimalDistortion</code><br>单元之间的间距，以略微扭曲 <code>pattern cell</code> 为代价，但不超过一个设备像素。称为：具有最小失真的恒定间距</p>
<p>3、<code>CGPatternTiling.constantSpacing</code><br>单元之间的间距一样，如同 <code>.constantSpacingMinimalDistortion</code>，可能被另外扭曲，以允许更有效的实现。称为：恒定间距</p>
<h3 id="Patterns如何工作"><a href="#Patterns如何工作" class="headerlink" title="Patterns如何工作"></a>Patterns如何工作</h3><p><code>Pattern</code> 的操作与颜色类似，可以设置填充 或 描边<code>Pattern</code>，然后调用绘制函数。<code>Quartz</code> 使用你设置的 <code>Pattern</code> 来进行绘制时，需要先调用 <code>context?.setFillPattern</code> 来设置模式，然后用此 pattern 绘制填充的矩形。使用 <code>color</code> 和 <code>pattern</code> 绘制的区别在于必须定义图案。</p>
<p>使用 <code>Pattern</code> 填充或描边时，<code>Quartz</code> 会执行以下任务来绘制每个图案单元格:</p>
<ol>
<li>保存图像状态(graphics state)；</li>
<li>将当前转换矩阵转换为 <code>Pattern Cell</code> 的原点；</li>
<li>将 <code>CTM</code> 与 模式矩阵连接起来；</li>
<li>剪辑到 <code>Pattern Cell</code> 的边界矩形；</li>
<li>调用绘图回调函数来绘制 <code>Pattern Cell</code>；</li>
<li>恢复图形状态(graphics state)；</li>
</ol>
<p>Quartz负责为处理 Tiling(平铺)，反复将 <code>Pattern Cell</code> 呈现到绘图空间，直到绘制完整个空间，可以使用描边或填充<code>Pattern Cell</code>。<code>Pattern Cell</code>的大小可以是任意的，如果您想要查看模式，您应该确保模式单元格与绘图空间相匹配，若不匹配，<code>Pattern Cell</code>将会被剪裁。</p>
<h3 id="使用-Patterns-进行绘制"><a href="#使用-Patterns-进行绘制" class="headerlink" title="使用 Patterns 进行绘制"></a>使用 Patterns 进行绘制</h3><p>1、colored Patterns(着色模式) </p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15994483068097.jpg" class="" title="This is an example image">

<p>通过 Apple 官方的例子，colored Patterns在 iOS12.0 模拟器上是无法设置颜色的，其它版本正常。真机12.x上也是正常。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制 Colored Patterns</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1、在回调函数中绘制Colored Pattern Cell</span></span><br><span class="line">    <span class="comment">// 在绘制时需要设置 color，使其成为 colored pattern</span></span><br><span class="line">    <span class="keyword">var</span> callBacks = <span class="type">CGPatternCallbacks</span>(version: <span class="number">0</span>, drawPattern: &#123; (pointer, context) <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">        context.setFillColor(red: <span class="number">1.0</span>, green: <span class="number">0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">        context.setStrokeColor(red: <span class="number">0</span>, green: <span class="number">0</span>, blue: <span class="number">1.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">        context.setLineWidth(<span class="number">2.0</span>)</span><br><span class="line">            </span><br><span class="line">        context.beginPath()</span><br><span class="line">        context.addRect(.<span class="keyword">init</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">20</span>, height: <span class="number">20</span>));</span><br><span class="line">        context.closePath()</span><br><span class="line">        context.drawPath(using: .fillStroke)</span><br><span class="line">    </span><br><span class="line">    &#125;) &#123; (pointer) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"释放资源"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.saveGState()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、设置Colored Pattern 的颜色空间</span></span><br><span class="line">    <span class="keyword">let</span> patternSpace = <span class="type">CGColorSpace</span>(patternBaseSpace: <span class="literal">nil</span>)</span><br><span class="line">    context?.setFillColorSpace(patternSpace!)</span><br><span class="line">    <span class="comment">//context?.setStrokeColorSpace(patternSpace!)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 3、创建 Colored Pattern</span></span><br><span class="line">    <span class="comment">// 由于是 Colored Pattern，所以 isColored 必须为 true</span></span><br><span class="line">    <span class="keyword">let</span> pattern = <span class="type">CGPattern</span>(info: <span class="literal">nil</span>, bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">40</span>, height: <span class="number">40</span>), matrix: <span class="type">CGAffineTransform</span>.identity, xStep: <span class="number">40</span>, yStep: <span class="number">40</span>, tiling: <span class="type">CGPatternTiling</span>.noDistortion, isColored: <span class="literal">true</span>, callbacks: &amp;callBacks);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 4、为图形上下文设置fill pattern</span></span><br><span class="line">    <span class="comment">// 由于是 colored pattern，colorComponents需要传入一个alpha</span></span><br><span class="line">    <span class="keyword">var</span> alp: <span class="type">CGFloat</span> = <span class="number">1.0</span></span><br><span class="line">    context?.setFillPattern(pattern!, colorComponents: &amp;alp)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 5、填充图形上下文</span></span><br><span class="line">    context?.fill(rect)</span><br><span class="line">    context?.restoreGState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Stencil (Uncolored) Patterns(未着色模式)</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15985117897814.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1、在回调函数中绘制 Stencil pattern cell</span></span><br><span class="line">    <span class="comment">// 此回调函数与 colored pattern cell 绘制回调函数的唯一区别是，绘图回调中不指定任何颜色</span></span><br><span class="line">    <span class="keyword">var</span> callBacks = <span class="type">CGPatternCallbacks</span>(version: <span class="number">1</span>, drawPattern: &#123; (pointer, context) <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> psize: <span class="type">CGFloat</span> = <span class="number">40</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="number">0.8</span> * psize / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> theta = <span class="type">CGFloat</span>.pi * <span class="number">2</span> * (<span class="number">2.0</span> / <span class="number">5.0</span>)</span><br><span class="line">        context.translateBy(x: psize / <span class="number">2</span>, y: psize / <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        context.beginPath()</span><br><span class="line">        context.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: r))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">            context.addLine(to: <span class="type">CGPoint</span>(x: r * sin(<span class="type">CGFloat</span>(k) * theta), y: r * cos(<span class="type">CGFloat</span>(k) * theta)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        context.closePath()</span><br><span class="line">        context.fillPath()</span><br><span class="line">    </span><br><span class="line">    &#125;) &#123; (pointer) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"释放资源"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、创建 Stencil Pattern，注意：此时isColored必须传 false</span></span><br><span class="line">    <span class="keyword">let</span> pattern = <span class="type">CGPattern</span>(info: <span class="literal">nil</span>, bounds: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">40</span>, height: <span class="number">40</span>), matrix: <span class="type">CGAffineTransform</span>.identity, xStep: <span class="number">40</span>, yStep: <span class="number">40</span>, tiling: <span class="type">CGPatternTiling</span>.constantSpacing, isColored: <span class="literal">false</span>, callbacks: &amp;callBacks);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3、设置 Stencil Pattern 的颜色空间，用于Stencil pattern cell的绘制</span></span><br><span class="line">    <span class="keyword">let</span> baseSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">    <span class="keyword">let</span> patternSpace = <span class="type">CGColorSpace</span>(patternBaseSpace: baseSpace)</span><br><span class="line">    context?.setFillColorSpace(patternSpace!)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4、将 Stencil Pattern 进行描边 或者 填充</span></span><br><span class="line">    <span class="comment">// 由于 pattern cell 绘制回调函数中不提供颜色，因此此时必须传入颜色值。</span></span><br><span class="line">    <span class="keyword">let</span> colors:[<span class="type">CGFloat</span>] = [<span class="number">246</span>/<span class="number">255.0</span>, <span class="number">190</span>/<span class="number">255.0</span>, <span class="number">73</span>/<span class="number">255.0</span>, <span class="number">1</span>]</span><br><span class="line">    context?.setFillPattern(pattern!, colorComponents: colors)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5、填充绘制到整个图形上下文的空间中</span></span><br><span class="line">    context?.fill(rect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影(Shadows)"></a>阴影(Shadows)</h2><p>阴影是画在图形对象下面并与之偏移的图像，这样阴影就模仿了光源投射在图形对象上的效果。</p>
<p>阴影有三个属性：</p>
<ul>
<li>x偏移量，它指定阴影在水平方向上与图像的偏移距离。</li>
<li>y偏移量，它指定阴影在垂直方向上与图像的偏移距离。</li>
<li>模糊值，它指定图像是具有硬边缘，还是漫反射边缘。</li>
</ul>
<p>Quartz中的 <code>Shadows</code> 是 <code>graphics state</code>(图形状态)的一部分，可以通过下面方法设置黑色和彩色阴影，彩色阴影颜色的值取决于您想要绘制的颜色空间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context?.setShadow(offset: , blur: )</span><br><span class="line">context?.setShadow(offset: , blur: , color: )</span><br></pre></td></tr></table></figure>

<p>在iOS中，如果使用Quartz 2D API创建PDF或位图上下文，则正y的偏移量表示向上位移；如果图形上下文是由UIKit创建的，则正y偏移表示向下位移。阴影绘制约定不受当前转换矩阵的影响。</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15985157777569.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    </span><br><span class="line">    context?.saveGState()</span><br><span class="line">    <span class="keyword">let</span> shadowOffset = <span class="type">CGSize</span>(width: -<span class="number">15</span>, height: <span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式一：设置默认黑色阴影</span></span><br><span class="line">    context?.setShadow(offset: shadowOffset, blur: <span class="number">5</span>)</span><br><span class="line">    context?.setFillColor(red: <span class="number">0</span>, green: <span class="number">1</span>, blue: <span class="number">0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    context?.fill(<span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：设置彩色阴影</span></span><br><span class="line">    <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">    <span class="keyword">let</span> values:[<span class="type">CGFloat</span>] = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>]</span><br><span class="line">    <span class="keyword">let</span> color = <span class="type">CGColor</span>(colorSpace: colorSpace, components: values)</span><br><span class="line">    context?.setShadow(offset: shadowOffset, blur: <span class="number">5</span>, color: color)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    context?.setFillColor(red: <span class="number">0</span>, green: <span class="number">0</span>, blue: <span class="number">1</span>, alpha: <span class="number">1</span>)</span><br><span class="line">    context?.fill(<span class="type">CGRect</span>(x: <span class="number">80</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    context?.restoreGState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渐变色-Gradients"><a href="#渐变色-Gradients" class="headerlink" title="渐变色(Gradients)"></a>渐变色(Gradients)</h2><p><code>Quartz</code> 为创建 <code>Gradients</code> 提供了两种不透明的数据类型：<code>CGShadingRef</code> 和 <code>CGGradientRef</code>。可以使用其中任何一个来创建轴向或径向渐变。渐变是一种从一种颜色到另一种颜色的填充。</p>
<ul>
<li><p><code>axial gradient</code>：轴向渐变(也称为线性渐变)沿两个端点之间的轴变化。垂直于坐标轴的直线上的所有点都有相同的颜色值。</p>
</li>
<li><p><code>radial gradient</code>：径向渐变是在两个定义的端点之间沿轴径向变化的填充，这两个端点通常都是圆。如果点位于中心点落在轴上的圆的圆周上，则它们共享相同的颜色值。梯度的圆形截面的半径由端圆的半径定义;每个中间圆的半径从一端到另一端线性地变化。</p>
</li>
</ul>
<h3 id="CGShading-和-CGGradient"><a href="#CGShading-和-CGGradient" class="headerlink" title="CGShading 和 CGGradient"></a>CGShading 和 CGGradient</h3><p><code>CGShading</code> 和 <code>CGGradient</code> 都可以创建渐变，它们的区别是：</p>
<p><code>CGShadingRef</code> 不透明数据类型使您可以控制渐变中每个点的颜色是如何计算的。在创建CGShading对象之前，您必须创建一个CGFunction对象(CGFunctionRef)，它定义了一个在渐变中计算颜色的函数。</p>
<table>
<thead>
<tr>
<th>CGGradient</th>
<th>CGShading</th>
</tr>
</thead>
<tbody><tr>
<td>可以使用同一对象绘制轴向和径向渐变</td>
<td>需要为轴向和径向渐变创建单独的对象</td>
</tr>
<tr>
<td>在绘图时设置渐变的几何形状</td>
<td>在创建对象时设置渐变的几何形状</td>
</tr>
<tr>
<td>Quartz计算渐变中每个点的颜色</td>
<td>必须提供一个回调函数来计算渐变中每个点的颜色</td>
</tr>
<tr>
<td>易于定义两个以上的位置和颜色</td>
<td>需要你安排回调函数来使用两个以上的位置和颜色，因此您需要做更多的工作。</td>
</tr>
</tbody></table>
<h3 id="CGGradient的使用"><a href="#CGGradient的使用" class="headerlink" title="CGGradient的使用"></a>CGGradient的使用</h3><p>1、绘制红色到蓝色的线性渐变</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15988382826721.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpace</span>(name: <span class="type">CGColorSpace</span>.genericRGBLinear)</span><br><span class="line">    <span class="keyword">let</span> components: [<span class="type">CGFloat</span>] = [<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>,    <span class="comment">// start color 红色</span></span><br><span class="line">                                <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]    <span class="comment">// end color 蓝色</span></span><br><span class="line">    <span class="keyword">let</span> locations: [<span class="type">CGFloat</span>] = [<span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/// 根据相关的参数创建 CGGradient 对象</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - space: 用于渐变的颜色空间。不能使用 Indexed and Pattern ColorSpace</span></span><br><span class="line">    <span class="comment">///   - components: 定义渐变的每种颜色的颜色组成部分</span></span><br><span class="line">    <span class="comment">///   - locations: 为components中每种颜色提供的位置。取值范围为0~1，如果该数组中不包括0和1，则Quartz将为这些位置使用最接近0和1的颜色。</span></span><br><span class="line">    <span class="comment">///   - count: 提供的位置(locations)个数</span></span><br><span class="line">    <span class="keyword">let</span> gradient = <span class="type">CGGradient</span>(colorSpace: colorSpace!, colorComponents: components, locations: locations, <span class="built_in">count</span>: <span class="number">2</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">let</span> startPt = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> endPt = <span class="type">CGPoint</span>(x: rect.width, y: rect.height)</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 绘制渐变填充</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - gradient: 渐变对象</span></span><br><span class="line">    <span class="comment">///   - startPoint: 定义渐变起点的坐标</span></span><br><span class="line">    <span class="comment">///   - endPoint: 定义渐变终点的坐标</span></span><br><span class="line">    <span class="comment">///   - options:用于控制填充是延伸到起点还是终点之外。如： drawsBeforeStartLocation 表示填充超出起始的颜色，该颜色为CGGradient中定义locations位于0的纯色</span></span><br><span class="line">    context?.drawLinearGradient(gradient!, start: startPt, end: endPt, options: .drawsBeforeStartLocation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2、绘制红色到蓝色的径向渐变</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15988396459223.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startCenter = <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>)</span><br><span class="line"><span class="keyword">let</span> startRd: <span class="type">CGFloat</span> = <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> endCenter = <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">150</span>)</span><br><span class="line"><span class="keyword">let</span> endRd: <span class="type">CGFloat</span> = <span class="number">50</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 绘制沿提供的起始圆和结束圆定义的区域变化的渐变填充</span></span><br><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - gradient: 渐变对象</span></span><br><span class="line"><span class="comment">///   - startCenter: 起始圆中心的坐标</span></span><br><span class="line"><span class="comment">///   - startRadius: 起始圆的半径</span></span><br><span class="line"><span class="comment">///   - endCenter: 结束圆中心的坐标</span></span><br><span class="line"><span class="comment">///   - endRadius: 结束圆的半径</span></span><br><span class="line"><span class="comment">///   - options: 用于控制渐变是在开始圆之前绘制还是在结束圆之后绘制。</span></span><br><span class="line">context?.drawRadialGradient(gradient!, startCenter: startCenter, startRadius: startRd, endCenter: endCenter, endRadius: endRd, options: .drawsBeforeStartLocation)</span><br></pre></td></tr></table></figure>
<p>当然你也可以使用同一个 <code>CGGradient</code> 对象来同时绘制渐变，我们可以把上面的渐变叠加绘制，效果如下：</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15988414922076.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorSpace = <span class="type">CGColorSpace</span>(name: <span class="type">CGColorSpace</span>.genericRGBLinear)</span><br><span class="line"><span class="keyword">let</span> components: [<span class="type">CGFloat</span>] = [<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>,    <span class="comment">// start color</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]    <span class="comment">// end color</span></span><br><span class="line"><span class="keyword">let</span> locations: [<span class="type">CGFloat</span>] = [<span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradient = <span class="type">CGGradient</span>(colorSpace: colorSpace!, colorComponents: components, locations: locations, <span class="built_in">count</span>: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startPt = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> endPt = <span class="type">CGPoint</span>(x: rect.width, y: rect.height)</span><br><span class="line">context?.drawLinearGradient(gradient!, start: startPt, end: endPt, options: .drawsBeforeStartLocation)</span><br></pre></td></tr></table></figure>

<h3 id="CGShading的使用"><a href="#CGShading的使用" class="headerlink" title="CGShading的使用"></a>CGShading的使用</h3><p>关于 CGShading  的 API 的使用比较繁琐，后续研究了再作补充。</p>
<h2 id="透明层-Transparency-Layers"><a href="#透明层-Transparency-Layers" class="headerlink" title="透明层(Transparency Layers)"></a>透明层(Transparency Layers)</h2><p><code>Transparency Layer</code> 由两个或多个对象组成，这些对象组合在一起产生一个复合图形。生成的组合被视为单个对象。当你想要对一组对象应用效果时，透明层是非常有用的。</p>
<p>如果没有透明层，三个矩形的阴影将不会作为整体设置阴影：</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15988563744714.jpg" class="" title="This is an example image">

<p>如下操作，通过使用透明层，使得三个矩形可以作为一个整体来设置阴影：</p>
<img src="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/15988562884821.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shadowOffset = <span class="type">CGSize</span>(width: <span class="number">10</span>, height: <span class="number">20</span>)</span><br><span class="line">    context?.setShadow(offset: shadowOffset, blur: <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> wd = rect.width</span><br><span class="line">    <span class="keyword">let</span> ht = rect.height</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 透明层开始</span></span><br><span class="line">    <span class="comment">// 指定上下文中的所有后续绘图操作都被组合到一个完全透明的背景中</span></span><br><span class="line">    context?.beginTransparencyLayer(auxiliaryInfo: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    context?.setFillColor(red: <span class="number">0</span>, green: <span class="number">1</span>, blue: <span class="number">0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">    context?.fill(<span class="type">CGRect</span>(x: wd/<span class="number">3</span> + <span class="number">50</span>, y: ht/<span class="number">2</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">    context?.setFillColor(red: <span class="number">1</span>, green: <span class="number">0</span>, blue: <span class="number">0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">    context?.fill(<span class="type">CGRect</span>(x: wd/<span class="number">3</span> + <span class="number">25</span>, y: ht/<span class="number">2</span> - <span class="number">25</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    context?.setFillColor(red: <span class="number">0</span>, green: <span class="number">0</span>, blue: <span class="number">1</span>, alpha: <span class="number">1</span>)</span><br><span class="line">    context?.fill(<span class="type">CGRect</span>(x: wd/<span class="number">3</span>, y: ht/<span class="number">4</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结束透明层</span></span><br><span class="line">    <span class="comment">// 使用上下文的全局alpha和阴影状态将结果合成到上下文中</span></span><br><span class="line">    context?.endTransparencyLayer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="noopener">Quartz 2D编程指南</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148-CH204-BBCHJACF" target="_blank" rel="noopener">Introduction to Color Management Overview</a></p>
<p><a href="http://southpeak.github.io/categories/translate/page/2/" target="_blank" rel="noopener">南峰子翻译的Quartz2D编程指南</a></p>
<p><a href="https://markmiao.com/2016/12/13/Quartz2D1/" target="_blank" rel="noopener">Quartz 2D（一）概念、图形上下文、路径</a></p>
<p><a href="https://my.oschina.net/u/2340880/blog/779926" target="_blank" rel="noopener">Patterns模型的应用</a></p>
<p><a href="https://swift.gg/2017/01/05/draw-gradients-core-graphics-tutorial-ios10/" target="_blank" rel="noopener">通过 Core Graphics 绘制渐变颜色</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/">http://yoursite.com/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Core-Graphics/">Core Graphics</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>CALayer解析</span></a></div><div class="next-post pull-right"><a href="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/"><span>Core Graphics绘图(一)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>