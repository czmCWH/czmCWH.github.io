<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Block"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Block | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Block的基本使用"><span class="toc-number">1.</span> <span class="toc-text">Block的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block-的概念"><span class="toc-number">2.</span> <span class="toc-text">Block 的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Block的功能"><span class="toc-number">2.1.</span> <span class="toc-text">Block的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block回调"><span class="toc-number">2.2.</span> <span class="toc-text">Block回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block-和-变量"><span class="toc-number">3.</span> <span class="toc-text">block 和 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block使用的变量类型"><span class="toc-number">3.1.</span> <span class="toc-text">block使用的变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block存储类型"><span class="toc-number">3.2.</span> <span class="toc-text">__block存储类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象和block变量"><span class="toc-number">3.3.</span> <span class="toc-text">对象和block变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Objective-C对象"><span class="toc-number">3.3.1.</span> <span class="toc-text">Objective-C对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-对象"><span class="toc-number">3.3.2.</span> <span class="toc-text">C++对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block对象"><span class="toc-number">3.3.3.</span> <span class="toc-text">block对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block-Tips"><span class="toc-number">4.</span> <span class="toc-text">Block Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#避免的模式"><span class="toc-number">4.1.</span> <span class="toc-text">避免的模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block存放区域"><span class="toc-number">4.2.</span> <span class="toc-text">block存放区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在MRC环境下"><span class="toc-number">4.2.1.</span> <span class="toc-text">在MRC环境下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在ARC环境下"><span class="toc-number">4.2.2.</span> <span class="toc-text">在ARC环境下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block循环引用-Retain-Circle"><span class="toc-number">4.3.</span> <span class="toc-text">block循环引用(Retain Circle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并不是所有block里面都用weakSelf"><span class="toc-number">4.4.</span> <span class="toc-text">并不是所有block里面都用weakSelf</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Block</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/runtime/">runtime</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><ul>
<li><p><code>Block</code> 对象是一个<code>C</code>语言层级的语法和 <code>runtime</code> 的特性。</p>
</li>
<li><p><code>Block</code> 类似于标准<code>C</code>函数，但除了可执行代码外，它还可能包含了自动(栈<code>stack</code>)或托管(堆<code>heap</code>)的内存所绑定的变量。因此，<code>Block</code> 可以保存一组状态(数据)，当执行它时可以使用这些状态(数据)来影响行为。</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>可以使用<code>Block</code>来编写函数表达式，这些函数表达式可以传递给<code>API</code>，可以将其存储并由多个线程使用。</p>
</li>
<li><p><code>Block</code>作为回调特别有用，因为<code>Block</code>既包含回调时要执行的代码，也包含执行过程中所需的数据。</p>
</li>
<li><p><code>block runtime</code>是开源的，可以在<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/" target="_blank" rel="noopener">LLVM’s compiler-rt</a>子项目存储库中找到，或<a href="https://opensource.apple.com/source/libclosure/libclosure-63/" target="_blank" rel="noopener">Open Sourece</a>查看，或者下载<a href="https://opensource.apple.com/tarballs/libclosure/" target="_blank" rel="noopener">源码</a>。 </p>
</li>
<li><p><code>Block</code>也提交给<code>C</code>标准工作组，由于<code>Objective-C</code>和<code>C++</code>都从<code>C</code>派生而来，所以<code>Block</code>被设计成可以在这三种语言中运行（以及<code>Objective-C++</code>）。</p>
</li>
</ul>
<h2 id="Block的基本使用"><a href="#Block的基本使用" class="headerlink" title="Block的基本使用"></a>Block的基本使用</h2><p>创建一个<code>block</code>时，<code>^</code>运算符指示<code>block</code>字面量表达式的开头，它的后面可能跟着一个包含在<code>()</code>中的参数列表。<code>Block</code>的主体包含在<code>{}</code>中。<code>block</code>定义语法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;returnType&gt;(^&lt;blockName&gt;)(&lt;parameterTypes&gt;) = ^(&lt;parameters&gt;) &#123;</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、定义有参数和无参数的block</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、声明block变量，block变量保存对block的引用。</span></span><br><span class="line"><span class="keyword">int</span> (^sumBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">sumBlock = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过block变量名，像调用函数一样block一样使用它</span></span><br><span class="line"><span class="comment">// block变量保存对block的引用， 如：sumBlock</span></span><br><span class="line"><span class="keyword">int</span> sum = sumBlock(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2、定义无参block</span></span><br><span class="line"><span class="comment">// 声明无参数的block必须在参数列表中指定void</span></span><br><span class="line"><span class="keyword">void</span> (^block1)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了block1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、定义<code>block</code>时返回值类型通常省略</p>
<p>如果没有显式声明<code>Block</code>表达式的返回值，则可以从块的内容自动推导出返回值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block4)(<span class="built_in">NSString</span> *) = ^ <span class="keyword">void</span> (<span class="built_in">NSString</span> *str)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (^block5)() = ^&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、block的类型</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block4的类型：int(^)(NSString *)</span></span><br><span class="line"><span class="keyword">int</span> (^block4)(<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、通常，<code>block</code>用作为参数传递给方法或函数。这样的情况下，通常创建一个内联块(<code>block &quot;inline&quot;</code>)，而不需要声明</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSome:(<span class="built_in">NSInteger</span> (^)(<span class="built_in">NSString</span> *))doBlock &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = doBlock(<span class="string">@"张三"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> doSome:^ <span class="built_in">NSInteger</span> (<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    <span class="keyword">return</span> [str isEqualToString:<span class="string">@"张三"</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>5、<code>typedef</code>关键字给定义的<code>block</code>类型取别名，定义语法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> &lt;returnType&gt;(^&lt;name&gt;)(&lt;arguments&gt;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>(^CalculateBlock)(<span class="keyword">float</span>, <span class="keyword">float</span>);</span><br><span class="line"></span><br><span class="line">CalculateBlock divBlock = ^(<span class="keyword">float</span> a, <span class="keyword">float</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b + a / b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> res = divBlock(<span class="number">2.15</span>, <span class="number">3.56</span>);</span><br></pre></td></tr></table></figure>

<p>6、全局block<br>在文件层面，可以定义全局<code>block</code>字面量表达式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> (^getCount)(<span class="built_in">NSString</span> *) = ^ <span class="built_in">NSInteger</span> (<span class="built_in">NSString</span> *name) &#123;</span><br><span class="line">    <span class="keyword">return</span> [name isEqualToString:<span class="string">@"测试"</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Block-的概念"><a href="#Block-的概念" class="headerlink" title="Block 的概念"></a>Block 的概念</h2><p><code>Block</code>对象提供了一种创建特殊函数体的方法，函数体可用<code>C</code>和<code>C衍生</code>语言(如<code>Objective-C</code>和<code>C++</code>)作为表达式。在其他语言和环境中，<code>Block</code>对象有时也称为“闭包”(<code>closure</code>)。</p>
<h3 id="Block的功能"><a href="#Block的功能" class="headerlink" title="Block的功能"></a>Block的功能</h3><p><code>Block</code>是一个匿名的内联代码块，它包含：</p>
<ul>
<li>和函数一样具有类型化的参数列表</li>
<li>具有推断或声明的返回类型</li>
<li>可以在它定义的词法范围内 捕获 状态</li>
<li>可以有选择地修改词法范围的状态</li>
<li>可以与在相同的词法范围内定义的其它 <code>Block</code> 共享修改状态</li>
<li>在词法作用域(<code>stack</code>)被销毁后，可以继续共享和修改在词法作用域(<code>stack</code>)中定义的状态</li>
</ul>
<p>可以<code>copy</code>一个<code>Block</code>，甚至将它传递给其他线程以延迟执行(或本线程的执行循环里)。编译器 和 <code>runtime</code> 会把<code>Block</code>用到的所有变量保存到<code>Block</code>的所有副本的生命周期后。</p>
<blockquote>
<p>注意：尽管 <code>Block</code> 可以用于纯<code>C</code>和<code>c++</code>，但是<code>Block</code>也是一个<code>Objective-C</code>对象。</p>
</blockquote>
<h3 id="Block回调"><a href="#Block回调" class="headerlink" title="Block回调"></a><code>Block</code>回调</h3><p><code>Block</code> 通常表示小段的，独立的代码块。因此，它们在封装并发执行的工作单元、集合中的项或在另一个操作完成时作为回调函数特别有用。</p>
<p><code>Block</code>是传统回调函数的有用替代方法，主要有两个原因：</p>
<ul>
<li><p>允许你在方法调用的地方编写<code>block</code>代码，并稍后在方法实现的上下文中执行。<br>因此，<code>Block</code>通常是框架方法的参数。</p>
</li>
<li><p><code>block</code>允许访问局部变量。<br>相比于回调函数需要一个在执行回调操作所需的所有上下文信息的数据结构，<code>block</code>可以直接访问本地变量。</p>
</li>
</ul>
<h2 id="block-和-变量"><a href="#block-和-变量" class="headerlink" title="block 和 变量"></a>block 和 变量</h2><h3 id="block使用的变量类型"><a href="#block使用的变量类型" class="headerlink" title="block使用的变量类型"></a>block使用的变量类型</h3><p>在 <code>Block</code> 对象的代码体中可以引用三种标准类型的变量，就像函数传参一样：</p>
<ul>
<li>全局变量，包括静态局部变量；</li>
<li>全局函数，(从技术上讲，它不是变量)；</li>
<li>作用域中的局部变量和参数；</li>
</ul>
<p><code>Block</code> 还支持另外两种类型的变量：</p>
<ul>
<li>在函数级别上是<code>__block</code>变量。 它们在 <code>Block</code>（和作用域）内是可变的，如果将引用的 <code>Block</code> 复制到堆(<code>heap</code>)中，则将保留它们。</li>
<li><code>const</code>导入</li>
</ul>
<p>以下规则适用于 <code>Block</code> 中使用的变量：</p>
<p><strong>1、</strong> 可以访问全局变量，包括存在于作用域内的静态(<code>static</code>)变量。</p>
<p><strong>2、</strong>传递给 <code>Block</code> 的参数是可访问的（就像函数的参数一样）。</p>
<p><strong>3、</strong>词法作用域内的栈(<code>stack</code>，或者非静态)变量被捕获为常量(<code>const</code>)变量。<br>它们的值在程序内的<code>Block</code>表达式处获取。在嵌套<code>Block</code>中，从最近的封闭范围中捕获值。</p>
<p><strong>4、</strong>用<code>__block</code>存储修饰符声明的词法作用域内的局部变量，是传递引用的，因此是可变的。<br>任何更改都将反映在词法作用域内，包括在同一词法作用域内定义的任何其他<code>block</code>。</p>
<p><strong>5、</strong>在<code>block</code>的词法作用域内声明的局部变量，其行为与函数中的局部变量完全相同。<br><code>block</code>的每次调用都提供该变量的新副本。这些变量又可以在块中作为常量(<code>const</code>)使用，或在<code>block</code>内包含的<code>block</code>中的引用变量。</p>
<h3 id="block存储类型"><a href="#block存储类型" class="headerlink" title="__block存储类型"></a>__block存储类型</h3><ul>
<li><p>可以在 <code>block</code> 内部读取导入变量的值，直接修改变量的值会报错。可以通过 <code>__block</code> 存储类型修饰符来指定导入到<code>block</code> 内部的变量是可变的(即可读写)。</p>
</li>
<li><p><code>__block</code>存储方式类似于局部变量的<code>register</code>、<code>auto</code>和<code>static</code>存储类型，但它们相互排斥。</p>
</li>
<li><p><code>__block</code>变量存在于存储中，该存储在变量的词法范围与在该变量的词法范围内声明或创建的所有<code>block</code>和<code>block</code>副本之间共享。给定词法作用域中的多个<code>block</code>可以同时使用一个共享变量。</p>
</li>
</ul>
<blockquote>
<p>注意：作为一种优化，<code>block</code>存储从栈(<code>stack</code>)开始，就像<code>block</code>本身一样。如果<code>block</code>是用<code>Block_copy</code>(或在<code>Objective-C</code>中发送<code>copy</code>)复制的，则会将<code>block</code>变量复制到堆(<code>heap</code>)。因此一个<code>__block</code>变量的地址会随时间改变。</p>
<p> <code>__block</code>变量还有两个严格的限制：它们不能是可变长度数组，也不能是包含<code>C99</code>可变长度数组的结构体。</p>
</blockquote>
<p><strong>1、</strong><code>block</code> 内部使用 (<code>static</code>、<code>non-static</code>、<code>__block</code>修饰的)局部变量</p>
<ul>
<li>(<code>static</code> 和 <code>__block</code>修饰的)局部变量是引用传递；</li>
<li><code>non-static</code>的局部变量是值传递；</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">__block <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    b = b * <span class="number">10</span>;</span><br><span class="line">    c = c * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a = %d, b = %d, c = %d"</span>, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line">a = <span class="number">5</span>; b = <span class="number">5</span>; c = <span class="number">5</span>;</span><br><span class="line">testBlock();        <span class="comment">// a = 3, b = 50, c = 50</span></span><br></pre></td></tr></table></figure>

<p><strong>2、</strong><code>block</code>中使用全局变量</p>
<ul>
<li>在 <code>block</code> 中使用全局变量是引用传递</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        a = a * <span class="number">10</span>;</span><br><span class="line">        b = b * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a = %d, b = %d"</span>, a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    a = <span class="number">5</span>; b = <span class="number">5</span>;</span><br><span class="line">    testBlock();        <span class="comment">//  a = 50, b = 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象和block变量"><a href="#对象和block变量" class="headerlink" title="对象和block变量"></a>对象和block变量</h3><p><code>block</code>提供对<code>Objective-C</code>和<code>C++</code>对象以及其他<code>block</code> 作为变量的支持。</p>
<h4 id="Objective-C对象"><a href="#Objective-C对象" class="headerlink" title="Objective-C对象"></a>Objective-C对象</h4><p>当复制<code>block</code>时，它会创建对在<code>block</code>中使用的对象变量的强引用。如果在方法的实现中使用<code>block</code>：</p>
<ul>
<li>如果通过引用访问实例变量，则会对<code>self</code>进行强引用。</li>
<li>如果按值访问实例变量，则会对该变量进行强引用。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, <span class="keyword">self</span>.count);   <span class="comment">// 会对 self 进行一次强引用</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSInteger</span> countP = <span class="keyword">self</span>.count;</span><br><span class="line"><span class="keyword">void</span> (^testBlock2)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, countP);   <span class="comment">// 直接使用 countP 的值，会对countP强引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="C-对象"><a href="#C-对象" class="headerlink" title="C++对象"></a>C++对象</h4><p>一般来说，可以在<code>block</code>内使用<code>C++</code>对象。在成员函数中，对成员变量和函数的引用是通过隐式导入该指针实现的，因此看起来是可变的。如果<code>block</code>被复制，有两个注意事项:</p>
<ul>
<li><p>如果你有一个<code>__block</code>存储类来存储基于栈(<code>stack</code>)的<code>C++</code>对象，那么将使用常规<code>copy</code>构造函数。</p>
</li>
<li><p>如果在<code>block</code>中使用任何其他基于<code>c++</code>栈(<code>stack</code>)的对象，则它必须具有<code>const</code>的<code>copy</code>构造函数。然后使用该构造函数复制<code>c++</code>对象。</p>
</li>
</ul>
<h4 id="block对象"><a href="#block对象" class="headerlink" title="block对象"></a>block对象</h4><p>当您复制一个<code>block</code>时，如果需要，将复制该<code>block</code>中对其他<code>block</code>的任何引用——可以复制整个树(从顶部开始)。如果您有<code>block</code>变量，并且从该<code>block</code>中引用了一个<code>block</code>，那么该<code>block</code>将被复制。</p>
<h2 id="Block-Tips"><a href="#Block-Tips" class="headerlink" title="Block Tips"></a>Block Tips</h2><h3 id="避免的模式"><a href="#避免的模式" class="headerlink" title="避免的模式"></a>避免的模式</h3><p><code>block</code>字面量(即：<code>^{ ... }</code>)是表示<code>Block</code>栈(<code>stack</code>)本地数据结构的地址。因此，栈(<code>stack</code>)本地数据结构的范围是封闭的复合语句，因此应避免以下示例中显示的模式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blockArray[<span class="number">3</span>])(<span class="keyword">void</span>);  <span class="comment">// 定义包含3个block引用的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        blockArray[i] = ^&#123; printf(<span class="string">"hello, %d\n"</span>, i); &#125;;</span><br><span class="line">        <span class="comment">// 错误：block字面量的范围是 for 循环</span></span><br><span class="line">    &#125;</span><br><span class="line">blockArray[<span class="number">1</span>]();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int</span> i = random();</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    block = ^&#123; printf(<span class="string">"got i at: %d\n"</span>, i); &#125;;</span><br><span class="line">    <span class="comment">// 错误：block字面量的范围是 then 子句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="block存放区域"><a href="#block存放区域" class="headerlink" title="block存放区域"></a>block存放区域</h3><p>在<code>block runtime</code>中，定义了6种类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteStackBlock[<span class="number">32</span>];  栈上创建的block；由系统自动分配和释放，作用域执行完毕之后就会被立即释放</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>];  堆上创建的block</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>];</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>];</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>];  全局变量的block，存储在.data区(数据区)；直到程序结束才会被回收</span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>

<h4 id="在MRC环境下"><a href="#在MRC环境下" class="headerlink" title="在MRC环境下"></a>在MRC环境下</h4><p>如果<code>block</code>没有引用外部的局部变量，<code>block</code>放在全局区<br>如果<code>block</code>引用了外部的局部变量，<code>block</code>就放在栈里面</p>
<p>在<code>MRC</code>环境下，<code>block</code>只能使用<code>copy</code>，不能使用<code>retain</code>。使用<code>retain</code>，则<code>block</code>存放在栈里面。使用 <code>copy</code> 会把 <code>block</code> 从栈空间复制到堆空间。</p>
<h4 id="在ARC环境下"><a href="#在ARC环境下" class="headerlink" title="在ARC环境下"></a>在ARC环境下</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^globalBlock)(<span class="keyword">void</span>) = ^&#123; &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, testBlock, globalBlock);   <span class="comment">// __NSGlobalBlock__, __NSGlobalBlock__</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    __block <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">void</span> (^testBlock)(<span class="keyword">void</span>) = ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, b); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当<code>block</code>中使用了外部的 非静态的 和 <code>__block</code>修饰的 局部变量， <code>block</code>存储在堆区；如果使用了 静态变量 和 全局变量  则存放在全局区。</p>
</li>
<li><p>ARC环境下，<code>block</code>用 <code>strong</code> 和 <code>copy</code> 修饰效果是一样的。</p>
</li>
</ul>
<p>具体可以参考<a href="https://juejin.im/post/5b0181e15188254270643e88#heading-18" target="_blank" rel="noopener">掘金 探寻block的本质</a>。</p>
<h3 id="block循环引用-Retain-Circle"><a href="#block循环引用-Retain-Circle" class="headerlink" title="block循环引用(Retain Circle)"></a>block循环引用(Retain Circle)</h3><p>通常我们会在某个类中定义一个<code>block</code>类型的变量，当在该类中使用<code>block</code>时用到了该类的实例变量。这时候<code>block</code>对象会与该对象相互持有发生循环引用，引起内存泄漏的问题。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSome &#123;</span><br><span class="line">    <span class="keyword">self</span>.workBlock = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、可以通过<code>__weak</code>修饰符解决循环引用：</p>
<p><code>__weak</code>修饰符的变量被<code>Block</code>捕获时是对其进行弱引用持有的，可以避免循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：__weak ClassName</span></span><br><span class="line">__<span class="keyword">weak</span> MyPerson *weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.workBlock = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：typeof用来获取self的类型</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.workBlock = ^&#123;</span><br><span class="line">    [weakSelf test];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们通常会定义一个宏：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAKSELF __weak typeof(self) weakSelf = self;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAKSELF typeof(self) __weak weakSelf = self;</span></span><br></pre></td></tr></table></figure>


<p>2、<code>__weak</code> 和 <code>__strong</code></p>
<p>当<code>block</code>执行时，如果<code>__weak</code>修饰的变量被提前释放了，则会出现野指针，导致内存泄漏。</p>
<p>如果不允许在<code>block</code>执行时<code>self</code>被释放，则需要在<code>block</code>内部使用<code>__strong</code>修饰一个局部变量来接收<code>weakSelf</code>，防止<code>weakSelf</code>提前释放，<code>strongSelf</code>会对<code>self</code>产生一个强引用，当<code>block</code>执行结束时便会释放。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">_block = ^&#123;</span><br><span class="line">    <span class="comment">// strongSelf 不允许self在这个执行过程中释放</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strongSelf);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">_block();</span><br></pre></td></tr></table></figure>


<p>3、@weakify、@strongify</p>
<p><code>@weakify</code>、<code>@strongify</code>，这两个关键字是<code>RAC</code>(ReactiveCocoa)中避免 <code>Block</code> 循环引用而开发的2个宏<br>其实 <code>@weakify(self)</code> 和 <code>@strongify(self)</code> 就是比我们日常写的 <code>weakSelf</code>、<code>strongSelf</code> 多了一个 <code>@autoreleasepool{}</code> 而已，使用者两个宏，需要引入<code>RAC</code>的 <code>EXTScope.h</code> 和 <code>metamacros.h</code> 源文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> foo = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> bar = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line">@weakify(foo, bar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this block will not keep 'foo' or 'bar' alive</span></span><br><span class="line"><span class="built_in">BOOL</span> (^matchesFooOrBar)(<span class="keyword">id</span>) = ^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> obj)&#123;</span><br><span class="line">    <span class="comment">// but now, upon entry, 'foo' and 'bar' will stay alive until the block has finished executing</span></span><br><span class="line">    @strongify(foo, bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [foo isEqual:obj] || [bar isEqual:obj];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="并不是所有block里面都用weakSelf"><a href="#并不是所有block里面都用weakSelf" class="headerlink" title="并不是所有block里面都用weakSelf"></a>并不是所有block里面都用weakSelf</h3><p>在开发中，我们并不需要一定使用 <code>weakSelf</code>，这取决于是否存在循环引用。</p>
<p>1、系统的一些回调方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.view.alpha = <span class="number">1.0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>UIView 的某个负责动画的对象持有了 block，而block 持有了 self。因为 self 并不持有 block，所以就没有循环引用产生，因为就不需要使用 weak self 了。</p>
<p>2、常用的第三方库</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.bgView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.center.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>通过查看<code>Masonry</code>的源代码，在执行过程中会创建<code>MASConstraintMaker</code>类型的变量持有 <code>self.bgView</code>，而这个<code>block</code>并没有被任何对象持有，因此在 <code>Masnory</code> 中使用 self.xxx 不会循环引用。</p>
<br>
参考博客：

<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502" target="_blank" rel="noopener">Blocks Programming Topics</a></p>
<p><a href="http://zhangzr.cn/2018/03/12/iOS开发-消息传递方式-Block/#more" target="_blank" rel="noopener">zhangzr’s Block</a></p>
<p><a href="http://hchong.net/2017/07/04/Block%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">HChong</a></p>
<p><a href="https://juejin.im/post/5b0181e15188254270643e88#heading-18" target="_blank" rel="noopener">掘金</a><br><a href="https://halfrost.com/ios_block_retain_circle/" target="_blank" rel="noopener">一缕殇流化隐半边冰霜</a></p>
<p><a href="https://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="noopener">深入研究 Block 用 weakSelf、strongSelf、@weakify、@strongify 解决循环引用</a></p>
<p><a href="http://ziecho.com/post/ios/2016-08-04" target="_blank" rel="noopener">Reactive Cocoa中的@weakify、@strongify是如何装逼的</a></p>
<p><a href="https://a1049145827.github.io/2019/03/10/iOS-中的-block/" target="_blank" rel="noopener">iOS 中的 block</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/22/Block/">http://yoursite.com/2020/09/22/Block/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/12/Runloop-%E4%B8%80/"><i class="fa fa-chevron-left">  </i><span>Runloop(一)概念</span></a></div><div class="next-post pull-right"><a href="/2020/09/15/KVO/"><span>KVO</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>