<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="CALayer解析"><meta name="keywords" content="iOS,Core Animation"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>CALayer解析 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CALayer概念"><span class="toc-number">1.</span> <span class="toc-text">CALayer概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CALayer的绘图模型"><span class="toc-number">1.1.</span> <span class="toc-text">CALayer的绘图模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALayer动画"><span class="toc-number">1.2.</span> <span class="toc-text">CALayer动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALayer的两种类型坐标系"><span class="toc-number">1.3.</span> <span class="toc-text">CALayer的两种类型坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CALayer特有功能"><span class="toc-number">1.4.</span> <span class="toc-text">CALayer特有功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CALayer-的属性和方法"><span class="toc-number">2.</span> <span class="toc-text">CALayer 的属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#图层的几何坐标"><span class="toc-number">2.1.</span> <span class="toc-text">图层的几何坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#坐标转换"><span class="toc-number">2.2.</span> <span class="toc-text">坐标转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zPosition、anchorPointZ"><span class="toc-number">2.3.</span> <span class="toc-text">zPosition、anchorPointZ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图层的内容"><span class="toc-number">2.4.</span> <span class="toc-text">图层的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#contents"><span class="toc-number">2.4.1.</span> <span class="toc-text">contents</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contentsGravity"><span class="toc-number">2.4.2.</span> <span class="toc-text">contentsGravity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contentsScale"><span class="toc-number">2.4.3.</span> <span class="toc-text">contentsScale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#masksToBounds"><span class="toc-number">2.4.4.</span> <span class="toc-text">masksToBounds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contentsRect"><span class="toc-number">2.4.5.</span> <span class="toc-text">contentsRect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contentsCenter"><span class="toc-number">2.4.6.</span> <span class="toc-text">contentsCenter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义绘制"><span class="toc-number">2.4.7.</span> <span class="toc-text">自定义绘制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图层的外观设置"><span class="toc-number">2.5.</span> <span class="toc-text">图层的外观设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#圆角边框"><span class="toc-number">2.5.1.</span> <span class="toc-text">圆角边框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阴影"><span class="toc-number">2.5.2.</span> <span class="toc-text">阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图层蒙版"><span class="toc-number">2.5.3.</span> <span class="toc-text">图层蒙版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isOpaque"><span class="toc-number">2.5.4.</span> <span class="toc-text">isOpaque</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rasterization-栅格化、光栅化"><span class="toc-number">2.6.</span> <span class="toc-text">Rasterization(栅格化、光栅化)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldRasterize"><span class="toc-number">2.6.1.</span> <span class="toc-text">shouldRasterize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rasterizationScale"><span class="toc-number">2.6.2.</span> <span class="toc-text">rasterizationScale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拉伸过滤"><span class="toc-number">2.6.3.</span> <span class="toc-text">拉伸过滤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#专用图层"><span class="toc-number">3.</span> <span class="toc-text">专用图层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAShapeLayer"><span class="toc-number">3.1.</span> <span class="toc-text">CAShapeLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAGradientLayer"><span class="toc-number">3.2.</span> <span class="toc-text">CAGradientLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CATextLayer"><span class="toc-number">3.3.</span> <span class="toc-text">CATextLayer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用CALayer的技巧提示"><span class="toc-number">4.</span> <span class="toc-text">使用CALayer的技巧提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">5.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">CALayer解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Graphics-Animation/">Graphics &amp; Animation</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="CALayer概念"><a href="#CALayer概念" class="headerlink" title="CALayer概念"></a>CALayer概念</h2><p><code>CALayer</code> 继承自 <code>NSObject</code>，<code>CALayer</code>是在3D空间中的2D曲面，是 <code>Core Animation</code> 的核心。它提供了 绘图 和 动画 的基础。</p>
<p>与 <code>UIView</code> 一样，<code>CALayer</code> 管理几何图形(如：位置，大小和变换)、内容和表面的视觉属性(如：背景颜色，边框和阴影)；与 <code>UIView</code> 不同的是，<code>CALayer</code> 不定义自己的外观，仅管理位图周围的状态信息。位图可以是视图本身绘图的结果，也可以是您指定的固定图像的结果。</p>
<a id="more"></a>

<p><code>CALayer</code> 的主要作用是管理基于图像的内容，并对该内容执行动画。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">CALayer</span> : <span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">CAMediaTiming</span></span></span><br></pre></td></tr></table></figure>

<p><code>CALayer</code> 通过 <code>CALayerDelegate</code> 类型的 delegate 属性，提供图层的内容；处理子图层的布局；提供要执行的自定义动画动作。如果图层对象是由 UIView 创建的，必须将 <code>delegate</code> 属性设置为拥有该图层的视图。</p>
<p><code>CALayer</code> 通过遵守 <code>CAMediaTiming</code> 协议，来封装图层及其动画的持续时间和节奏，该协议定义了图层的计时信息。</p>
<p>在 <code>iOS</code> 中， <code>Core Animation</code>总是处于启用状态，每个 <code>UIView</code> 都有一个 <code>CALayer</code> 支持。在 <code>macOS</code> 中，应用程序必须通过操作显式启用核心动画支持。</p>
<h3 id="CALayer的绘图模型"><a href="#CALayer的绘图模型" class="headerlink" title="CALayer的绘图模型"></a>CALayer的绘图模型</h3><p>大多数情况下 <code>CALayer</code> 不会进行任何实际绘制，而是捕获 <code>UIView</code> 的内容并将其缓存在位图中，位图有时也称为<strong>后台存储</strong>。</p>
<p>当随后更改 <code>CALayer</code> 的属性时，您所做的只是更改与 <code>CALayer</code> 对象关联的状态信息。当更改触发动画时，<code>Core Animation</code> 将 <code>CALayer</code>的位图和状态信息传递给图形硬件(<code>graphics hardware</code>)，由图形硬件使用新信息渲染位图，其过程如下图所示：</p>
<p>在硬件中操作位图产生的动画比在软件中要快得多。</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15995306946548.jpg" class="" title="This is an example image">


<p>基于 <code>CALayer</code> 的绘制与更传统的基于 <code>UIView</code> 的绘制技术有很大的不同。<code>Core Animation</code> 是直接操作静态位图来绘制内容；而对 <code>UIView</code> 本身的更改，需要调用 <code>UIView</code> 的 <code>drawRect:</code> 方法来使用新的参数重新绘制内容，这一过程是使用主线程上的CPU来完成的，其绘制方式是昂贵的。</p>
<p><code>Core Animation</code> 会尽可能通过在硬件中操作缓存的位图来达到相同或类似的效果，从而避免了这种开销。</p>
<h3 id="CALayer动画"><a href="#CALayer动画" class="headerlink" title="CALayer动画"></a>CALayer动画</h3><p>下图是在 CALayer 上执行的几种动画类型，可参考触发动画<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW4" target="_blank" rel="noopener">CALayer动画属性</a>进行相关动画。</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15964233241256.jpg" class="" title="This is an example image">

<h3 id="CALayer的两种类型坐标系"><a href="#CALayer的两种类型坐标系" class="headerlink" title="CALayer的两种类型坐标系"></a>CALayer的两种类型坐标系</h3><p>CALayer 同时使用基于 点的坐标系 和 单位坐标系 来指定内容的放置。</p>
<p>基于点的坐标系，最常见的用途是指定图层的大小和位置，您可以使用 CALayer 的 bounds 和 position 属性进行指定。CALayer 的 frame 属性实际上是从bounds和position属性中的值派生的，使用频率较低。</p>
<p>单位坐标系，可以将单位坐标视为指定值的百分比，每个坐标值的范围为0.0至1.0。使用 单位坐标系的属性有：锚点(anchorPoint)、Core Animation的相关属性</p>
<h3 id="CALayer特有功能"><a href="#CALayer特有功能" class="headerlink" title="CALayer特有功能"></a>CALayer特有功能</h3><p>CALayer未通过UIView暴露出来的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框 3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<h2 id="CALayer-的属性和方法"><a href="#CALayer-的属性和方法" class="headerlink" title="CALayer 的属性和方法"></a>CALayer 的属性和方法</h2><h3 id="图层的几何坐标"><a href="#图层的几何坐标" class="headerlink" title="图层的几何坐标"></a>图层的几何坐标</h3><p><code>CALayer</code>的 <code>bounds</code>、<code>position</code>、<code>frame</code> 对应着 <code>UIView</code> 的 <code>bounds</code>、<code>center</code>、<code>frame</code>。当操作视图的frame时，实质上是操作下方 <code>CALayer</code> 的<code>frame</code>，不能独立于图层来操作视图的<code>frame</code>。</p>
<ul>
<li><p><code>frame</code>：表示图层父层坐标系中的位置和大小。它是一个计算属性，它是从<code>Bounds</code>、<code>anchorPoint</code>、<code>position</code> 和 <code>transform</code>属性中的值计算而来，其中任意一个属性改变都会影响frame。</p>
</li>
<li><p><code>bounds</code>：表示图层在自身坐标系中的位置和大小。</p>
</li>
<li><p><code>position</code>：用来设置 <code>CAlayer</code> 在父层中的位置，默认值为 <code>.zero</code>，以父层的左上角为坐标原点。</p>
</li>
<li><p><code>anchorPoint</code>：称为定位点、锚点，对<code>CALayer</code>的几何操作都围绕该点进行。它采用单位坐标系，默认值为 <code>(0.5, 0.5)</code>，表示 <code>layer</code> 矩形的中心。<code>anchorPoint</code> 决定 <code>CALayer</code> 身上的那个点会在 <code>position</code>属性所指的位置。</p>
</li>
</ul>
<h3 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(<span class="number">_</span> p: CGPoint, from l: CALayer?)</span></span> -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(<span class="number">_</span> p: CGPoint, to l: CALayer?)</span></span> -&gt; <span class="type">CGPoint</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(<span class="number">_</span> r: CGRect, from l: CALayer?)</span></span> -&gt; <span class="type">CGRect</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(<span class="number">_</span> r: CGRect, to l: CALayer?)</span></span> -&gt; <span class="type">CGRect</span></span><br></pre></td></tr></table></figure>

<h3 id="zPosition、anchorPointZ"><a href="#zPosition、anchorPointZ" class="headerlink" title="zPosition、anchorPointZ"></a>zPosition、anchorPointZ</h3><p>CALayer存在一个三维空间当中，下面两个属性都是表示图层在 Z轴 的位置。</p>
<ul>
<li><p><code>zPosition</code>：主要用于改变图层的显示顺序，或者在三维空间移动和旋转图层。</p>
</li>
<li><p><code>anchorPointZ</code>：表示图层在Z轴上的定位点，默认值为0。</p>
</li>
</ul>
<h3 id="图层的内容"><a href="#图层的内容" class="headerlink" title="图层的内容"></a>图层的内容</h3><p><code>CALayer</code> 是管理应用程序提供的内容的数据对象。<code>CALayer</code>的内容由一个位图组成，其中包含你想要显示的可视化数据。有如下三种方式提供 <code>CALayer</code> 内容：</p>
<ul>
<li>直接给 <code>CALayer</code> 的 <code>contents</code> 属性赋值 图像对象；(此技术最适用于从不更改或很少更改的层内容)</li>
<li>给<code>CALayer</code>分配一个 <code>delegate</code> 对象，让代理绘制层的内容。(此方式适合于可能周期性变化且可以由外部对象(如视图)提供的层内容。)</li>
<li>定义一个 <code>CALayer</code> 的子类并重写它的一个绘图方法来提供自己的层内容。(此方式适用于，当你必须创建一个自定义的图层子类，或者你想改变图层的基本绘制行为)</li>
</ul>
<h4 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h4><p>iOS中必须给 <code>contents</code> 赋值<code>CGImage</code>类型，否则会显示空白。<code>contents</code>值的类型为<code>Any?</code>，是因为在 <code>MacOS</code> 中，这个属性对 <code>CGImage</code> 和 <code>NSImage</code> 类型的值都起作用.<br>除了通过 <code>contents</code> 给图层设置寄宿图，我们还可以通过 <code>Core Graphics</code> 进行自定义绘制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redLayer.contents = <span class="type">UIImage</span>(named: <span class="string">"car_icon"</span>)?.cgImage</span><br></pre></td></tr></table></figure>

<h4 id="contentsGravity"><a href="#contentsGravity" class="headerlink" title="contentsGravity"></a>contentsGravity</h4><p>表示图层的内容如何在其边界内定位或缩放，取值分为两类：</p>
<ul>
<li>position-based gravity constants<br>允许您在不缩放图像的情况下将图像固定到层边界矩形的特定边缘或角落。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.center / .top / .bottom / .<span class="keyword">left</span> / .<span class="keyword">right</span></span><br><span class="line">.topLeft / .topRight / .bottomLeft / .bottomRight</span><br></pre></td></tr></table></figure>

<ul>
<li>scaling-based gravity constants<br>允许你使用几个选项中的一个来拉伸图像，其中一些保留了高宽比，而另一些则没有。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.resize      <span class="comment">// 默认值</span></span><br><span class="line">.resizeAspect</span><br><span class="line">.resizeAspectFill</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redLayer.contentsGravity = .center</span><br></pre></td></tr></table></figure>

<h4 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h4><p><code>contentsScale</code>定义<code>CALayer</code>的逻辑坐标空间（以点为单位）和物理坐标空间（以像素为单位）之间的映射。</p>
<p>该属性属于支持高分辨率屏幕机制的一部分，默认值为 1.0，表示以每个点1个像素绘制图片，一般设置其值为屏幕的scale。比如：当layer.size = (100，100)，scale = 2.0，则该layer最多可以显示200 pixels的图片。</p>
<p>只有在直接为图层的<code>contents</code>属性指定位图时，才需要更改<code>contentsScale</code> 属性的值。<code>UIKit</code>和<code>AppKit</code>中的层支持视图根据屏幕分辨率和视图管理的内容自动将其层的比例因子设置为适当的值。</p>
<p>如果对 contentsGravity 进行了 resize 缩放设置，则该属性无效。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br></pre></td></tr></table></figure>

<h4 id="masksToBounds"><a href="#masksToBounds" class="headerlink" title="masksToBounds"></a>masksToBounds</h4><p>该属性默认为false，为true表示裁剪掉超出边界的内容</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redLayer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h4><p>表示单位坐标空间中的矩形，它使用单位坐标(0~1)，定义使用图层内容的一部分。默认值是 (0.0, 0.0, 1.0, 1.0)，表示图层的所有内容可见。</p>
<p>可以通过该属性，进行 <strong>图片拼合</strong>(<code>image sprites</code>)，把几张图片载入到一张大图，然后赋值给几个独立的 <code>layer.contents</code>，进行调整<code>layer.contentsRect</code> 来分别显示不同的部分内容。这样做的好处：减少内存使用、载入时间、渲染性能等等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示水平方向一般，垂直方向的全部内容</span></span><br><span class="line">redLayer.contentsRect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0.5</span>, height: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h4><p> <code>contentsCenter</code>表示，当 <code>layer.contentsGravity = .resize</code>时，即图层内容大小可以被调整，如何对图层的内容矩形进行缩放。此属性也是采用 <code>单位坐标</code> 表示其值。</p>
<p>1、该属性把图层内容分成 3x3 的网格。该属性的值指定了该网格中 <code>中心矩形</code> 的位置和大小，即定义了一个固定的边框和一个在图 层上可拉伸的区域。</p>
<p>2、layer.contentsGravity 设置为调整大小模式，则在调整大小时，会导致 3x3 网格中的矩形进行不同程度的缩放。</p>
<p>3、中心矩形在两个维度中都被拉伸，上中心和下中心矩形仅水平拉伸，左中心和右中心矩形仅垂直拉伸，四个角矩形根本不拉伸。</p>
<p>当 contentsCenter = (0,0,1.0,1.0)时，整个图片内容在两个维度上缩放。</p>
<p>该属性的效果和 <code>UIImage</code> 的 <code>resizableImage(withCapInsets:, resizingMode:)</code> 方法很相似</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15967044127083.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redLayer.contents = <span class="type">UIImage</span>(named: <span class="string">"chat_send_nor"</span>)?.cgImage</span><br><span class="line">redLayer.contentsGravity = .resizeAspectFill</span><br><span class="line">redLayer.contentsCenter = <span class="type">CGRect</span>(x: <span class="number">0.1</span>, y: <span class="number">0.1</span>, width: <span class="number">0.8</span>, height: <span class="number">0.8</span>)</span><br></pre></td></tr></table></figure>

<h4 id="自定义绘制"><a href="#自定义绘制" class="headerlink" title="自定义绘制"></a>自定义绘制</h4><p>除了通过 <code>layer.contents</code> 设置图层的图片，还可以通过 <code>Core Graphics</code> 绘制 <code>CALayer</code> 的图像内容，有如下两种方式：</p>
<ol>
<li>重写UIView的 <code>draw(_ rect:)</code> 进行绘制。其底层还是 <code>CALayer</code> 完成，<code>UIView</code>只是进行一层封装</li>
<li>而对于在 <code>CALayer</code> 中重绘制内容，则需要借助它的代理</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">orangeLayer.delegate = <span class="keyword">self</span></span><br><span class="line"><span class="comment">// 需要显式调用display方法，因为CALayer不会自动重绘它的内容</span></span><br><span class="line">orangeLayer.display()</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 在调用该方法时，CALayer已经创建了一个空的寄宿图 和 一个Core Graphics的绘制上下文环境，因此我们可以在该方法中进行绘制。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> layer: CALayer, <span class="keyword">in</span> ctx: CGContext)</span></span> &#123;</span><br><span class="line">    <span class="type">CGContext</span>.setLineWidth(ctx)(<span class="number">10.0</span>)</span><br><span class="line">    <span class="type">CGContext</span>.setStrokeColor(ctx)(<span class="type">UIColor</span>.green.cgColor)</span><br><span class="line">    <span class="type">CGContext</span>.strokeEllipse(ctx)(<span class="keyword">in</span>: layer.bounds)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图层的外观设置"><a href="#图层的外观设置" class="headerlink" title="图层的外观设置"></a>图层的外观设置</h3><h4 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h4><ul>
<li><p>cornerRadius：设置图层的圆角半径，默认情况下它只作用于背景色和边框。若需要对图层的图像、子图层裁剪，需要借助 <code>masksToBounds</code> 属性。</p>
</li>
<li><p>borderColor：设置图层边框的颜色。</p>
</li>
<li><p>borderWidth：图层边框的宽度，默认0.0。当其值大于0.0时，会borderColor绘制边框。</p>
</li>
</ul>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>如果开启了 <code>masksToBounds = true</code> ，阴影将被裁减。图层阴影是根据图层的内容、背景颜色、子图层计算出来的，而不是根据边框。</p>
<ul>
<li>shadowColor：阴影的颜色，默认是不透明的黑色。</li>
<li>shadowOpacity：阴影的不透明度，0~1.0，默认0.0表示透明。</li>
<li>shadowOffset：阴影的偏移量，默认为 (0.0, -3.0)</li>
<li>hadowRadius ：阴影层的模糊半径，默认为0.3</li>
<li>shadowPath：指定阴影的形状，默认值为nil，即使用标准的阴影的形状。如果图层包含多个透明子图层，每个子图层还包含图片，这样计算阴影的时候是非常消耗资源的，可以通过该属性指定显式路径通常可以提高渲染性能</li>
</ul>
<h4 id="图层蒙版"><a href="#图层蒙版" class="headerlink" title="图层蒙版"></a>图层蒙版</h4><ul>
<li>contentLayer.mask：该属性接收一个CALayer类型，定义了图层的可见区域。注意 mask 接收的 layer，它的frame是相对于其父图层的。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentLayer = <span class="type">CALayer</span>()</span><br><span class="line">contentLayer.frame = <span class="type">CGRect</span>(x: <span class="number">150</span>, y: <span class="number">200</span>, width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br><span class="line">contentLayer.contents = <span class="type">UIImage</span>(named: <span class="string">"autumn"</span>)?.cgImage</span><br><span class="line">contentLayer.contentsGravity = .resizeAspectFill</span><br><span class="line"><span class="keyword">self</span>.view.layer.addSublayer(contentLayer)</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">let</span> maskLayer = <span class="type">CALayer</span>()</span><br><span class="line">maskLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">50</span>, width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">maskLayer.contents = <span class="type">UIImage</span>(named: <span class="string">"sun_icon"</span>)?.cgImage</span><br><span class="line"><span class="comment">//        maskLayer.backgroundColor = UIColor.yellow.cgColor</span></span><br><span class="line">maskLayer.contentsGravity = .resizeAspect</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 maskLayer 未被设置 backgroundColor，那么contentLayer 会把 maskLayer.frame 范围内的内容，按照 sun_icon 遮挡的部分显示出来</span></span><br><span class="line"><span class="comment">// 如果 maskLayer 设置了 backgroundColor，那么contentLayer 会把 maskLayer.frame 范围内的内容都显示出来</span></span><br><span class="line">contentLayer.mask = maskLayer</span><br></pre></td></tr></table></figure>

<h4 id="isOpaque"><a href="#isOpaque" class="headerlink" title="isOpaque"></a>isOpaque</h4><p><code>isOpaque</code>表示<code>CALayer</code>是否包含完全不透明的内容，默认值为false。</p>
<p>如果你的应用程序绘制了完全不透明的内容，填充了层的边界，将这个属性设置为true可以让系统优化层的渲染行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isOpaque: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rasterization-栅格化、光栅化"><a href="#Rasterization-栅格化、光栅化" class="headerlink" title="Rasterization(栅格化、光栅化)"></a>Rasterization(栅格化、光栅化)</h3><ul>
<li><p>向量图形：是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。</p>
</li>
<li><p>位图：又称为栅格图、点阵图。是使用像素阵列(Pixel-array/Dot-matrix点阵)来表示的图像。</p>
</li>
</ul>
<p>计算机显示器都要将矢量图形转换成栅格图像的格式，包含屏幕上每个像素数值的栅格图像保存在内存中。</p>
<ul>
<li>Rasterization(栅格化、光栅化)：是PS中的一个专业术语，栅格即像素，用于任何将 <strong>向量图形</strong> 转换成 <strong>位图</strong>(栅格图像) 的过程。</li>
</ul>
<p>栅格化在应用中通常表示在计算机上显示三维形状的流行渲染算法，是目前生成实时三维计算机图形最流行的算法。</p>
<p>最基础的栅格化算法将多边形表示的 三维场景 渲染到 二维表面。多边形由三角形的集合表示，三角形由三维空间中的三个顶点表示。在最简单的实现形式中，栅格化工具将顶点数据映射到观察者显示器上对应的二维坐标点，然后对变换出的二维三角形进行合适的填充。</p>
<h4 id="shouldRasterize"><a href="#shouldRasterize" class="headerlink" title="shouldRasterize"></a>shouldRasterize</h4><p><code>shouldRasterize</code> 表示 <code>CALayer</code> 在合成之前是否渲染为位图，即是否对 <code>CALayer</code> 进行栅格化。默认值为false。</p>
<p>如果值为true，则 <code>CALayer</code> 在其局部坐标系中渲染为位图，然后位图将合成到目标中。如果位图需要缩放，则应用 <code>minificationFilter</code> 和<code>magnificationFilter</code> 属性。</p>
<p>光栅化发生在 <code>CALayer</code> 的 <code>filters</code>(滤镜)和 <code>shadow</code>(阴影)被应用之后，但在 <code>opacity</code>(不透明度)调制之前。作为实现细节，渲染引擎(<code>Rendering Engine</code>)可能会尝试从一帧到下一帧缓存和重用位图，不管它是否会影响渲染输出。</p>
<p>如果值为false，<code>CALayer</code>将尽可能直接合成到目标中。但是，合成模型的某些特性可能会强制栅格化，例如添加过滤器(<code>filters</code>)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shouldRasterize: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="rasterizationScale"><a href="#rasterizationScale" class="headerlink" title="rasterizationScale"></a>rasterizationScale</h4><p><code>rasterizationScale</code> 当 <code>shouldRasterize</code> 的值为 true 时，相对于CALayer的坐标空间栅格化内容的比例，即确定是否缩放光栅化的内容。默认值为1.0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rasterizationScale: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure>


<h4 id="拉伸过滤"><a href="#拉伸过滤" class="headerlink" title="拉伸过滤"></a>拉伸过滤</h4><p>minificationFilter 和 magnificationFilter 是指缩小 或者 增大图层图片大小时使用的 <code>filters</code>(过滤器)。它们使用的场景是：当一张图片需要显示不同大小(比如：缩略图和大图)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.nearest</span><br><span class="line">.linear     <span class="comment">// 它们的默认值</span></span><br><span class="line">.trilinear</span><br></pre></td></tr></table></figure>

<h2 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h2><p>Core Animation提供了不同的图层类，每个图层类都提供了专门有用的功能。选择不同的图层类能够让你以简单的方式提高性能，或者支持特定类型的内容。CALayer类是所有层对象的根类。具体可以学习<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW4" target="_blank" rel="noopener">CALayer子类及其用途</a></p>
<h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p><code>CAShapeLayer</code> 用于在其坐标空间中绘制三次贝塞尔曲线样条的图层。<code>CAShapeLayer</code> 可以用来绘制所有能够通过 <code>CGPath</code> 来表示的形状。</p>
<ol>
<li><p>也可以在 <code>drawRect</code> 中用 <code>Core Graphics</code> 直接向原始的 <code>CALyer</code> 的内容中绘制一个路径，来达到此效果。但此方式占用CPU，消耗性能大；</p>
</li>
<li><p><code>CAShapeLayer</code> 将对图形进行抗锯齿绘制，并在可能的情况下将其映射到屏幕空间，然后再进行栅格化以保持分辨率的独立性。</p>
</li>
<li><p><code>CAShapeLayer</code> 通过在其合成时将提供的路径渲染为位图图像来创建其内容。这样做的好处是图层总是以尽可能最好的分辨率绘制路径，但这一好处是以额外的渲染时间为代价的。</p>
</li>
</ol>
<p>在使用 <code>CAShapeLayer</code> 时，需要考虑如下问题：</p>
<ul>
<li><p>如果您提供的路径很复杂，那么对该路径进行光栅化可能会花费太多。</p>
</li>
<li><p>如果层的大小频繁变化(因此必须频繁重绘)，绘制所花费的时间就会增加，并成为性能瓶颈。</p>
</li>
</ul>
<p>解决办法：可以将复杂的形状分解为简单的形状，来减少绘制的时间。<br>在合成器中，使用简单的路径，并将多个CAShapeLayer对象层叠在一起比绘制一个大的复杂路径要快得多。这是因为绘图操作时在CPU上进行的，而合成是在GPU上进行的。</p>
<p>1、CAShapeLayer根据路径来绘制形状</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991003888497.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(arcCenter: <span class="type">CGPoint</span>(x: <span class="number">25</span>, y: <span class="number">25</span>), radius: <span class="number">25</span>, startAngle: <span class="number">0</span>, endAngle: -<span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">false</span>)</span><br><span class="line">path.move(to: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">25</span>))</span><br><span class="line">path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">25</span>))</span><br><span class="line">path.addArc(withCenter: <span class="type">CGPoint</span>(x: <span class="number">125</span>, y: <span class="number">25</span>), radius: <span class="number">25</span>, startAngle: <span class="type">CGFloat</span>.pi, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">3</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> shapLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapLayer.position = <span class="type">CGPoint</span>(x: <span class="number">125</span>, y: <span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置需要渲染的形状的路径</span></span><br><span class="line">shapLayer.path = path.cgPath</span><br><span class="line"><span class="comment">// 设置形状路径的线宽</span></span><br><span class="line">shapLayer.lineWidth = <span class="number">2.0</span></span><br><span class="line"><span class="comment">// 设置填充形状路径的颜色，如果为nil, 路径不会填充渲染，则默认使用不透明黑色</span></span><br><span class="line">shapLayer.fillColor = <span class="type">UIColor</span>.clear.cgColor</span><br><span class="line"><span class="comment">// 设置形状路径的描边颜色，如果为nil，则不会描边</span></span><br><span class="line">shapLayer.strokeColor = <span class="type">UIColor</span>.blue.cgColor</span><br><span class="line"><span class="comment">// 停止移动路径的相对位置，取值0.0～1.0，默认值1.0</span></span><br><span class="line">shapLayer.strokeEnd = <span class="number">1.0</span></span><br><span class="line">view.layer.addSublayer(shapLayer)</span><br></pre></td></tr></table></figure>

<p>2、CAShapeLayer绘制路径线段</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991005189446.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> linePath = <span class="type">UIBezierPath</span>()</span><br><span class="line">linePath.move(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">185</span>))</span><br><span class="line">linePath.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">120</span>, y: <span class="number">235</span>))</span><br><span class="line">linePath.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">300</span>, y: <span class="number">235</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> shapLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapLayer.path = linePath.cgPath</span><br><span class="line">shapLayer.lineWidth = <span class="number">5.0</span></span><br><span class="line">shapLayer.fillColor = <span class="type">UIColor</span>.clear.cgColor</span><br><span class="line">shapLayer.strokeColor = <span class="type">UIColor</span>.black.cgColor</span><br><span class="line">shapLayer.strokeEnd = <span class="number">1.0</span></span><br><span class="line"><span class="comment">// 设置状路径的线帽样式，即路径开口处端点的形状，默认值.butt</span></span><br><span class="line"><span class="comment">// .butt(方形)  .round(圆形)  .square(方形，会往外延伸一半的宽度)</span></span><br><span class="line">shapLayer.lineCap = .butt</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置形状路径的虚线模式，其值数组元素的含义为：每个元素表示线段的长度 和 间隔 交替出现</span></span><br><span class="line">shapLayer.lineDashPattern = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment">// 设置绘制形状路径路径时虚线模式的偏移量</span></span><br><span class="line">shapLayer.lineDashPhase = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置形状路径的线条连接处的样式</span></span><br><span class="line"><span class="comment">// .bevel(方形的连接，默认值)；.miter(尖角的接头，)；.round(圆形接头)</span></span><br><span class="line"><span class="comment">//        shapLayer.lineJoin = .round</span></span><br><span class="line">view.layer.addSublayer(shapLayer)</span><br></pre></td></tr></table></figure>

<p>3、CAShapeLayer填充路径时的规则</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991005974260.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> leftPath = <span class="type">UIBezierPath</span>(rect: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">80</span>, height: <span class="number">80</span>))</span><br><span class="line"><span class="keyword">let</span> rightPath = <span class="type">UIBezierPath</span>(rect: <span class="type">CGRect</span>(x: <span class="number">40</span>, y: <span class="number">0</span>, width: <span class="number">80</span>, height: <span class="number">80</span>))</span><br><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">path.append(leftPath)</span><br><span class="line">path.append(rightPath)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> shapLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapLayer.frame = <span class="type">CGRect</span>(x: <span class="number">125</span>, y: <span class="number">180</span>, width: <span class="number">120</span>, height: <span class="number">135</span>)</span><br><span class="line">shapLayer.path = path.cgPath</span><br><span class="line">shapLayer.fillColor = <span class="type">UIColor</span>.red.cgColor</span><br><span class="line">shapLayer.strokeColor = <span class="type">UIColor</span>.black.cgColor</span><br><span class="line"><span class="comment">// 填充形状路径时使用的填充规则，默认值为：.nonZero</span></span><br><span class="line"><span class="comment">// even-odd winding rule(奇偶规则填充)：计算路径与区域点射线交叉总数，总次数为偶数，表示点在路径外部，则不填充；如果为奇数则填充</span></span><br><span class="line"><span class="comment">// non-zero winding rule(非零环绕数原则)：路径与区域点射线交叉时路径的方向，从左到右的路径计数为+1，从右到左的路径计数为-1，所有交叉点的和为0,则不绘制该点所在区域；非0则绘制</span></span><br><span class="line">shapLayer.fillRule = .evenOdd</span><br><span class="line">view.layer.addSublayer(shapLayer)</span><br></pre></td></tr></table></figure>

<p>如上介绍了 <code>CAShapeLayer</code> 的基本API，当然开发中我们使用 <code>CAShapeLayer</code> 远远不止这些，比如：给控件添加任意圆角；进度条 直线、圆环（纯色 or 渐变色）；实现复杂的View的遮罩效果；实现一些动画等等。</p>
<h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p><code>CAGradientLayer</code> 是用于在背景上绘制渐变色的图层，用于填充图层的形状(包括圆角)。</p>
<ul>
<li><code>.axial</code>：轴向渐变，又称为线性渐变，垂直于坐标轴的直线上的所有点都有相同的颜色值。本例子效果如下：</li>
</ul>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991118892917.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradientLayer.frame = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">100</span>, width: <span class="number">300</span>, height: <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置每个渐变停止的颜色</span></span><br><span class="line">gradientLayer.colors = [<span class="type">UIColor</span>.red.cgColor, <span class="type">UIColor</span>.green.cgColor, <span class="type">UIColor</span>.yellow.cgColor]</span><br><span class="line"><span class="comment">// 每个渐变停止点的位置，取值为 0.0~1.0</span></span><br><span class="line">gradientLayer.locations = [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置渐变样式，默认 .axial</span></span><br><span class="line">gradientLayer.type = .axial</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在图层的坐标空间中绘制时渐变的起点，默认值(0.5,0.0)，起点对应于渐变的第一个停止点</span></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 终点对应渐变的最后一个停止点，默认值为（0.5,1.0）</span></span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">view.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.radial</code>：径向渐变，渐变定义为椭圆，其中心位于 startPoint ，其宽度和高度分别由(endPoint.x - startPoint.x) * 2 和 (endPoint.y - startPoint.y) * 2 定义。本例子效果如下：</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991122273333.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradientLayer.type = .radial</span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0.5</span>, y: <span class="number">0.5</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">3.0</span>/<span class="number">2.0</span>, y: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><code>.conic</code>：圆锥形渐变，渐变以 startPoint 为中心，然后以顺时针方向绕中心实现渐变效果。当 startPoint 和 endPoint 重叠时，结果是未定义的。本例子效果如下：</li>
</ul>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991128868636.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、圆锥形渐变</span></span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">12.0</span>, *) &#123;</span><br><span class="line">    gradientLayer.type = .conic</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gradientLayer.type = .radial</span><br><span class="line">&#125;</span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0.5</span>, y: <span class="number">0.5</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p><code>CATextLayer</code> 用于提供简单文本布局以及普通字符串或属性字符串的呈现的图层。</p>
<p>在渲染文本时，CATextLayer禁用亚像素反锯齿。当文本在栅格化的同时被合成到现有的不透明背景中时，只能使用亚像素反锯齿来绘制文本。在有了背景像素之前，没有办法自己用亚像素反锯齿来绘制文本，无论是图像还是层。将图层的不透明度属性设置为true不会改变渲染模式。</p>
<p>1、绘制普通文本</p>
<img src="/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/15991176325419.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textLayer = <span class="type">CATextLayer</span>()</span><br><span class="line">textLayer.backgroundColor = <span class="type">UIColor</span>.gray.withAlphaComponent(<span class="number">0.2</span>).cgColor</span><br><span class="line">textLayer.frame = <span class="type">CGRect</span>(x: <span class="number">25</span>, y: <span class="number">100</span>, width: <span class="number">350</span>, height: <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">textLayer.string = <span class="string">"好好学习，天天向上！"</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> font = <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">25</span>)</span><br><span class="line"><span class="keyword">let</span> fontName = font.fontName <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line"><span class="comment">// 可以是一个CTFont，一个CGFont，一个NSFont的实例(仅macOS)，或者一个命名字体的字符串。默认为 Helvetica</span></span><br><span class="line"><span class="comment">// 在iOS中，不能给这个属性分配一个UIFont对象。</span></span><br><span class="line"><span class="comment">// 该属性是CTFontRef、CGFontRef或NSFont的实例，则该属性的字体大小将被忽略</span></span><br><span class="line"><span class="comment">// 当 textLayer.string 不是 NSAttributedString 时使用</span></span><br><span class="line">textLayer.font = <span class="type">CGFont</span>(fontName)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置字体属性的大小，默认值为：36.0</span></span><br><span class="line"><span class="comment">// 当 textLayer.string 不是 NSAttributedString 时使用</span></span><br><span class="line">textLayer.fontSize = font.pointSize</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置字体的颜色，默认值不透明白色</span></span><br><span class="line"><span class="comment">// 当 textLayer.string 不是 NSAttributedString 时使用</span></span><br><span class="line">textLayer.foregroundColor = <span class="type">UIColor</span>.orange.cgColor</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 是否允许对用于文本呈现的图形上下文进行亚像素量化</span></span><br><span class="line"><span class="comment">//        textLayer.allowsFontSubpixelQuantization = true</span></span><br><span class="line"><span class="comment">// 文本是否换行来适应边界，默认值false</span></span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 文本如何水平对齐，默认值 natural</span></span><br><span class="line">textLayer.alignmentMode = .center</span><br><span class="line"><span class="comment">// 如何截断文本以适应边界，默认值.none</span></span><br><span class="line"><span class="comment">// .none .start .middle .end</span></span><br><span class="line">textLayer.truncationMode = .end</span><br><span class="line">view.layer.addSublayer(textLayer)</span><br></pre></td></tr></table></figure>

<p>2、绘制富文本</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textLayer = <span class="type">CATextLayer</span>()</span><br><span class="line">textLayer.backgroundColor = <span class="type">UIColor</span>.gray.withAlphaComponent(<span class="number">0.2</span>).cgColor</span><br><span class="line">textLayer.frame = <span class="type">CGRect</span>(x: <span class="number">25</span>, y: <span class="number">200</span>, width: <span class="number">200</span>, height: <span class="number">120</span>)</span><br><span class="line">    </span><br><span class="line">textLayer.isWrapped = <span class="literal">true</span></span><br><span class="line">textLayer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">textLayer.alignmentMode = .justified</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"在渲染文本时，CATextLayer禁用亚像素反锯齿。当文本在栅格化的同时被合成到现有的不透明背景中时，只能使用亚像素反锯齿来绘制文本。"</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="type">NSMutableAttributedString</span>(string: text)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> font = <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> fontName = font.fontName <span class="keyword">as</span> <span class="type">CFString</span></span><br><span class="line"><span class="keyword">let</span> fontSize = font.pointSize</span><br><span class="line"><span class="keyword">let</span> fontRef = <span class="type">CTFontCreateWithName</span>(fontName, fontSize, <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> attri: [<span class="type">CFString</span> : <span class="type">Any</span>] = [kCTForegroundColorAttributeName: <span class="type">UIColor</span>.black.cgColor,</span><br><span class="line">             kCTFontAttributeName: fontRef]</span><br><span class="line">string.setAttributes(attri <span class="keyword">as</span> [<span class="type">NSAttributedString</span>.<span class="type">Key</span> : <span class="type">Any</span>], range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: text.<span class="built_in">count</span>))</span><br><span class="line">    </span><br><span class="line">attri = [kCTForegroundColorAttributeName: <span class="type">UIColor</span>.red.cgColor,</span><br><span class="line">         kCTUnderlineStyleAttributeName: <span class="type">NSNumber</span>(value: <span class="type">CTUnderlineStyle</span>.single.rawValue),</span><br><span class="line">         kCTFontAttributeName:fontRef]</span><br><span class="line">string.setAttributes(attri <span class="keyword">as</span> [<span class="type">NSAttributedString</span>.<span class="type">Key</span> : <span class="type">Any</span>], range: <span class="type">NSRange</span>(location: <span class="number">5</span>, length: <span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line">textLayer.string = string</span><br><span class="line">view.layer.addSublayer(textLayer)</span><br></pre></td></tr></table></figure>

<h2 id="使用CALayer的技巧提示"><a href="#使用CALayer的技巧提示" class="headerlink" title="使用CALayer的技巧提示"></a>使用<code>CALayer</code>的技巧提示</h2><p>1、尽可能使用 <code>Opaque Layers</code>，将 <code>layer.isOpaque = true</code> 可以让 <code>Core Animation</code> 知道它不需要为图层维护一个alpha通道。</p>
<p>2、对<code>CAShapeLayer</code>对象使用更简单的路径</p>
<p>3、为相同的layer显式设置contents</p>
<p>4、始终将 <code>CALayer</code> 的 Size 设置为整数值</p>
<p>5、根据需要使用异步层渲染，<code>layer.drawsAsynchronously = true</code></p>
<p>6、给 <code>CALayer</code> 添加阴影时指定阴影路径<code>shadowPath</code></p>
<p>具体解释可以查看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html#//apple_ref/doc/uid/TP40004514-CH9-SW8" target="_blank" rel="noopener">Improving Animation Performance</a></p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html" target="_blank" rel="noopener">Apple Core Animation</a></p>
<p><a href="https://zsisme.gitbooks.io/ios-/content/chapter4/group-opacity.html" target="_blank" rel="noopener">ios核心动画高级技巧 gitbooks</a></p>
<p><a href="https://www.jianshu.com/p/600668b17a69" target="_blank" rel="noopener">CAGradientLayer 渐变色</a></p>
<p><a href="https://juejin.im/post/6844903455857836039#heading-5" target="_blank" rel="noopener">CALayer的Specialized Layers</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/">http://yoursite.com/2020/09/09/CALayer%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Core-Animation/">Core Animation</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/09/Core-Animation%E8%A7%A3%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>Core Animation解析</span></a></div><div class="next-post pull-right"><a href="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/"><span>Core Graphics绘图(二)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>