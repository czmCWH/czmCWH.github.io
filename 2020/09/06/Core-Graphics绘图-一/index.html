<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Core Graphics绘图(一)"><meta name="keywords" content="iOS,Core Graphics"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>Core Graphics绘图(一) | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念理解"><span class="toc-number">1.</span> <span class="toc-text">基本概念理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphics-Context-图形上下文"><span class="toc-number">1.1.</span> <span class="toc-text">Graphics Context(图形上下文)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz-2D不透明数据类型"><span class="toc-number">1.2.</span> <span class="toc-text">Quartz 2D不透明数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphics-States-图形状态"><span class="toc-number">1.3.</span> <span class="toc-text">Graphics States(图形状态)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz-2D坐标系"><span class="toc-number">1.4.</span> <span class="toc-text">Quartz 2D坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz-2D的内存管理"><span class="toc-number">1.5.</span> <span class="toc-text">Quartz 2D的内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path-路径"><span class="toc-number">2.</span> <span class="toc-text">Path(路径)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路径的绘制"><span class="toc-number">2.1.</span> <span class="toc-text">路径的绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建路径"><span class="toc-number">2.2.</span> <span class="toc-text">创建路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描边路径"><span class="toc-number">2.3.</span> <span class="toc-text">描边路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#填充路径"><span class="toc-number">2.4.</span> <span class="toc-text">填充路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anti-Aliasing-抗锯齿渲染"><span class="toc-number">3.</span> <span class="toc-text">Anti-Aliasing(抗锯齿渲染)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#混合模式-Blend-Modes"><span class="toc-number">4.</span> <span class="toc-text">混合模式(Blend Modes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#裁剪路径"><span class="toc-number">5.</span> <span class="toc-text">裁剪路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">6.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">29</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Core Graphics绘图(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Graphics-Animation/">Graphics &amp; Animation</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a href="https://developer.apple.com/documentation/coregraphics" target="_blank" rel="noopener">Core Graphics</a>，也称为 <code>Quartz 2D</code>，是可用于iOS，tvOS和macOS应用程序开发的高级二维绘图引擎。只要有可能，Quartz 2D就会充分利用图形硬件(Graphics hardware)的能力。</p>
<ul>
<li><p><code>Core Graphics</code> 是基于 <code>Quartz advanced drawing engine</code>(Quartz高级绘图引擎)，它提供了低层次的(low-level)、轻量级的2D渲染(lightweight 2D rendering )，具有无与伦比的输出保真度。</p>
</li>
<li><p><code>Quartz 2D</code> 与分辨率和设备无关，它充分利用了图形硬件的能力。</p>
</li>
</ul>
<a id="more"></a>

<p>我们可以使用 <code>Core Graphics</code> 框架来处理：</p>
<ul>
<li>路径(创建、绘制、裁剪)</li>
<li>模式(Patterns)</li>
<li>抗锯齿渲染(anti-aliased Rendering)</li>
<li>变换(Transforms)</li>
<li>颜色管理(Color and Color Spaces)</li>
<li>离屏渲染(Offscreen Rendering)</li>
<li>渐变和阴影</li>
<li>透明层(transparency layers)</li>
<li>图像数据管理</li>
<li>创建图像和图像蒙板(Bitmap Images and Image Masks)</li>
<li>创建PDF文档、显示和解析等功能</li>
</ul>
<p>在iOS中，<code>Quartz 2D</code> 可以与所有可用的图形和动画技术(例如 <code>Core Animation</code>，<code>OpenGL ES</code> 和 <code>UIKit</code>)一起工作，来完成复杂的功能。</p>
<p>在Mac OS X中，Quartz 2D可以与所有其他图形和成像技术一起工作——<code>Core Image</code>、<code>Core Video</code>、<code>OpenGL</code>和<code>QuickTime</code>。</p>
<h2 id="基本概念理解"><a href="#基本概念理解" class="headerlink" title="基本概念理解"></a>基本概念理解</h2><h3 id="Graphics-Context-图形上下文"><a href="#Graphics-Context-图形上下文" class="headerlink" title="Graphics Context(图形上下文)"></a>Graphics Context(图形上下文)</h3><p><code>Graphics Context</code> 表示绘图的目的地(Drawing Destinations)，其目的地可以是应用程序中的窗口、位图图像、PDF文档、打印机等。</p>
<p><code>Graphics Context</code> 包含绘图所需参数 和 绘图系统执行任何后续绘图命令所需的所有设备特定信息。他定义了基本的绘图属性，例如绘图时使用的颜色、裁剪区域、线宽和样式信息、字体信息、组合选项，以及其他一些属性。<code>Quartz</code> 中的所有对象都绘制到图形上下文或包含在图形上下文中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGContext</span> <span class="built_in">CGContextRef</span>;</span><br></pre></td></tr></table></figure>

<p><code>Graphics Context</code> 在代码中由数据类型<code>CGContextRef</code> 表示，这是一种不透明的数据类型(opaque data type)。</p>
<blockquote>
<p>开发者们利用typedef声明一个类型，把它叫做不透明类型，希望其他人别去把它重新转化回对应的那个标准C类型。</p>
</blockquote>
<p>当使用Quartz绘制时，所有不同类型设备的特征都包含在您使用的特定类型的图形上下文中。我们只需向相同序列的Quartz绘图例程提供不同的图形上下文，就可以将相同的图像绘制到不同的设备上，如下图是Quartz的绘图目标：</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15978880104065.jpg" class="" title="This is an example image">

<p>可以通过 Quartz上下文创建函数、Mac OS X框架、iOS中的<code>UIKit</code>框架中的高级函数来获得图形上下文。</p>
<ul>
<li>在iOS中通过UIKit框架提供的高级函数来获得图形上下文</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQuartzView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在调用自定义drawRect:方法之前，UIView会自动配置它的绘图环境，并给当前绘图环境创建一个图形上下文</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取图形上下文的引用，注意不能建立对图形上下文的强引用，因为它可能在调用draw方式时被更改</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建PDF图形上下文</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>?(consumer: <span class="type">CGDataConsumer</span>, mediaBox: <span class="type">UnsafePointer</span>&lt;<span class="type">CGRect</span>&gt;?, <span class="number">_</span> auxiliaryInfo: <span class="type">CFDictionary?</span>)</span><br><span class="line">    <span class="keyword">init</span>?(<span class="number">_</span> url: <span class="type">CFURL</span>, mediaBox: <span class="type">UnsafePointer</span>&lt;<span class="type">CGRect</span>&gt;?, <span class="number">_</span> auxiliaryInfo: <span class="type">CFDictionary?</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建位图(Bitmap)图形上下文</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">CGBitmapContextReleaseDataCallback</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutableRawPointer?</span>, <span class="type">UnsafeMutableRawPointer?</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>?(data: <span class="type">UnsafeMutableRawPointer?</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>, bitsPerComponent: <span class="type">Int</span>, bytesPerRow: <span class="type">Int</span>, space: <span class="type">CGColorSpace</span>, bitmapInfo: <span class="type">UInt32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quartz-2D不透明数据类型"><a href="#Quartz-2D不透明数据类型" class="headerlink" title="Quartz 2D不透明数据类型"></a>Quartz 2D不透明数据类型</h3><p>除了图形上下文之外，Quartz 2D API还定义了各种不透明的数据类型。因为其数据类型属于 Core Graphics 框架，所有命名时都使用CG前缀。Quartz 2D从应用程序操作的不透明数据类型创建对象，以实现特定的绘图输出。</p>
<p>Quartz 2D中可用的不透明数据类型有：<code>CGPathRef</code>、<code>CGImageRef</code>、<code>CGLayerRef</code>、<code>CGPatternRef</code>、<code>CGShadingRef</code>、<code>CGGradientRef</code>、<code>CGFunctionRef</code>、<code>CGColorRef</code> 等等，具体可以参看<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_overview/dq_overview.html#//apple_ref/doc/uid/TP30001066-CH202-TPXREF101" target="_blank" rel="noopener">Quartz 2D Opaque Data Types</a></p>
<h3 id="Graphics-States-图形状态"><a href="#Graphics-States-图形状态" class="headerlink" title="Graphics States(图形状态)"></a>Graphics States(图形状态)</h3><p><code>Quartz</code> 根据当前 <code>Graphics States</code> 下的参数修改绘图操作的结果。</p>
<p>图形上下文包含一组图形状态，当Quartz创建图形上下文时，堆栈是空的。保存图形状态时，Quartz会将当前图形状态的副本推送到堆栈上。恢复图形状态时，Quartz会从堆栈顶部弹出图形状态。弹出的状态变为当前状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line"><span class="comment">// 将当前图形状态的副本推送到上下文的图形状态堆栈上        </span></span><br><span class="line">context?.saveGState()</span><br><span class="line"><span class="comment">// 将当前图形状态替换为堆栈顶部的图形状态，恢复以前保存的图形状态</span></span><br><span class="line">context?.restoreGState()</span><br></pre></td></tr></table></figure>

<p>与图形状态相关联的参数有：<code>CTM</code>、<code>Clipping area</code>、<code>Line: width, join, cap, dash, miter limit</code>、<code>flatness</code>、<code>Anti-aliasing setting</code>、<code>Color: fill and stroke settings</code>、<code>Alpha value (transparency)</code>、<code>Rendering intent</code>、<code>Color space: fill and stroke settings</code>、<code>Text: font, font size, character spacing, text drawing mode</code>、<code>Blend mode</code></p>
<h3 id="Quartz-2D坐标系"><a href="#Quartz-2D坐标系" class="headerlink" title="Quartz 2D坐标系"></a>Quartz 2D坐标系</h3><p>Quartz的默认坐标系如下图，原点位于页面的左下角</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15992002848748.jpg" class="" title="This is an example image">

<p>有些技术使用与Quartz不同的默认坐标系来设置图形上下文。如下方式中的上下文是与Quartz的默认坐标系相匹配：</p>
<ul>
<li>在iOS中，由UIView返回的一种绘图上下文。</li>
<li>在iOS中，通过调用<code>UIGraphicsBeginImageContextWithOptions</code>函数创建的绘图上下文。</li>
</ul>
<p>UIKit使用的默认坐标系统与Quartz使用的坐标系统不同。UIView对象修改了Quartz图形上下文的CTM，通过将原点转换到视图的左上角，并通过将y轴乘以-1来翻转y轴来匹配UIKit约定。</p>
<h3 id="Quartz-2D的内存管理"><a href="#Quartz-2D的内存管理" class="headerlink" title="Quartz 2D的内存管理"></a>Quartz 2D的内存管理</h3><p>Quartz使用Core Foundation内存管理模型，在该模型中对对象进行引用计数。</p>
<h2 id="Path-路径"><a href="#Path-路径" class="headerlink" title="Path(路径)"></a>Path(路径)</h2><p>路径定义一个或多个形状或子路径。子路径可以由直线、曲线或两者都组成。它可以打开或关闭。子路径可以是简单的形状，如直线、圆形、矩形或星形，也可以是更复杂的形状。Quartz支持基于路径的绘图。</p>
<p>路径创建和路径绘制是独立的任务。首先创建一个路径。当您想渲染一个路径时，您请求Quartz绘制它。可以选择描边路径、填充路径、或者同时描边和填充路径，还可以使用路径来创建剪切区域。</p>
<h3 id="路径的绘制"><a href="#路径的绘制" class="headerlink" title="路径的绘制"></a>路径的绘制</h3><p>给图形上下文构造一个路径时，是通过 <code>context?.beginPath()</code> 来给Quartz发送信号。接着设置路径的第一个点<code>context?.move(to: )</code> 或者 第一个形状，然后就可以在路径上添加直线，圆弧和曲线。在进行下面的操作时，需要注意一下几点：</p>
<ol>
<li>在开始创建新路径之前，调用函数<code>beginPath()</code></li>
<li>开始绘制线、弧和曲线时需要通过 <code>move(to:)</code>设置起始点，或者通过便利函数来隐式地完成此工作。</li>
<li>当调用 <code>closePath()</code> 关闭子路径时，会将子路径的起始点连接。后续的路径调用将开始新的子路径，即使您没有显式地设置新的起始点。</li>
<li>当画圆弧时，Quartz会在圆弧的当前点和起点之间绘制一条直线。</li>
<li>绘制椭圆和矩形时，Quartz将新的封闭子路径添加到该路径。</li>
<li>最后必须调用绘画功能来填充<code>fillPath()</code>或描边<code>strokePath()</code>路径，因为创建路径并不会绘制路径。</li>
</ol>
<ul>
<li>画点、线</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(to point: CGPoint)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addLine</span><span class="params">(to point: CGPoint)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979749575243.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123; &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="comment">// 在图形上下文中创建一个新的空路径</span></span><br><span class="line">    context?.beginPath()</span><br><span class="line">    <span class="comment">// 在指定的点开始一个新的子路径，该点将成为新子路径的起始点</span></span><br><span class="line">    context?.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">50</span>))</span><br><span class="line">    <span class="comment">// 从当前点追加一条直线线段到指定点</span></span><br><span class="line">    context?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">150</span>))</span><br><span class="line">    context?.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">80</span>, y: <span class="number">100</span>))</span><br><span class="line">    <span class="comment">// 关闭当前路径的子路径，连接路径的起始点</span></span><br><span class="line">    context?.closePath()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> points = [<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">100</span>), <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">50</span>)]</span><br><span class="line">    <span class="comment">// 将已连接的直线段添加到当前路径</span></span><br><span class="line">    context?.addLines(between: points)</span><br><span class="line"><span class="comment">//        context?.closePath()</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 描边路径，沿着当前路径绘制一条线</span></span><br><span class="line">    context?.strokePath()</span><br><span class="line"><span class="comment">// 填充路径，按照指定的填充规则在当前路径中绘制区域</span></span><br><span class="line"><span class="comment">//        context?.fillPath()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定圆心，半径和径向角度画圆弧</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addArc</span><span class="params">(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979751454375.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    <span class="comment">// 在当前路径上添加圆弧，clockwise: true表示顺时针方向画圆弧，false表示逆时针画弧。</span></span><br><span class="line">    context?.move(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>))</span><br><span class="line">    context?.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">50</span>, startAngle:<span class="number">0</span>, endAngle: -<span class="type">CGFloat</span>.pi / <span class="number">2</span>, clockwise: <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 闭合路径</span></span><br><span class="line">    context?.closePath()</span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>画正圆</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979752240524.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">50</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据半径和两条切线画圆弧</li>
</ul>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979805534141.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数常用于绘制圆角矩形的角</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addArc</span><span class="params">(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979754392859.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    <span class="comment">// 设置起点</span></span><br><span class="line">    context?.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">100</span>))</span><br><span class="line">    <span class="comment">// 设置半价</span></span><br><span class="line">    <span class="keyword">let</span> radius: <span class="type">CGFloat</span> = <span class="number">100</span></span><br><span class="line">    <span class="comment">// 绘制左上角</span></span><br><span class="line">    context?.addArc(tangent1End: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), tangent2End: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">0</span>), radius: radius)</span><br><span class="line">    <span class="comment">// 绘制右上角</span></span><br><span class="line">    context?.addArc(tangent1End: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">0</span>), tangent2End: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">100</span>), radius: radius)</span><br><span class="line">    <span class="comment">// 绘制右下角</span></span><br><span class="line">    context?.addArc(tangent1End: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">200</span>), tangent2End: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">200</span>), radius: radius)</span><br><span class="line">    <span class="comment">// 绘制左下角</span></span><br><span class="line">    context?.addArc(tangent1End: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">200</span>), tangent2End: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">100</span>), radius: radius)</span><br><span class="line">    context?.closePath()</span><br><span class="line"></span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三次贝塞尔曲线</li>
</ul>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979761838554.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addCurve</span><span class="params">(to end: CGPoint, control1: CGPoint, control2: CGPoint)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979755509666.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">100</span>))</span><br><span class="line">    <span class="comment">// 使用指定的端点和控制点，向当前路径添加三次贝塞尔曲线</span></span><br><span class="line">    <span class="comment">// 该方法构造一条曲线，从路径的当前点开始，到指定的端点结束，曲率由两个控制点定义</span></span><br><span class="line">    context?.addCurve(to: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">100</span>), control1: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>), control2: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">150</span>))</span><br><span class="line">    context?.closePath()</span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二次贝塞尔曲线</li>
</ul>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979761655201.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addQuadCurve</span><span class="params">(to end: CGPoint, control: CGPoint)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979756605954.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">100</span>))</span><br><span class="line">    <span class="comment">// 使用指定的端点和控制点，向当前路径添加二次贝塞尔曲线</span></span><br><span class="line">    context?.addQuadCurve(to: <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">100</span>), control: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">0</span>))</span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>画矩形、矩形的内切椭圆</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addRect</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addEllipse</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></span><br></pre></td></tr></table></figure>

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979758198088.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    <span class="comment">// 将矩形路径添加到当前路径</span></span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向当前路径添加一组矩形路径</span></span><br><span class="line">    <span class="keyword">let</span> rects = [<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">50</span>, width: <span class="number">50</span>, height: <span class="number">50</span>), <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">50</span>), <span class="type">CGRect</span>(x: <span class="number">150</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>), <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">150</span>, width: <span class="number">50</span>, height: <span class="number">50</span>)]</span><br><span class="line">    context?.addRects(rects)</span><br><span class="line">    context?.closePath()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加矩形的内切圆</span></span><br><span class="line">    context?.addEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">150</span>, height: <span class="number">100</span>))</span><br><span class="line">    context?.closePath()</span><br><span class="line">    </span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h3><p>如上操作在图形上下文中绘制完路径后，它会从图形上下文中清除。当绘制复杂的场景时，你想重复的使用路径，这就需要Quartz提供的 <code>CGPathRef</code> 和 <code>CGMutablePathRef</code> 类型。通过 <code>CGMutablePath()</code> 创建可变的CGPath对象，并向其中添加直线，圆弧，曲线和矩形。path函数操作CGPath对象，而不是图形上下文。Quartz提供了一组CGPath函数，与 <code>CGContext</code> 的一些函数并行。</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15979904447396.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line">    path.move(to: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addArc(tangent1End: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">150</span>), tangent2End: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">150</span>), radius: <span class="number">50</span>)</span><br><span class="line">    path.closeSubpath()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.addPath(path)</span><br><span class="line">    <span class="comment">// 将图形上下文中的路径替换为路径的描边版本</span></span><br><span class="line">    context?.replacePathWithStrokedPath()</span><br><span class="line">    <span class="comment">// 描边路径</span></span><br><span class="line">    context?.strokePath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="描边路径"><a href="#描边路径" class="headerlink" title="描边路径"></a>描边路径</h3><ul>
<li>描边路径使用的参数：</li>
</ul>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15980009796135.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line">    path.move(to: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">150</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">150</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">150</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.addPath(path)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置描边时的线宽，默认值为1.0。路径两边为总宽度的一半。</span></span><br><span class="line">    context?.setLineWidth(<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 线条连接的样式，默认值为 .miter</span></span><br><span class="line">    <span class="comment">// .miter(斜接，类似相框一样)  .round(一个半圆弧连接)  .bevel(斜角，末端为方形的连接)</span></span><br><span class="line">    <span class="comment">//        context?.setLineJoin(CGLineJoin.miter)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置线的端点的样式，默认值为.butt</span></span><br><span class="line">    <span class="comment">// .butt(末端为方形) .round(末端为圆弧)  .square(末端为方形，线长会扩展到路径端点之外的距离等于线宽的一半)</span></span><br><span class="line">    context?.setLineCap(<span class="type">CGLineCap</span>.butt)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果线的连接方式为：CGLineJoin.miter, 它的值决定是否应使用.bevel而不是.miter连接线。</span></span><br><span class="line">    <span class="comment">// 如果 斜接的长度除以线宽 大于 MiterLimit，则线的连接方式为：.bevel</span></span><br><span class="line">    <span class="comment">//        context?.setMiterLimit(5)</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置绘制虚线的模式。注意设置 setLineCap 对虚线的影响</span></span><br><span class="line">    <span class="comment">// phase：指绘制前按照 lengths 模式跳过的距离，开始绘制</span></span><br><span class="line">    <span class="comment">// lengths：表示虚线如何进行虚实交替绘制。即按照lengths数组的元素长度依次循环绘制线段，并且每个线段虚实交替</span></span><br><span class="line">    context?.setLineDash(phase: <span class="number">0</span>, lengths: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置图形上下文的描边颜色空间</span></span><br><span class="line">    context?.setStrokeColorSpace(<span class="type">CGColorSpaceCreateDeviceRGB</span>())</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置描边颜色</span></span><br><span class="line">    context?.setStrokeColor(<span class="type">UIColor</span>.yellow.cgColor)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 描边当前路径</span></span><br><span class="line">    context?.strokePath()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 指定图形上下文中的描边模式</span></span><br><span class="line">    <span class="comment">//context?.setStrokePattern(pattern: CGPattern, colorComponents: UnsafePointer&lt;CGFloat&gt;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>描边路径的方式，包括一些便利功能用于绘制矩形或椭圆形：<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15980009005766.jpg" class="" title="This is an example image">

</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line">    path.move(to: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">150</span>, y: <span class="number">50</span>))</span><br><span class="line">    path.addLine(to: <span class="type">CGPoint</span>(x: <span class="number">75</span>, y: <span class="number">150</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.addPath(path)</span><br><span class="line">    context?.setLineWidth(<span class="number">2</span>)</span><br><span class="line">    context?.setStrokeColor(<span class="type">UIColor</span>.black.cgColor)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 描边当前路径</span></span><br><span class="line">    context?.strokePath()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 以指定模式描画当前路径，取值有：.fill .eoFill .stroke .fillStroke .eoFillStroke</span></span><br><span class="line">    <span class="comment">//context?.drawPath(using: CGPathDrawingMode.fill)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描边指定矩形</span></span><br><span class="line">    context?.stroke(<span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定的线宽描边指定的矩形</span></span><br><span class="line">    context?.stroke(<span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">100</span>, width: <span class="number">50</span>, height: <span class="number">50</span>), width: <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描边指定矩形内的椭圆</span></span><br><span class="line">    context?.strokeEllipse(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">100</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描边指定的线条</span></span><br><span class="line">    context?.strokeLineSegments(between: [<span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">0</span>), <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">200</span>)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充路径"><a href="#填充路径" class="headerlink" title="填充路径"></a>填充路径</h3><p>当填充当前路径时，<code>Quartz</code>把路径中包含的子路径都被闭合了，然后它使用这些封闭的子路径并计算要填充的像素。Quartz有两种计算填充面积的方法：</p>
<p>1、 简单的路径具有明确定义的区域，例如：矩形和椭圆</p>
<p>2、 路径由重叠的部分组成，或者如果路径包含多个子路径。则有两个规则用于确定填充区域：</p>
<ul>
<li>默认的填充规则，称为 <a href="https://www.cs.rit.edu/~icss571/filling/alt_parity.html" target="_blank" rel="noopener">nonzero winding number rule</a> (非零环绕数原则)。如果要确定是否应该绘制特定的点，则从该点开始向绘图的边界之外画一条线。从0开始计数，当路径段从左到右穿过这条线时，将计数加1，从右往左则减1。如果最后结果为0，则不绘制该点。否则渲染该点。绘制路径段的方向会影响结果。</li>
<li>奇偶规则(<code>even-odd rule</code>)，要确定是否应该绘制特定的点，可以从该点开始向绘图的边界之外画一条线，计算这条线穿过的路径段的数量。如果路径段的总数是奇数，则绘制点，否则则不绘制点。</li>
</ul>
<p>具体理解可以参考<a href="https://www.jianshu.com/p/5cf8048b083b" target="_blank" rel="noopener">iOS 绘图中的 FillMode 填充模式</a> 中所提供示意图：</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15990125104213.jpg" class="" title="Even-Odd Rule">

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15990125223934.jpg" class="" title="Nonzero Winding Number Rule">


<p>如下是 Apple 的官方配图：</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15981647629002.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> outPath = <span class="type">CGMutablePath</span>()</span><br><span class="line">    <span class="comment">// 顺时针方向绘制圆弧</span></span><br><span class="line">    outPath.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">100</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> inPath = <span class="type">CGMutablePath</span>()</span><br><span class="line">    <span class="comment">// 逆时针方向绘制圆弧</span></span><br><span class="line">    inPath.addArc(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">50</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> basePath = <span class="type">CGMutablePath</span>()</span><br><span class="line">    basePath.addPath(outPath)</span><br><span class="line">    basePath.addPath(inPath)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.addPath(basePath)</span><br><span class="line">    <span class="comment">// 设置填充路径的颜色</span></span><br><span class="line">    context?.setFillColor(<span class="type">UIColor</span>.yellow.cgColor)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等价于 context?.fillPath(using: .winding)</span></span><br><span class="line">    <span class="comment">//        context?.fillPath()</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 按照指定的填充规则在当前路径中绘制区域。如果当前路径包含任何未关闭的子路径，则此方法将把每个未关闭的子路径视为以使用 closePath()方法关闭，并按照指定的规则来确定要填充的区域进行填充。填充路径后，此方法清除上下文的当前路径。</span></span><br><span class="line"><span class="comment">     * .winding，将会采用用nonzero winding number rule方式填充</span></span><br><span class="line"><span class="comment">     * .evenOdd，将会采用even-odd rule方式填充绘制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context?.fillPath(using: .evenOdd)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 只填充指定矩形的区域，不会填充路径</span></span><br><span class="line">    <span class="comment">//context?.fill(CGRect(x: 100, y: 100, width: 100, height: 50))</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 只填充指定矩形内的椭圆</span></span><br><span class="line">    <span class="comment">//context?.fillEllipse(in: CGRect(x: 100, y: 100, width: 100, height: 50))</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 根据相应的模式绘制当前路径</span></span><br><span class="line"><span class="comment">     * .fill 等价于 context?.fillPath(using: .winding)</span></span><br><span class="line"><span class="comment">     * .eofill 使用 even-odd rule 规则填充路径</span></span><br><span class="line"><span class="comment">     * .stroke 沿着路径渲染一条线</span></span><br><span class="line"><span class="comment">     * .fillStroke 首先使用nonzero winding number rule填充，然后描边</span></span><br><span class="line"><span class="comment">     * .eoFillStroke 首even-odd rul填充，然后描边路径。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//context?.drawPath(using: .eoFillStroke)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Anti-Aliasing-抗锯齿渲染"><a href="#Anti-Aliasing-抗锯齿渲染" class="headerlink" title="Anti-Aliasing(抗锯齿渲染)"></a>Anti-Aliasing(抗锯齿渲染)</h2><p><code>Anti-Aliasing</code> 是指在绘制文本或形状时，人为地纠正位图图像中的锯齿(或锯齿)边缘的过程。</p>
<p>当图形分辨率低于眼睛分辨率时，就会出现锯齿边缘。<code>Quartz</code> 对围绕形状轮廓的像素使用了不同的颜色，通过这种方式混合颜色，形状看起来很平滑。</p>
<p><code>Bitmap</code> 和 <code>UIKit</code> 提供的 <code>Graphics Contexts</code> 都支持 <code>anti-aliasing</code>。</p>
<p><code>setShouldAntialias</code> 是图形状态参数；<code>setallowsatialiasing</code> 不是图形状态参数。如下图所示锯齿图和反锯齿图的比较：</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/IMG_6705.jpg" class="" title="This is an example image">

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/IMG_6706.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scaleT = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.5</span>, y: <span class="number">1.5</span>)</span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">CGPath</span>(roundedRect: <span class="type">CGRect</span>(x: <span class="number">25</span>, y: <span class="number">25</span>, width: <span class="number">100</span>, height: <span class="number">100</span>), cornerWidth: <span class="number">20</span>, cornerHeight: <span class="number">30</span>, transform: &amp;scaleT)</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    context?.addPath(path)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置图形上下文的反锯齿打开或关闭</span></span><br><span class="line">    <span class="comment">// 默认情况下，当创建 window or bitmap context 时，值为true；其它类型的上下文值为 false</span></span><br><span class="line">    context?.setShouldAntialias(<span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 是否允许图形上下文的反锯齿</span></span><br><span class="line">    <span class="comment">// 如果 allowsAntialiasing 和 shouldAntialias 值都为 true，则Core Graphics 将对 图形上下文执行反锯齿处理</span></span><br><span class="line">    context?.setAllowsAntialiasing(<span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">    context?.setStrokeColor(<span class="type">UIColor</span>.black.cgColor)</span><br><span class="line">    context?.setFillColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">    context?.drawPath(using: .fillStroke)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="混合模式-Blend-Modes"><a href="#混合模式-Blend-Modes" class="headerlink" title="混合模式(Blend Modes)"></a>混合模式(Blend Modes)</h2><p>混合模式指定 Quartz 如何在背景上着色，其实就是前景图和背景图怎么混合叠加绘制。混合模式影响着绘制。</p>
<p>Quartz默认使用普通的混合模式，该模式使用以下公式将前景色和背景色组合。当颜色的 alpha = 1.0 时，通过下面公式，我们可以得出对于不透明的颜色，当使用普通混合模式进行绘制时，任何在背景之上绘制的内容完全遮挡背景上的绘图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; (alpha * foreground) + (1 - alpha) * background</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>func setBlendMode(_:)</code> 函数传递混合模式常量，实现各种效果；</p>
<p>混合模式是图形状态的一部分。如果在更改混合模式之前使用了函数 <code>context?.saveGState()</code>，那么调用函数 <code>context?.restoreGState()</code> 会将混合模式重置为普通模式；</p>
<p>如下代码，可以参照 Apple Setting Blend Modes 文档查看混合模式效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">    <span class="comment">// 绘制背景矩形</span></span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">207</span> / <span class="number">255.0</span>, green: <span class="number">194</span> / <span class="number">255.0</span>, blue: <span class="number">141</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">50</span>, width: <span class="number">200</span>, height: <span class="number">25</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">201</span> / <span class="number">255.0</span>, green: <span class="number">202</span> / <span class="number">255.0</span>, blue: <span class="number">204</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">75</span>, width: <span class="number">200</span>, height: <span class="number">25</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">227</span> / <span class="number">255.0</span>, green: <span class="number">106</span> / <span class="number">255.0</span>, blue: <span class="number">161</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">25</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">165</span> / <span class="number">255.0</span>, green: <span class="number">219</span> / <span class="number">255.0</span>, blue: <span class="number">102</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">125</span>, width: <span class="number">200</span>, height: <span class="number">25</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设置混合模式</span></span><br><span class="line">    context?.setBlendMode(.normal)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 绘制背景矩形</span></span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">168</span> / <span class="number">255.0</span>, green: <span class="number">127</span> / <span class="number">255.0</span>, blue: <span class="number">180</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">0</span>, width: <span class="number">25</span>, height: <span class="number">200</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">234</span> / <span class="number">255.0</span>, green: <span class="number">153</span> / <span class="number">255.0</span>, blue: <span class="number">58</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">75</span>, y: <span class="number">0</span>, width: <span class="number">25</span>, height: <span class="number">200</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">62</span> / <span class="number">255.0</span>, green: <span class="number">148</span> / <span class="number">255.0</span>, blue: <span class="number">218</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">0</span>, width: <span class="number">25</span>, height: <span class="number">200</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">    context?.beginPath()</span><br><span class="line">    context?.setFillColor(red: <span class="number">165</span> / <span class="number">255.0</span>, green: <span class="number">219</span> / <span class="number">255.0</span>, blue: <span class="number">102</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    context?.addRect(<span class="type">CGRect</span>(x: <span class="number">125</span>, y: <span class="number">0</span>, width: <span class="number">25</span>, height: <span class="number">200</span>))</span><br><span class="line">    context?.fillPath()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIJEFG" target="_blank" rel="noopener">Using Blend Modes With Images</a><br><a href="https://onevcat.com/2013/04/using-blending-in-ios/" target="_blank" rel="noopener">iOS中使用blend改变图片颜色</a></p>
<h2 id="裁剪路径"><a href="#裁剪路径" class="headerlink" title="裁剪路径"></a>裁剪路径</h2><p>剪切区域是从一个用作遮罩的路径创建的，它允许您屏蔽页面中不想绘制的部分。Quartz只在裁剪区域内呈现绘制，出现在剪切区域的闭合子路径内的绘制是可见的，发生在剪切区域的封闭子路径之外的绘图是不可见的。</p>
<p>最开始创建图形上下文时，剪切区域包括上下文的所有可绘制区域。您可以通过设置当前路径，然后使用剪切函数而不是绘图函数来更改剪切区域。</p>
<p>裁剪区域是图形状态的一部分。若要将剪辑区域恢复到以前的状态，可以在剪辑之前保存图形状态<code>context?.saveGState()</code>，并在完成剪辑绘制后恢复图形状态<code>context?.restoreGState()</code>。</p>
<p>1、如下给图形上下文设置红色到黄色渐变的背景色，通过一个圆环路径进行裁剪：</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15992051690612.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(<span class="number">_</span> rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 创建一个矩形的裁剪区域</span></span><br><span class="line">     context?.beginPath()</span><br><span class="line">     <span class="comment">// 绘制一个同心圆</span></span><br><span class="line">    <span class="keyword">let</span> arcCenter = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">    context?.addArc(center: arcCenter, radius: <span class="number">80</span>, startAngle: <span class="type">CGFloat</span>(<span class="number">0</span>), endAngle: <span class="type">CGFloat</span>(<span class="type">Double</span>.pi*<span class="number">2</span>), clockwise: <span class="literal">false</span>)</span><br><span class="line">    context?.addArc(center: arcCenter, radius: <span class="number">40</span>, startAngle: <span class="type">CGFloat</span>(<span class="type">Double</span>.pi*<span class="number">2</span>), endAngle: <span class="type">CGFloat</span>(<span class="number">0</span>), clockwise: <span class="literal">true</span>)</span><br><span class="line">    context?.closePath()</span><br><span class="line">    <span class="comment">//context?.clip() 等价于 context?.clip(using: .winding)</span></span><br><span class="line">    <span class="comment">// 根据规则修改裁剪路径</span></span><br><span class="line">    context?.clip(using: .evenOdd)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 绘制渐变背景</span></span><br><span class="line">    <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpace</span>(name: <span class="type">CGColorSpace</span>.genericRGBLinear)</span><br><span class="line">    <span class="keyword">let</span> components: [<span class="type">CGFloat</span>] = [<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>,    <span class="comment">// start color 红色</span></span><br><span class="line">                                <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]    <span class="comment">// end color 蓝色</span></span><br><span class="line">    <span class="keyword">let</span> locations: [<span class="type">CGFloat</span>] = [<span class="number">0.3</span>, <span class="number">0.8</span>]</span><br><span class="line">    <span class="keyword">let</span> gradient = <span class="type">CGGradient</span>(colorSpace: colorSpace!, colorComponents: components, locations: locations, <span class="built_in">count</span>: <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> startPt = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> endPt = <span class="type">CGPoint</span>(x: rect.width, y: rect.height)</span><br><span class="line">    context?.drawLinearGradient(gradient!, start: startPt, end: endPt, options: .drawsBeforeStartLocation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、将剪切路径设置为 当前剪切路径 与 由指定矩形定义的区域 的交点</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15992067850751.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context?.beginPath()</span><br><span class="line"><span class="keyword">let</span> arcCenter = <span class="type">CGPoint</span>(x: rect.size.width / <span class="number">2.0</span>, y: rect.size.height / <span class="number">2.0</span>)</span><br><span class="line">context?.addArc(center: arcCenter, radius: <span class="number">50</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>, clockwise: <span class="literal">true</span>)</span><br><span class="line">context?.closePath()</span><br><span class="line"><span class="comment">// 设置绘制的路径为裁剪路径</span></span><br><span class="line">context?.clip()</span><br><span class="line"><span class="comment">// 将剪切路径设置为 当前剪切路径 与 由指定矩形定义的区域 的交点</span></span><br><span class="line">context?.clip(to: <span class="type">CGRect</span>(x: arcCenter.x, y: arcCenter.y, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>3、将mask映射到指定的矩形中，并使其与图形上下文的当前剪切区域相交。</p>
<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15992081582943.jpg" class="" title="This is an example image">

<img src="/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/15992079268404.jpg" class="" title="This is an example image">


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context?.beginPath()</span><br><span class="line">context?.addRect(rect)</span><br><span class="line">context?.closePath()</span><br><span class="line">context?.clip()</span><br><span class="line"><span class="comment">// 将遮罩映射到指定的矩形，并将其与图形上下文的当前剪切区域相交。</span></span><br><span class="line">context?.clip(to: <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>), mask: (<span class="type">UIImage</span>(named: <span class="string">"ear"</span>)?.cgImage!)!)</span><br></pre></td></tr></table></figure>

<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066" target="_blank" rel="noopener">Quartz 2D编程指南</a></p>
<p><a href="https://developer.apple.com/library/archive/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531" target="_blank" rel="noopener">Quartz2D for iOS Sample Code</a></p>
<p><a href="https://www.jianshu.com/p/76c3e47cc7da" target="_blank" rel="noopener">理解CGContextAddArcToPoint</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101" target="_blank" rel="noopener">Color and Color Spaces</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/csintro/csintro_intro/csintro_intro.html#//apple_ref/doc/uid/TP30001148-CH204-BBCHJACF" target="_blank" rel="noopener">Color Management Overview</a></p>
<p><a href="https://blog.csdn.net/Hello_Hwc/article/details/49422823" target="_blank" rel="noopener">iOS 2D绘图详解</a></p>
<p><a href="https://markmiao.com/2016/12/13/Quartz2D1/" target="_blank" rel="noopener">Quartz 2D（一）概念、图形上下文、路径</a></p>
<p><a href="https://mp.weixin.qq.com/s/8eLkz6iGykcrcgGHyRi9iA" target="_blank" rel="noopener">Core Graphics 学习（一）</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/">http://yoursite.com/2020/09/06/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%B8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/Core-Graphics/">Core Graphics</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/07/Core-Graphics%E7%BB%98%E5%9B%BE-%E4%BA%8C/"><i class="fa fa-chevron-left">  </i><span>Core Graphics绘图(二)</span></a></div><div class="next-post pull-right"><a href="/2020/06/26/iOS%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"><span>iOS环境变量配置</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>