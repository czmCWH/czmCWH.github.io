<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="XCTest"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>XCTest | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#XCTest-Framework"><span class="toc-number">1.</span> <span class="toc-text">XCTest Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XCTestCase"><span class="toc-number">1.1.</span> <span class="toc-text">XCTestCase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XCTest-Assertions"><span class="toc-number">1.2.</span> <span class="toc-text">XCTest Assertions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-Test-Navigator"><span class="toc-number">1.3.</span> <span class="toc-text">Xcode Test Navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Swift-编写测试"><span class="toc-number">1.4.</span> <span class="toc-text">使用 Swift 编写测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在-Xcode-中测试-App"><span class="toc-number">2.</span> <span class="toc-text">在 Xcode 中测试 App</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unit-Test"><span class="toc-number">2.1.</span> <span class="toc-text">Unit Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unit-test-for-performance"><span class="toc-number">2.1.1.</span> <span class="toc-text">Unit test for performance</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integration-Test"><span class="toc-number">2.2.</span> <span class="toc-text">Integration Test</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UI-Test"><span class="toc-number">2.3.</span> <span class="toc-text">UI Test</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-UI-Recording"><span class="toc-number">2.3.1.</span> <span class="toc-text">使用 UI Recording</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编写-UI-Tests"><span class="toc-number">2.3.2.</span> <span class="toc-text">编写 UI Tests</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UI-test-for-performance"><span class="toc-number">2.3.3.</span> <span class="toc-text">UI test for performance</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码覆盖范围"><span class="toc-number">3.</span> <span class="toc-text">代码覆盖范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试框架"><span class="toc-number">4.</span> <span class="toc-text">测试框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">5.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">XCTest</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Xcode/">Xcode</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><code>test</code>(测试) 是你编写的代码，它可以操练应用程序和库代码，并根据一组期望值得出通过或失败的结果。<code>test</code>可能会在执行某些操作后检查对象实例变量的状态，验证代码在受边界条件约束时是否抛出特定异常，等等。对于性能测量测试，参考标准可以是一组例程运行到完成的最长时间。</p>
<a id="more"></a>

<p>为项目的组件设计的测试是<code>test-driven development</code>(测试驱动开发)的基础，这是一种编写代码的风格，在编写要测试的代码之前先编写测试逻辑。这种开发风格允许你在实现代码之前为代码编写需求和边缘用例。编写测试后，你将开发算法以通过测试。代码通过测试后，你便有了基础，可以对代码进行改进，并确信下次运行测试时会识别出对预期行为的任何更改（这会导致产品中的错误）。</p>
<p>即使你不使用<code>test-driven development</code>，测试也可以帮助你在修改代码以增强功能时减少错误的引入。将测试添加到未考虑测试目的的项目中，可能需要重新设计或重构部分代码，以使其更易于测试。</p>
<h2 id="XCTest-Framework"><a href="#XCTest-Framework" class="headerlink" title="XCTest Framework"></a>XCTest Framework</h2><p><a href="https://developer.apple.com/documentation/xctest" target="_blank" rel="noopener">XCTest Framework</a> 为 <code>Xcode</code> 项目创建和运行 <code>Unit Tests</code>、<code>Performance Tests</code>、<code>UI Tests</code>。</p>
<h3 id="XCTestCase"><a href="#XCTestCase" class="headerlink" title="XCTestCase"></a>XCTestCase</h3><p><code>XCTestCase</code>是定义<code>test cases</code>(测试用例)，<code>test methods</code>(测试方法)和<code>performance tests</code>的主要类。</p>
<p>通过编写一个或多个 <code>test methods</code> 将测试添加到你的 <code>Xcode</code> 项目中，每个 <code>test methods</code> 都验证代码的特定方面。将相关的 <code>test methods</code> 分组为 <code>test cases</code>，每个<code>test cases</code>都是 <a href="https://developer.apple.com/documentation/xctest/xctestcase" target="_blank" rel="noopener">XCTestCase</a> 的子类。</p>
<p>将 <code>tests</code> 添加到项目：</p>
<ol>
<li>在测试目标内创建 <code>XCTestCase</code> 的新子类。</li>
<li>在<code>test case</code>中添加一种或多种<code>test methods</code>。</li>
<li>向每种测试方法添加一个或多个<code>test assertions</code>(测试断言)。</li>
</ol>
<ul>
<li><p><code>test methods</code> 是 <code>XCTestCase</code> 子类上的实例方法，没有参数和返回值，名称以<code>test</code>开头。<code>Xcode</code> 中的 <code>XCTest framework</code> 会自动检测。<code>test methods</code>的命名要能明确说明该方法测试的内容，例如：<code>testUserJSONFeedParsing()</code>等。</p>
</li>
<li><p><code>test case</code> 定义<code>test case</code>的名称要概括其中的测试，阐明测试的组织。例如：<code>TableValidationTests</code>、<code>NetworkReachabilityTests</code>或<code>JSONParsingTests</code>。</p>
</li>
<li><p><code>Tests assert</code> 用于在<code>test methods</code>执行期间声明某些条件，如果这些条件不满足，则记录测试失败(并附带有可选消息)，以确保你的代码行为符合预期。使用 <a href="https://developer.apple.com/documentation/xctest/boolean_assertions" target="_blank" rel="noopener">XCTAssert</a> 函数族检查布尔条件、nil或非nil值、期望值和抛出的错误。</p>
</li>
</ul>
<h3 id="XCTest-Assertions"><a href="#XCTest-Assertions" class="headerlink" title="XCTest Assertions"></a>XCTest Assertions</h3><p><code>test methods</code>使用<code>XCTest framework</code>提供的<code>assertions</code>(断言)来呈现<code>Xcode</code>显示的测试结果。所有<code>assertions</code>都具有类似的形式：要比较的项或逻辑表达式，失败结果格式字符串以及要插入格式字符串的参数。</p>
<p><code>test method</code>可以包含多个<code>assertions</code>。如果Xcode包含的任何断言报告失败，则Xcode会发出测试方法失败的信号。</p>
<p><code>Assertions</code>分为五类：</p>
<ol>
<li><p><code>Unconditional Fail</code>(无条件失败)，当仅到达特定的代码分支指示失败时，请使用此选项。此类别中唯一的断言是<a href="https://developer.apple.com/documentation/xctest/xctfail" target="_blank" rel="noopener">XCTFail</a>。</p>
</li>
<li><p><code>Equality Tests</code>，使用这些来断言两个项目之间的关系。例如，<code>XCTAssertEqual</code> 断言两个表达式具有相同的值，而 <code>XCTAssertEqualWithAccuracy</code> 断言两个表达式在一定精度范围内具有相同的值。这一类还包括对不等式的检验，例如 <code>XCTAssertNotEqual</code> 和 <code>XCTAssertNotEqual</code>。 </p>
</li>
<li><p><code>Boolean Tests</code>，使用这些来断言布尔表达式以某种方式计算，例如使用<code>XCTAssertTrue</code>或<code>XCTAssertFalse</code>。</p>
</li>
<li><p><code>Nil Tests</code>，使用这些来断言某项是否为nil，例如，使用<code>XCTAssertNil</code>或<code>XCTAssertNotNil</code>。</p>
</li>
<li><p><code>Exception Tests</code>，使用这些来断言评估表达式是否会生成异常。可以查找<code>XCTAssertThrows</code>引发的任何异常，也可以使用诸如<code>XCTAssertThrowsSpecific</code>的断言查找特定的异常。也可以断言相反，使用<code>XCTAssertNoThrow</code>之类的函数在计算表达式时不会引发异常。</p>
</li>
</ol>
<h3 id="Xcode-Test-Navigator"><a href="#Xcode-Test-Navigator" class="headerlink" title="Xcode Test Navigator"></a>Xcode Test Navigator</h3><p><code>Xcode</code> 的 <code>test navigator</code>(测试导航器) 和 <code>integration reports</code>(集成报告) 中使用了<code>test case</code>和<code>test methods</code>的名称来对测试进行分组和标识。</p>
<p>将<code>test target</code>添加到项目中会创建一个<code>test bundle</code>。<code>test navigator</code>对项目中所有<code>test bundle</code>的源代码组件进行布局，并在层次结构列表中显示<code>test classes</code>和<code>test methods</code>。</p>
<p>当你创建一个新项目时，默认情况下会为您创建一个<code>test target</code>和相关的<code>test bundle</code>，其名称是从你的项目名称派生的。</p>
<img src="/2020/05/20/XCTest/16213083232408.jpg" class="" title="This is an example image">

<h3 id="使用-Swift-编写测试"><a href="#使用-Swift-编写测试" class="headerlink" title="使用 Swift 编写测试"></a>使用 Swift 编写测试</h3><p><code>Swift</code>的<code>access control model</code>(访问控制模型)阻止外部实体访问在应用程序或框架中声明为<code>internal</code>的任何内容。默认情况下，为了能够从测试代码访问这些项目，需要将它们的访问级别至少提高到<code>public</code>，从而降低Swift的类型安全性的好处。</p>
<p><code>Xcode</code>提供了一个由两部分组成的解决方案：</p>
<ul>
<li>设置 <code>test builds</code> -&gt; <code>build setting</code> -&gt; <code>Enable Testability</code> -&gt; <code>Debug 设置为 YES</code>，Xcode在编译过程中会包含<code>-enable-testing</code>标志。这使得在已编译模块中声明的Swift实体有资格获得更高级别的访问权限。</li>
<li>将 <code>@testable</code> 属性添加到启用了测试功能的模块的<code>import</code>语句中时，可以激活该作用域中该模块的提升的访问权限。标记为<code>internal</code>或<code>public</code>的<code>Classes 和 class members</code>的行为就像标记为<code>open</code>的一样。其他标记为内部实体的实体就像被宣布为<code>public</code>实体一样。</li>
</ul>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import XCTest</span><br><span class="line">@testable import MySwiftApp</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@testable</code>仅提供对<code>internal</code>函数的访问；使用<code>@testable</code>时，<code>file-private</code>和<code>private</code>声明在其通常作用域之外不可见。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModel</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSome</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> CTest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> m = <span class="type">TestModel</span>()</span><br><span class="line">        m.doSome()</span><br><span class="line">        <span class="comment">// m.sayHello()    // 'sayHello' is inaccessible due to 'private' protection level</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-Xcode-中测试-App"><a href="#在-Xcode-中测试-App" class="headerlink" title="在 Xcode 中测试 App"></a>在 Xcode 中测试 App</h2><p>XCTest使您能够以不同的抽象级别编写测试。好的测试策略应结合多种测试类型，以最大程度地发挥每种测试的优势。</p>
<p>如下图所示，旨在实现测试的“金字塔”分布。包括大量快速，隔离良好的<code>unit tests</code>，以涵盖应用程序的逻辑；少量的<code>integration tests</code>，以证明较小的部分正确地连接在一起；<code>UI tests</code>来<code>assert</code>(断言)常见用例的正确行为。</p>
<img src="/2020/05/20/XCTest/16212167765570.jpg" class="" title="This is an example image">

<p><code>UI tests</code>是你的应用以您期望的方式为用户工作的最终指标，但是与其他类型的测试相比，它们需要更长的运行时间。在同一个<code>UI tests</code>中，可能有多种应用程序变量导致失败。测试金字塔平衡了显示用户可以完成任务的高保真测试，以及针对性强的测试，这些测试可以为你提供有关应用程序逻辑的正确性以及所做更改的影响的快速反馈。</p>
<h3 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h3><p>每个<code>unit test</code>都应该通过项目中的方法或函数<code>assert</code>单个路径的预期行为。要覆盖多个路径，请为每种情况编写一个<code>test</code>。例如，如果一个函数接收到一个可选参数，则可以编写一个参数为nil的<code>test</code>，以及一个参数为非nil的<code>test</code>。 确定代码中的边界情况和逻辑分支，并编写一个单元测试来覆盖这些情况的每种组合。</p>
<p><code>Unit Test</code>侧重于代码功能，创建<code>unit tests</code>时，请专注于测试与<code>Controller</code>交互的代码的最基本基础，即<code>Model</code>类和方法。</p>
<p><code>test method</code>应包含三个步骤，顺序如下所述：</p>
<p>1、<code>Arrange</code>(安排)，创建你正在执行的代码路径使用的任何对象或数据结构。将复杂的依赖项替换为易于配置的 <code>stubs</code>，以确保测试快速运行并具有确定性。采用面向协议的编程可确保应用程序中对象之间的关系足够灵活，从而可以用<code>stubs</code>替换实际实现。</p>
<p>2、<code>Act</code>(行为)，使用在<code>Arrange</code>阶段配置的参数和属性，调用要测试的方法或函数。</p>
<p>3、<code>Assert</code>(断言)，使用<code>XCTest framework</code>中的<code>Test Assertions</code>来比较你在 <code>Act</code> 阶段执行的代码的行为与对应该发生的期望。任何条件为假的断言都会导致测试失败。</p>
<p>关于<code>Unit Test</code>的使用，具体可以学习 <a href="https://github.com/kakaopensource/KakaJSON" target="_blank" rel="noopener">kakaopensource/KakaJSON</a>，CoderMJLee 写的第三方框架都会写很多测试用例。 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="meta">@testable</span> <span class="keyword">import</span> CTest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTestTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUpWithError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处放置设置代码。在调用类中的每个测试方法之前调用此方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tearDownWithError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 把清理代码放在这里。在调用类中的每个测试方法之后调用此方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 测试执行流程：对于每一个测试方法，都会分配一个类的新实例，并执行其实例 setup 方法。之后，它运行test method，然后运行实例 teardown 方法。此序列对类中的所有测试方法重复。</span></span><br><span class="line"><span class="comment">    * 当Xcode运行测试时，它会独立调用每个测试方法。因此，每种方法都必须准备并清理与主题API交互所需的任何辅助变量，结构和对象。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 这是一个功能测试用例的例子。</span></span><br><span class="line">        <span class="comment">// 使用XCTAssert和相关函数来验证测试是否产生正确的结果。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了处理调用异步执行方法和函数的测试组件，XCTest通过等待异步回调或超时完成，在测试方法中包含序列化异步执行的能力。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testAsyncExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 测试将在此处暂停，运行运行循环，直到达到超时或所有期望都达到为止。</span></span><br><span class="line">        <span class="keyword">self</span>.waitForExpectations(timeout: <span class="number">1</span>) &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 在此处编写异步代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性能测试采用你要评估的代码块并将其运行十次，以收集运行的平均执行时间和标准偏差。</span></span><br><span class="line">    <span class="comment">// 这些单独测量值的平均值形成测试运行的值，然后可以将其与基准进行比较以评估成功或失败。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPerformanceExample</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 这是一个性能测试用例的示例</span></span><br><span class="line">        <span class="keyword">self</span>.measure &#123;</span><br><span class="line">            <span class="comment">// 在此处放置你要测量时间的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Unit-test-for-performance"><a href="#Unit-test-for-performance" class="headerlink" title="Unit test for performance"></a>Unit test for performance</h4><p>编写<code>performance tests</code>，以收集有关在代码区域执行期间所花费的时间、所用内存、写入的数据的信息。</p>
<p><strong><code>XCTest</code>提供<code>API</code>来衡量基于时间的性能。</strong> <code>XCTest</code>会多次运行你的代码，以测量所请求的<code>metric</code>(指标)。可以为<code>metric</code>(指标)设置<code>baseline</code>(基线)期望值，如果测量值明显低于<code>baseline</code>，则<code>XCTest</code>会报告测试失败。</p>
<p>当第一次运行<code>performance tests</code>时，<code>XCTest</code>总是报告失败，因为<code>baseline</code>未知。一旦你接受了某个测量作为<code>baseline</code>，<code>XCTest</code>将评估和报告成功或失败，并为你提供查看测试结果的详细方法。</p>
<p>要测试代码占用的时间，请在测试方法内调用<code>measure(_:)</code>，然后在<code>block</code>参数中将应用的代码运行到<code>measure(_:)</code>。要使用其他指标（包括内存使用情况和写入磁盘的数据量）来衡量性能，请调用<code>measure(metrics:block:)</code>。</p>
<img src="/2020/05/20/XCTest/16213888767622.jpg" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testSomePerformanceOfMyFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> model = <span class="type">TestModel</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// @metrics 接收你需要测量性能类型的数组：XCTMemoryMetric、XCTCPUMetric</span></span><br><span class="line">        <span class="keyword">self</span>.measure(metrics: <span class="type">ModelTests</span>.defaultMetrics) &#123;</span><br><span class="line">            <span class="comment">// 在此处放置你要测量时间的代码</span></span><br><span class="line">            model.myFunc()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integration-Test"><a href="#Integration-Test" class="headerlink" title="Integration Test"></a>Integration Test</h3><p><code>Integration tests</code>看起来与<code>unit tests</code>非常相似，使用相同的API，并遵循相同的<code>Arrange-Act-Assert</code>模式。<code>unit test</code>和<code>integration test</code>的区别在于<code>scale</code>(规模)。 <code>unit test</code>只占应用逻辑的一小部分，而<code>integration test</code>检查的是更大的子系统或类和函数组合的行为。在<code>integration test</code>的<code>Arrange</code>步骤中，使用较少的<code>stub objects</code>(存根对象)来扩展正在测试的实际项目代码的范围。</p>
<p>与其尝试像<code>unit tests</code>一样尝试覆盖所有不同的条件或边界情况，不如使用<code>integration tests</code>来<code>assert</code>组件在重要情况下协同工作以实现应用程序目标。示例包括测试从控制器接收的值是否正确存储在模型中，以及由网络请求产生的错误是否传递到用户界面并由用户界面呈现。</p>
<h3 id="UI-Test"><a href="#UI-Test" class="headerlink" title="UI Test"></a>UI Test</h3><p><code>UI tests</code>使你能够查找应用程序的UI并与之交互，以验证<code>elements</code>的属性 和 状态。<code>UI tests</code>的重点是通过用户界面的流。</p>
<p><code>UI tests</code> 包括 <code>UI recording</code>，它使你能够生成以与你的 App 相同的方式执行应用程序UI的代码，并且可以扩展该代码以实现<code>UI tests</code>。这是快速开始编写 <code>UI tests</code> 的好方法。</p>
<p><code>Test reports</code>(测试报告) 得到了增强，可以提供有关<code>UI tests</code>的详细信息，包括测试失败时UI状态的快照。</p>
<p><code>UI tests</code> 基于两项核心技术：<code>XCTest framework</code> 和 <code>Accessibility</code>(辅助功能)。</p>
<ul>
<li><p><code>XCTest</code> 提供了与Xcode集成的UI测试功能框架。创建和使用<code>UI tests</code>扩展了你对 <code>XCTest</code> 和创建<code>unit tests</code>的了解。创建<code>UI test target</code>，并在项目中创建UI测试的类和方法。可以使用<code>XCTest assertions</code>来验证预期结果是否正确。还可以通过<code>Xcode Server</code>和<code>xcodebuild</code>进行持续集成。</p>
</li>
<li><p><code>Accessibility</code>是一项核心技术，可让残障用户获得与其他用户相同的iOS和macOS丰富体验。它包含有关UI的丰富语义数据集，用户可以使用这些语义数据来指导他们使用应用程序。<code>Accessibility</code>与<code>UIKit</code>和<code>AppKit</code>集成在一起，并具有API，可让你微调行为和对外公开的内容。<code>UI tests</code>使用该数据执行其功能。</p>
</li>
</ul>
<p>用源代码创建<code>UI tests</code>类似于创建<code>unit tests</code>，它仍作为<code>XCTestCase</code>子类上的方法进行组织。为应用创建了一个<code>UI test target</code>；然后Xcode为你创建一个默认的<code>UI test group</code>和实现文件，并在实现文件中提供示例测试方法模板。创建<code>UI test target</code>时，可以指定测试将要处理的应用程序。</p>
<p><code>UI tests</code> 的工作原理是：通过查询找到应用程序的UI对象，合成事件并将其发送到这些对象，并提供丰富的API，使你能够检查 UI对象的属性和状态，并将它们与预期状态进行比较。</p>
<p><code>UI tests</code> 与<code>unit tests</code>的基本区别在于。<code>unit tests</code>使你可以在应用程序的范围内工作，并允许你在完全访问应用程序的的变量和状态的情况下使用函数和方法。<code>UI tests</code>以用户无法访问应用程序内部方法、功能和变量的方式练习应用程序的 UI。这使你的测试能够像用户一样查看应用程序，从而暴露用户遇到的 UI问题。</p>
<p>你的测试代码作为一个单独的程序运行，综合了应用程序中UI响应的事件。</p>
<p><code>UI tests</code> 基于三个新类的实现：</p>
<ul>
<li><code>XCUIApplication</code></li>
<li><code>XCUIElement</code></li>
<li><code>XCUIElementQuery</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTestUITests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUpWithError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处输入设置代码。在调用类中的每个测试方法之前调用此方法。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在 UI tests 中，当出现故障时，最好立即停止。</span></span><br><span class="line">        <span class="comment">// UI tests 方法中的每一步往往取决于前一步的成功；如果一个步骤失败，那么下面的所有测试也会失败。</span></span><br><span class="line">        continueAfterFailure = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 UI tests 中，必须先设置测试的初始状态（例如界面方向），然后再运行。setUp方法是执行此操作的好地方。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tearDownWithError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// 将清理代码放在此处。调用类中的每个测试方法后，将调用此方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testExample</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// UI tests 必须启动他们测试的应用程序。</span></span><br><span class="line">        <span class="keyword">let</span> app = <span class="type">XCUIApplication</span>()</span><br><span class="line">        app.launch()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 recording 开始编写 UI tests.</span></span><br><span class="line">        <span class="comment">// 使用 XCTAssert 和相关函数来验证测试是否产生正确的结果。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testLaunchPerformance</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">7.0</span>, *) &#123;</span><br><span class="line">            <span class="comment">// 这将测量启动应用程序所需的时间</span></span><br><span class="line">            measure(metrics: [<span class="type">XCTApplicationLaunchMetric</span>()]) &#123;</span><br><span class="line">                <span class="type">XCUIApplication</span>().launch()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-UI-Recording"><a href="#使用-UI-Recording" class="headerlink" title="使用 UI Recording"></a>使用 UI Recording</h4><p>从 <code>UI recording</code> 开始。它将源代码生成到一个测试实现文件中，可以编辑该文件来构建测试 或 回放特定的使用场景。<code>UI recording</code> 对于探索新的UI或学习如何编写UI测试序列也很有用。基本操作顺序是：</p>
<p>1、使用<code>test navigator</code>，创建<code>UI tests target</code>。</p>
<p>2、在创建的模板文件中，将光标置于测试函数中。</p>
<p>3、开始 <code>UI recording</code>。<br>应用程序启动并运行。使用应用程序以执行一系列UI操作。Xcode将操作捕获到函数体的源代码中。</p>
<p>4、完成要测试的操作后，停止<code>UI recording</code>。 </p>
<p>5、向源代码添加 <code>XCTest assertions</code>。</p>
<h4 id="编写-UI-Tests"><a href="#编写-UI-Tests" class="headerlink" title="编写 UI Tests"></a>编写 UI Tests</h4><p><code>API tests</code> 可以同时包含功能和性能方面，<code>UI tests</code>也可以。<code>UI tests</code>在App的表面空间运行，并且倾向于将许多低级功能集成到用户所看到的表示和响应中。</p>
<p><code>UI tests</code>基本上是在事件和响应级别上操作的。</p>
<ul>
<li>查询以查找元素。 </li>
<li>知道元素的预期行为作为参考。 </li>
<li>轻触或单击该元素以引起响应。 </li>
<li>测量响应是否符合通过/失败结果的预期。</li>
</ul>
<p>使用<code>XCTest</code>创建<code>UI tests</code>是与创建<code>unit tests</code>相同的编程模型的扩展。总体上使用了类似的操作和编程方法，不同之处在于<code>UI tests API</code>的基本概念以及它们在用户界面测试中描述的操作方式。</p>
<p>在测试类结构中，提供的setUp方法与单元测试类中的setUp包括两个区别。</p>
<p>在编写 <code>UI tests</code> 方法时，应该使用 <code>UI recording</code> 功能为测试创建一组基本步骤。然后可以使用<code>XCTest assertions</code>来为你的目的编辑此基本序列，以提供通过或失败结果（与<code>unit tests</code>一样）。``UI tests<code>和</code>unit tests`一样，既有功能方面，也有性能方面。</p>
<p>UI正确性测试的一般模式如下：</p>
<ul>
<li>使用 <code>XCUIElementQuery</code> 查找 <code>XCUIElement</code>。</li>
<li>合成事件并将其发送到 <code>XCUIElement</code>。</li>
<li>使用一个<code>assertion</code> 将 <code>XCUIElement</code> 的状态与预期的参考状态进行比较。</li>
</ul>
<h4 id="UI-test-for-performance"><a href="#UI-test-for-performance" class="headerlink" title="UI test for performance"></a>UI test for performance</h4><p>要构建性能的<code>UI test</code>，请将可重复的UI步骤序列包装到<code>test Performance</code>中可见的measureBlock结构中。</p>
<h2 id="代码覆盖范围"><a href="#代码覆盖范围" class="headerlink" title="代码覆盖范围"></a>代码覆盖范围</h2><p><code>Code coverage</code>(代码覆盖率) 是 Xcode 7 中的一项功能，使你可以可视化和测量测试执行了多少代码。使用<code>code coverage</code>，你可以确定测试是否在按预期的方式进行。</p>
<p>Xcode 中的 <code>code coverage</code> 是 <code>LLVM</code> 支持的一个测试选项。启用 <code>code coverage</code> 后，<code>LLVM</code> 会根据调用方法和函数的频率，对代码进行检测以收集覆盖率数据。<code>code coverage</code>选项可以收集数据以报告正确性和性能测试，无论是<code>unit tests</code>还是<code>UI tests</code>。</p>
<blockquote>
<p><code>code coverage</code>数据收集会导致性能下降。不管代价是否重大，它都将以线性方式影响代码的执行，因此启用它后，性能结果在测试运行与测试运行之间保持可比性。但是，在严格评估测试中例程的性能时，应考虑是否启用<code>code coverage</code>。</p>
</blockquote>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p><a href="https://github.com/specta/specta" target="_blank" rel="noopener">specta/specta</a>  和  <a href="https://github.com/specta/expecta" target="_blank" rel="noopener">specta/expecta</a> 框架都是出自<code>Cocoapods</code>作者 <code>orta</code>。</p>
<p><a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="noopener">facebookarchive/WebDriverAgent Archived</a>，3.8k，自动化测试</p>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html#//apple_ref/doc/uid/TP40014132" target="_blank" rel="noopener">About Testing with Xcode</a></p>
<p><a href="https://developer.apple.com/documentation/xcode/testing-your-apps-in-xcode" target="_blank" rel="noopener">Testing Your Apps in Xcode</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/ToolsLanguages/Conceptual/Xcode_Overview/UnitTesting.html#//apple_ref/doc/uid/TP40010215-CH63-SW1" target="_blank" rel="noopener">Using Unit Tests</a></p>
<p><a href="https://help.apple.com/xcode/mac/10.0/index.html?localePath=en.lproj#/dev42b289fbc" target="_blank" rel="noopener">Run UI tests and unit tests</a></p>
<p><a href="https://onevcat.com/tags/kiwi/" target="_blank" rel="noopener">onevcat * kiwi</a></p>
<p><a href="https://juejin.cn/post/6844903744170098695" target="_blank" rel="noopener">iOS 单元测试和 UI 测试快速入门</a></p>
<p><a href="https://chars.tech/blog/ios-unit-test/" target="_blank" rel="noopener">Chars’s Blog * iOS 单元测试</a></p>
<p><a href="https://mp.weixin.qq.com/s/66UvtkfPP3vDObLNk6W3Yg" target="_blank" rel="noopener">使用 XCTest 消除动画卡顿</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/20/XCTest/">http://yoursite.com/2020/05/20/XCTest/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/05/25/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"><i class="fa fa-chevron-left">  </i><span>iOS 内存管理编程指南</span></a></div><div class="next-post pull-right"><a href="/2020/05/14/LLDB/"><span>LLDB</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>