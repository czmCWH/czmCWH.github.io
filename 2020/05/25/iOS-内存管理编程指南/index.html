<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="iOS 内存管理编程指南"><meta name="keywords" content="iOS"><meta name="author" content="Czm"><meta name="copyright" content="Czm"><title>iOS 内存管理编程指南 | Czm</title><link rel="shortcut icon" href="/img/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Objective-C-提供了两种App-Memory-Management的方法："><span class="toc-number">1.1.</span> <span class="toc-text">Objective-C 提供了两种App Memory Management的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#良好做法可防止与内存相关的问题。错误的-memory-management-会导致的问题主要有两种："><span class="toc-number">1.2.</span> <span class="toc-text">良好做法可防止与内存相关的问题。错误的 memory management 会导致的问题主要有两种：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Management-Policy"><span class="toc-number">2.</span> <span class="toc-text">Memory Management Policy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-Memory-Management-Rules"><span class="toc-number">2.1.</span> <span class="toc-text">Basic Memory Management Rules</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发送-release"><span class="toc-number">2.1.1.</span> <span class="toc-text">发送 release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-autorelease-发送延迟-release"><span class="toc-number">2.1.2.</span> <span class="toc-text">使用 autorelease 发送延迟 release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你不拥有通过引用返回的对象"><span class="toc-number">2.1.3.</span> <span class="toc-text">你不拥有通过引用返回的对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-dealloc-以放弃对象的所有权"><span class="toc-number">2.2.</span> <span class="toc-text">实现 dealloc 以放弃对象的所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Core-Foundation-使用相似但不同的规则"><span class="toc-number">2.3.</span> <span class="toc-text">Core Foundation 使用相似但不同的规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实用的内存管理"><span class="toc-number">3.</span> <span class="toc-text">实用的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Accessor-Methods-使内存管理更轻松"><span class="toc-number">3.1.</span> <span class="toc-text">使用 Accessor Methods 使内存管理更轻松</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-Accessor-Methods-设置属性值"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用 Accessor Methods 设置属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要在-Initializer-和-dealloc-方法中使用-Accessor-Methods"><span class="toc-number">3.1.2.</span> <span class="toc-text">不要在 Initializer 和 dealloc 方法中使用 Accessor Methods</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用弱引用以避免-Retain-Cycles"><span class="toc-number">3.2.</span> <span class="toc-text">使用弱引用以避免 Retain Cycles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免释放正在使用的对象"><span class="toc-number">3.3.</span> <span class="toc-text">避免释放正在使用的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要使用-dealloc-来管理稀缺资源"><span class="toc-number">3.4.</span> <span class="toc-text">不要使用 dealloc 来管理稀缺资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合拥有它们包含的对象"><span class="toc-number">3.5.</span> <span class="toc-text">集合拥有它们包含的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ownership-Policy-是使用-Retain-Counts-实现的"><span class="toc-number">3.6.</span> <span class="toc-text">Ownership Policy 是使用 Retain Counts 实现的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autorelease-Pool-Blocks"><span class="toc-number">4.</span> <span class="toc-text">Autorelease Pool Blocks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-Local-Autorelease-Pool-Blocks-来减少峰值内存占用量"><span class="toc-number">4.1.</span> <span class="toc-text">使用 Local Autorelease Pool Blocks 来减少峰值内存占用量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autorelease-Pool-Blocks-和-Threads"><span class="toc-number">4.2.</span> <span class="toc-text">Autorelease Pool Blocks 和 Threads</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#学习博客"><span class="toc-number">5.</span> <span class="toc-text">学习博客</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="img/avatar.jpeg"></div><div class="author-info__name text-center">Czm</div><div class="author-info__description text-center">学习记录</div><div class="follow-button"><a href="https://github.com/czmCWH" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.cnswift.org/about-swift" target="_blank" rel="noopener">swift中文文档</a><a class="author-info-links__name text-center" href="https://swift.gg" target="_blank" rel="noopener">SwiftGG</a><a class="author-info-links__name text-center" href="http://chuangzaoshi.com" target="_blank" rel="noopener">创造狮导航</a><a class="author-info-links__name text-center" href="http://lib.xcz.im/library" target="_blank" rel="noopener">《西窗烛》</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Czm</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/About">关于</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">iOS 内存管理编程指南</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/Memory/">Memory</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>Application Memory Management</code>(应用程序内存管理) 是在程序运行时分配内存、使用内存并在完成后释放内存的过程。编写良好的程序将使用尽可能少的内存。在 <code>Objective-C</code> 中，<code>Memory Management</code>也可以看作是将有限内存资源的所有权分配给许多数据和代码的一种方式。</p>
<a id="more"></a>

<p>尽管通常在单个对象级别上考虑 <code>Memory Management</code>，但实际上你的目标是管理 <code>object graphs</code>(对象图)。你要确保内存中没有超出实际需要的对象。</p>
<img src="/2020/05/25/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/16215639999134.png" class="" title="This is an example image">


<h3 id="Objective-C-提供了两种App-Memory-Management的方法："><a href="#Objective-C-提供了两种App-Memory-Management的方法：" class="headerlink" title="Objective-C 提供了两种App Memory Management的方法："></a><code>Objective-C</code> 提供了两种<code>App Memory Management</code>的方法：</h3><p>1、在本指南中描述的方法，称为 <code>manual retain-release</code>(手动保留释放) 或 <code>MRR</code>，可以通过跟踪自己拥有的对象来显式管理内存。这是使用 <code>Foundation</code> 中的 <code>NSObject</code>类 与 <code>runtime environment</code> 一起提供的一个称为 <code>reference counting</code>(引用计数) 的模型来实现的。</p>
<p>2、在 <code>Automatic Reference Counting</code>(<code>ARC</code>) 中，系统使用与 <code>MRR</code> 相同的 <code>reference counting system</code>，但是它会在编译时为你插入适当的内存管理方法调用。有关 <code>ARC</code> 的更多信息，请参阅 <a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a>。</p>
<h3 id="良好做法可防止与内存相关的问题。错误的-memory-management-会导致的问题主要有两种："><a href="#良好做法可防止与内存相关的问题。错误的-memory-management-会导致的问题主要有两种：" class="headerlink" title="良好做法可防止与内存相关的问题。错误的 memory management 会导致的问题主要有两种："></a>良好做法可防止与内存相关的问题。错误的 <code>memory management</code> 会导致的问题主要有两种：</h3><ul>
<li>释放或覆盖仍在使用的数据</li>
</ul>
<p>这会导致内存损坏，通常会导致你的 <code>App</code> 崩溃，或者更糟的是，损坏的用户数据。</p>
<ul>
<li>不释放不再使用的数据会导致 <code>memory leaks</code>(内存泄漏)</li>
</ul>
<p><code>memory leak</code>是指分配的内存不会被释放，即使它不再被使用。泄漏会导致你的 <code>App</code> 使用越来越多的内存，进而可能导致系统性能下降或应用程序被终止。</p>
<p>但是，从 <code>reference counting</code> 的角度考虑 <code>memory management</code> 通常会适得其反，因为你倾向于根据实现细节而不是实际目标来考虑 <code>memory management</code>。相反，你应该从对象所有权和 <code>object graphs</code> 的角度考虑 <code>memory management</code>。</p>
<p><code>Cocoa</code> 使用一个直截了当的 <code>naming convention</code>(命名约定) 来指示你何时拥有一个方法返回的对象。请参阅 <code>Memory Management Policy</code>。</p>
<h2 id="Memory-Management-Policy"><a href="#Memory-Management-Policy" class="headerlink" title="Memory Management Policy"></a>Memory Management Policy</h2><p><code>reference-counted environment</code>(引用计数环境) 中用于 <code>memory management</code> 的基本模型 由 <code>NSObject  protocol</code> 中定义的方法 和 标准方法 <code>naming convention</code> 的组合 提供。<code>NSObject</code>类还定义了一个 <code>dealloc</code> 方法，该方法在对象被释放后自动调用。</p>
<h3 id="Basic-Memory-Management-Rules"><a href="#Basic-Memory-Management-Rules" class="headerlink" title="Basic Memory Management Rules"></a>Basic Memory Management Rules</h3><p><code>memory management model</code> 基于对象所有权。任何对象都可以具有一个或多个所有者。只要一个对象至少具有一个所有者，它就会继续存在。如果一个对象没有所有者，则 <code>runtime system</code> 会自动销毁它。为了确保你清楚何时拥有对象，何时不拥有对象，<code>Cocoa</code> 设置了以下策略：</p>
<ul>
<li>你拥有自己创建的任何对象。</li>
</ul>
<p>使用名称以 <code>alloc</code>、<code>new</code>、<code>copy</code> 或 <code>mutableCopy</code> 开头的方法（例如<code>alloc</code>，<code>newObject</code>或<code>mutableCopy</code>）创建对象。</p>
<ul>
<li>你可以使用 <code>retain</code> 来获取对象的所有权</li>
</ul>
<p>接收到的对象通常保证在接收到它的方法内保持有效，并且该方法还可以安全地将该对象返回给其调用者。在以下两种情况下你使用 <code>retain</code>：（1）在访问器方法或 <code>init</code> 方法的实现中，将要存储的对象的所有权作为属性值；（2）防止对象由于其他操作的副作用而失效（如 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/20000043-1000922" target="_blank" rel="noopener">Avoid Causing Deallocation of Objects You’re Using)</a>）。</p>
<ul>
<li>当你不再需要它时，必须放弃对你拥有的对象的所有权</li>
</ul>
<p>可以通过发送 <code>release</code> 消息或 <code>autorelease</code> 消息来放弃对象的所有权。因此，在<code>Cocoa</code>术语中，放弃对象的所有权通常称为 <code>“releasing” an object</code>。</p>
<ul>
<li>你不得放弃 你不拥有的对象 的所有权</li>
</ul>
<p>这只是先前明确规定的政策规则的推论。</p>
<p>如下是对象内存释放的一些例子：</p>
<h4 id="发送-release"><a href="#发送-release" class="headerlink" title="发送 release"></a>发送 release</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Person *aPerson = [[Person alloc] init];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = aPerson.fullName;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [aPerson release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Person</code> 对象是使用 <code>alloc</code> 方法创建的，因此当不再需要它时，将向它发送 <code>release</code> 消息。<code>person’s name</code>不是用任何拥有的方法来检索，因此不会发送 <code>release</code> 消息。但是请注意，该示例使用 <code>release</code> 不是 <code>autorelease</code>。</p>
<h4 id="使用-autorelease-发送延迟-release"><a href="#使用-autorelease-发送延迟-release" class="headerlink" title="使用 autorelease 发送延迟 release"></a>使用 autorelease 发送延迟 release</h4><p>当需要发送延迟的<code>release</code>消息时（通常是从方法返回对象时），可以使用 <code>autorelease</code>。</p>
<p>如下示例，你拥有 <code>alloc</code> 返回的字符串。为了遵守 <code>memory management rules</code>，你必须放弃对字符串的所有权，然后再丢失对该字符串的引用。但是，如果使用 <code>release</code>，则字符串将在返回之前被释放（该方法将返回无效的对象）。使用 <code>autorelease</code>，表示你要放弃所有权，但是允许方法的调用者在释放之前使用返回的字符串。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                          <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName] autorelease];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以像这样实现fullName方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                 <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循基本规则，你不拥有 <code>stringWithFormat:</code> 返回的字符串，因此可以安全地从该方法返回该字符串。 </p>
<p>相比之下，以下实现是错误的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                         <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 <code>naming convention</code>(命名约定)，没有任何东西表示 <code>fullName</code> 方法的调用者拥有返回的字符串。因此，调用者没有理由释放返回的字符串，因此它将被泄漏。</p>
<h4 id="你不拥有通过引用返回的对象"><a href="#你不拥有通过引用返回的对象" class="headerlink" title="你不拥有通过引用返回的对象"></a>你不拥有通过引用返回的对象</h4><p><code>Cocoa</code> 中的某些方法指定对象是通过引用返回的（即，它们采用 <code>ClassName **</code> 或 <code>id *</code> 类型的参数）。一种常见的模式是使用 <code>NSError</code> 对象，该对象包含发生错误时的相关信息，如<code>initWithContentsOfURL:options:error:</code> (NSData) 和 <code>initWithContentsOfFile:encoding:error:</code> (NSString)所示。</p>
<p>在这些情况下，适用的规则与前面描述的相同。当你调用任何这些方法时，你不会创建 <code>NSError</code> 对象，因此你不拥有该对象。因此，无需释放它，如下示例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *fileName = &lt;#Get a file name#&gt;;</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *string = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:fileName</span><br><span class="line">                        encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (string == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// Deal with error...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[string release];</span><br></pre></td></tr></table></figure>

<h3 id="实现-dealloc-以放弃对象的所有权"><a href="#实现-dealloc-以放弃对象的所有权" class="headerlink" title="实现 dealloc 以放弃对象的所有权"></a>实现 dealloc 以放弃对象的所有权</h3><p><code>NSObject</code> 类定义了一个 <code>dealloc</code> 方法，当对象没有所有者且其内存被回收时，该方法会自动调用——在 <code>Cocoa</code> 术语中，它是<code>“freed”</code> 或 <code>“deallocated.”</code>。<code>dealloc</code>方法的作用是释放对象自己的内存，并处理它所拥有的任何资源，包括任何对象实例变量的所有权。</p>
<p>以下示例说明了如何为 <code>Person</code> 类实现 <code>dealloc</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>) <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>) <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *fullName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">    [_firstName release];</span><br><span class="line">    [_lastName release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br>切勿直接调用另一个对象的 <code>dealloc</code> 方法。<br>必须在<code>dealloc</code> 方法实现结束时调用父类的实现。<br>你不应该将系统资源的管理与对象生存期联系起来；<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW13" target="_blank" rel="noopener">Don’t Use dealloc to Manage Scarce Resources</a><br>当 <code>App</code> 终止时，可能不会向对象发送 <code>dealloc</code> 消息。由于进程的内存在退出时会自动清除，因此简单地允许操作系统清理资源比调用所有 <code>memory management</code> 方法更有效。</p>
</blockquote>
<h3 id="Core-Foundation-使用相似但不同的规则"><a href="#Core-Foundation-使用相似但不同的规则" class="headerlink" title="Core Foundation 使用相似但不同的规则"></a>Core Foundation 使用相似但不同的规则</h3><p><code>Core Foundation</code> 对象也有类似的 <code>memory management rules</code>（请参阅 <a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="noopener">Memory Management Programming Guide for Core Foundation</a>）。但是，<code>Cocoa</code> 和 <code>Core Foundation</code> 的 <code>naming conventions</code>(命名约定) 不同。特别是，<code>Core Foundation</code> 的 <a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029" target="_blank" rel="noopener">Create Rule</a> 不适用于返回 <code>Objective-C</code> 对象的方法。例如，在以下代码片段中，你不负责放弃myInstance的所有权：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myInstance = [MyClass createInstance];</span><br></pre></td></tr></table></figure>

<h2 id="实用的内存管理"><a href="#实用的内存管理" class="headerlink" title="实用的内存管理"></a>实用的内存管理</h2><p>尽管 <code>Memory Management Policy</code>(内存管理策略) 中描述的基本概念很简单，但是你可以采取一些实际步骤，使管理内存更容易，并帮助确保你 <code>App</code> 保持可靠和健壮，同时最大程度地减少其资源需求。</p>
<h3 id="使用-Accessor-Methods-使内存管理更轻松"><a href="#使用-Accessor-Methods-使内存管理更轻松" class="headerlink" title="使用 Accessor Methods 使内存管理更轻松"></a>使用 Accessor Methods 使内存管理更轻松</h3><p>如果你定义类的属性是对象，则必须确保在使用该对象时，不会释放任何设置为该值的对象。因此，在设置对象时必须声明该对象的所有权。你还必须确保随后放弃对当前持有 <code>Value</code> 的所有权。</p>
<p>有时它可能看起来很乏味或繁琐，但是如果你始终使用<code>accessor methods</code>(访问器方法)，则出现内存管理问题的可能性会大大降低。如果在整个代码中对实例变量使用<code>retain</code>和<code>release</code>，则你几乎肯定在做错误的事情。</p>
<p>如下是你考虑一个 <code>Counter</code> 对象，你要设置其计数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Counter</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSNumber</span> *count;</span><br><span class="line"><span class="keyword">@end</span>;</span><br></pre></td></tr></table></figure>

<p><code>property</code>(属性) 声明了两个 <code>accessor methods</code>。通常，你应该要求编译器合成这些方法；然而，看看如何实现它们是很有启发性的。</p>
<p>在 <code>“get” accessor</code> 中，你只需返回合成的实例变量，因此不需要 <code>retain</code> 或 <code>release</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>“set” method</code> 中，如果其他所有人都遵循相同的规则，则必须假定可以随时处置新计数，因此必须通过发送 <code>retain</code> 消息来获取对象的所有权，以确保不会被处置。你还必须在此处通过发送 <code>release</code> 消息来放弃对旧计数对象的所有权。（在 <code>Objective-C</code> 中允许将消息发送到 <code>nil</code>，因此，如果尚未设置<code>_count</code>，则实现仍将起作用。）如果两个对象是同一对象，则必须在 <code>[newCount retain]</code> 之后发送该消息，否则您将无法发送该消息。 希望在不经意间导致它被释放。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</span><br><span class="line">    [newCount <span class="keyword">retain</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    <span class="comment">// 进行新工作</span></span><br><span class="line">    _count = newCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Accessor-Methods-设置属性值"><a href="#使用-Accessor-Methods-设置属性值" class="headerlink" title="使用 Accessor Methods 设置属性值"></a>使用 Accessor Methods 设置属性值</h4><p>假设你要实现一种重置 <code>counter</code> 的方法。有两种选择。第一个实现使用 <code>alloc</code> 创建 <code>NSNumber</code> 实例，因此你可以使用 <code>release</code> 来平衡它。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setCount:zero];</span><br><span class="line">    [zero release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法使用一个 <code>convenience constructor</code>(便利构造函数) 来创建一个新的 <code>NSNumber</code> 对象。因此，不需要 <code>retain</code> 或 <code>release</code> 消息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setCount:zero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方法都是用了 <code>accessor method</code>。</p>
<p>对于简单的情况，下面的方法几乎可以肯定是正确的，但是尽量避免使用 <code>accessor methods</code> 有诱惑力，但这几乎肯定会在某个阶段导致错误（例如，当您忘记 <code>retain</code> 或 <code>release</code> 时，或者如果实例变量的内存管理语义发生更改时）。</p>
<p>还要注意，如果使用 <code>key-value observing</code>，则如下以这种方式更改变量不符合KVO。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    [_count release];</span><br><span class="line">    _count = zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要在-Initializer-和-dealloc-方法中使用-Accessor-Methods"><a href="#不要在-Initializer-和-dealloc-方法中使用-Accessor-Methods" class="headerlink" title="不要在 Initializer 和 dealloc 方法中使用 Accessor Methods"></a>不要在 Initializer 和 dealloc 方法中使用 Accessor Methods</h4><p>你不应该使用 <code>accessor methods</code> 来设置实例变量的唯一地方是在 <code>initializer</code> 和 <code>dealloc</code> 方法中。要用表示 0 的 <code>number</code>对象初始化 <code>counter</code> 对象，可以实现如下的 <code>init</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要允许使用非零计数初始化 <code>counter</code>，可以实现 <code>initWithCount:</code> 方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- initWithCount:(<span class="built_in">NSNumber</span> *)startingCount &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = [startingCount <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Counter</code> 类有一个对象实例变量，因此你还必须实现 <code>dealloc</code> 方法。它应通过向其发送 <code>release</code> 消息来放弃任何实例变量的所有权，并最终应调用 <code>super</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_count release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用弱引用以避免-Retain-Cycles"><a href="#使用弱引用以避免-Retain-Cycles" class="headerlink" title="使用弱引用以避免 Retain Cycles"></a>使用弱引用以避免 Retain Cycles</h3><p><code>Retain</code> 对象会创建对该对象的 <code>strong reference</code>。在所有 <code>strong references</code> 释放之前，都无法释放对象。因此，如果两个对象可能具有 <code>cyclical references</code>(循环引用)，则可能会产生一个称为 <code>retain cycle</code> 的问题，也就是说，它们彼此之间有着 <code>strong reference</code>。（直接或通过一系列其他对象，每个对象都强烈引用下一个，导致第一个回到第一个）</p>
<p>如下是 <code>cyclical references</code> 的图解：</p>
<img src="/2020/05/25/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/16218235320517.jpg" class="" title="This is an example image">

<p>解决 <code>retain cycles</code> 问题的方法是使用 <code>weak references</code>(弱引用)。<code>weak reference</code> 是一种非所有权关系，其中源对象不 <code>retain</code>(保留) 其具有引用的对象。</p>
<p>但是，为了保持 <code>object graph</code> 的完整性，在某个地方必须有 <code>strong references</code>（如果只有 <code>weak references</code>，则 <code>pages</code> 和  <code>paragraphs</code> 可能没有任何所有者，因此将被释放）。 因此，<code>Cocoa</code>建立了一个约定，即 父对象 应保持对其 子代 的 <code>strong references</code>，而 子对象 应具有对其 父代 的<code>weak references</code>。</p>
<p><code>Cocoa</code> 中 <code>weak references</code> 的示例包括但不限于 <code>table data sources</code>、<code>outline view items</code>、<code>notification observers</code>以及 <code>miscellaneous targets</code> 和 <code>delegates</code>。</p>
<p>你需要谨慎地将消息发送到仅持有 <code>weak reference</code> 的对象。如果在对象被释放后向其发送消息，则应用程序将 <code>crash</code>(崩溃)。你必须对对象何时有效 具有明确定义的条件。</p>
<p>在大多数情况下，<code>weak-referenced object</code>知道另一个对象对它的弱引用，就像 <code>circular references</code> 一样，并负责在它释放时通知另一个对象。例如，向<code>notification center</code>注册对象时，<code>notification center</code>将存储对该对象的 <code>weak reference</code>，并在发布相应通知时向其发送消息。当对象被释放后，你需要在<code>notification center</code>注销它，以防止<code>notification center</code>向不再存在的对象发送任何消息。同样，当一个 <code>delegate object</code> 被释放时，你需要通过向另一个对象发送带有 <code>nil</code>参数的 <code>setDelegate:</code> 消息来删除 <code>delegate link</code>。这些消息通常从对象的 <code>dealloc</code> 方法发送。</p>
<h3 id="避免释放正在使用的对象"><a href="#避免释放正在使用的对象" class="headerlink" title="避免释放正在使用的对象"></a>避免释放正在使用的对象</h3><p><code>Cocoa</code> 的所有权策略规定，接收到的对象通常应在整个调用方法范围内保持有效。还应该可以从当前作用域返回接收到的对象，而不必担心它会被释放。对你的 App 来说，对象的 <code>getter</code> 方法返回缓存的实例变量或计算值并不重要。重要的是该对象在你需要的时间内保持有效。</p>
<p>该规则偶尔会有例外，主要属于以下两类之一。</p>
<p>1、从一个基本集合类中删除一个对象时。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [array objectAtIndex:n];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// heisenObject 现在可能无效</span></span><br></pre></td></tr></table></figure>

<p>从一个基本集合类中删除一个对象时，将向它发送一个<code>release</code>（而不是 <code>autorelease</code>）消息。如果该集合是被移除对象的唯一所有者，那么被移除对象（示例中的 <code>heisenObject</code> ）将立即被释放。</p>
<p>2、当“父对象”被释放时</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">heisenObject = [parent child] ;</span><br><span class="line">[parent release]; <span class="comment">// 或者，例如: self.parent = nil;</span></span><br><span class="line"><span class="comment">// heisenObject 现在可能无效.</span></span><br></pre></td></tr></table></figure>

<p>在某些情况下，你将从另一个对象中检索一个对象，然后直接或间接释放父对象。如果释放父级导致将其释放，并且父级是子项的唯一所有者，(假设在父级的 <code>dealloc</code> 方法中向其发送了 <code>release</code> 而不是 <code>autorelease</code> 消息。) 那么子项（示例中的 <code>heisenObject</code>）将同时释放。</p>
<p>为了防止出现这些情况，请在接收到 <code>heisenObject</code> 后将其保留，并在完成后将其释放。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heisenObject = [[array objectAtIndex:n] <span class="keyword">retain</span>];</span><br><span class="line">[array removeObjectAtIndex:n];</span><br><span class="line"><span class="comment">// 使用 heisenObject...</span></span><br><span class="line">[heisenObject release];</span><br></pre></td></tr></table></figure>

<h3 id="不要使用-dealloc-来管理稀缺资源"><a href="#不要使用-dealloc-来管理稀缺资源" class="headerlink" title="不要使用 dealloc 来管理稀缺资源"></a>不要使用 dealloc 来管理稀缺资源</h3><p>通常，你不应该在 <code>dealloc</code> 方法中管理 <code>scarce resources</code>(稀缺资源)，例如 <code>file descriptors</code>，<code>network connections</code> 以及 <code>buffers</code> 或 <code>caches</code>。特别是，你不应设计类，以便在你认为 <code>dealloc</code> 将被调用时调用它。由于 <code>bug</code> 或 <code>App tear-down</code>(APP崩溃)，对 <code>dealloc</code> 的调用可能会延迟或避开。</p>
<p>相反，如果您有一个类，其实例管理 <code>scarce resources</code>，则应设计你的 App，以使你知道何时不再需要这些资源，然后可以告诉实例在此时<code>clean up</code>。通常情况下，你会随后释放该实例，然后<code>dealloc</code>就会随之而来，但如果它不释放，则不会遇到其他问题。</p>
<p>如果你试图在 <code>dealloc</code> 的基础上进行<code>resource management</code>，则可能会出现问题。例如：</p>
<p>1、<code>object graph</code>的顺序依赖关系被分解。</p>
<p><code>object graph tear-down mechanism</code>(对象图的拆卸机制)本质上是无序的。虽然你可能通常期望并得到一个特定的顺序，但你正在引入脆弱性。例如，如果某个对象意外地<code>autoreleased</code>而不是<code>released</code>，则拆卸顺序可能会更改，这可能会导致意外结果。</p>
<p>2、不回收 <code>scarce resources</code></p>
<p><code>Memory leaks</code>(内存泄漏) 是应该修复的错误，但通常不会立即致命。但是，如果在你期望释放 <code>scarce resources</code> 时没有释放它们，则可能会遇到更严重的问题。例如，如果你的 App 用尽了 <code>file descriptors</code>，则用户可能无法保存数据。</p>
<p>3、在错误的线程上执行清除逻辑。</p>
<p>如果一个对象在一个意外的时间被自动释放，它将在它所在的线程的 <code>autorelease pool block</code> 上被释放。对于只能从一个线程访问的资源来说，这很容易是致命的。</p>
<h3 id="集合拥有它们包含的对象"><a href="#集合拥有它们包含的对象" class="headerlink" title="集合拥有它们包含的对象"></a>集合拥有它们包含的对象</h3><p>将对象添加到集合（例如数组，字典或集合）时，该集合将拥有该对象的所有权。当从集合中删除对象或释放集合本身时，该集合将放弃所有权。因此，例如，如果要创建数字数组，则可以执行以下任一操作：</p>
<p>如下例子中，你没有调用<code>alloc</code>，因此无需调用<code>release</code>。不需要 <code>retain</code> 新的数字（<code>convenienceNumber</code>），因为数组会这样做。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;#Get a <span class="keyword">mutable</span> array#&gt;;</span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *convenienceNumber = [<span class="built_in">NSNumber</span> numberWithInteger:i];</span><br><span class="line">    [array addObject:convenienceNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下这种情况下，你确实需要在 <code>for loop</code> 作用域内向 <code>allocedNumber</code> 发送 <code>release</code> 消息以平衡<code>alloc</code>。由于数组在由 <code>addObject:</code> 添加时会 <code>retained</code>(保留) 该数字，因此当它在数组中时将不会被释放。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = &lt;#Get a <span class="keyword">mutable</span> array#&gt;;</span><br><span class="line"><span class="built_in">NSUInteger</span> i;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *allocedNumber = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:i];</span><br><span class="line">    [array addObject:allocedNumber];</span><br><span class="line">    [allocedNumber release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ownership-Policy-是使用-Retain-Counts-实现的"><a href="#Ownership-Policy-是使用-Retain-Counts-实现的" class="headerlink" title="Ownership Policy 是使用 Retain Counts 实现的"></a>Ownership Policy 是使用 Retain Counts 实现的</h3><p><code>ownership policy</code>(所有权策略) 是通过 <code>reference counting</code>(引用计数）实现的，通常在 <code>retain</code> 方法之后称为 <code>“retain count”</code>(保留计数)。每个对象都有一个<code>retain count</code>。</p>
<ul>
<li>创建对象时，其 <code>retain count</code> 为1。</li>
<li>向对象发送 <code>retain</code> 消息时，其 <code>retain count</code> 将增加1。</li>
<li>向对象发送 <code>release</code> 消息时，其 <code>retain count</code> 减少1。</li>
<li>向对象发送 <code>autorelease</code> 消息时，其 <code>retain count</code> 在当前 <code>autorelease pool block</code> 的末尾减少1。</li>
<li>如果对象的 <code>retain count</code> 减少到零，则会将其释放。</li>
</ul>
<p>应该没有理由显式地询问对象其保留计数是多少 (请参阅 <code>retainCount</code>)。结果往往是误导性的，因为你可能不知道哪些 <code>framework objects</code> 保留了你感兴趣的对象。在调试 <code>memory management</code> 问题时，只应确保代码符合 <code>ownership rules</code>。</p>
<h2 id="Autorelease-Pool-Blocks"><a href="#Autorelease-Pool-Blocks" class="headerlink" title="Autorelease Pool Blocks"></a>Autorelease Pool Blocks</h2><p><code>Autorelease pool blocks</code>(自动释放池块) 提供了一种机制，你可以通过该机制放弃对象的所有权，但可以避免立即释放对象的可能性（例如，从方法返回对象时）。通常，你不需要创建自己的<code>autorelease pool block</code>，但是在某些情况下，你必须这样做或者这样做是有益的。</p>
<p>使用 <code>@autoreleasepool</code> 标记 <code>autorelease pool block</code>，如以下示例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// 创建自动释放对象的代码.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>autorelease pool block</code>的末尾，在 <code>block</code> 中接收到 <code>autorelease</code> 消息的对象会被发送一条 <code>release</code> 消息——每次在 <code>block</code> 中接收到 <code>autorelease</code> 消息时，对象都会收到一条 <code>release</code> 消息。</p>
<p>像任何其他代码块一样，<code>autorelease pool block</code>可以嵌套：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（你通常不会看到与上述完全相同的代码；通常，一个源文件中<code>autorelease pool block</code>中的代码会调用另一个<code>autorelease pool block</code>中包含的另一个源文件中的代码。）对于给定的 <code>autorelease</code> 消息，相应的<code>release</code>消息 将在发送 <code>autorelease</code> 的 <code>autorelease pool block</code> 的末尾发送。</p>
<p><code>Cocoa</code> 始终希望代码在 <code>autorelease pool block</code> 中执行，否则自动释放的对象将不会被释放，应用程序会<code>leaks memory</code>。（如果你在 <code>autorelease pool block</code> 之外发送 <code>autorelease</code> 消息，则 <code>Cocoa</code> 会记录一条适当的错误消息。）<code>AppKit</code> 和 <code>UIKit</code> 框架处理<code>autorelease pool block</code>中的每个<code>event-loop</code>迭代（例如，鼠标按下事件或轻击）。因此，你通常不必自己创建一个<code>autorelease pool block</code>，甚至不必查看用于创建一个<code>autorelease pool block</code>的代码。但是，在三种情况下，你可能会使用自己的<code>autorelease pool block</code>：</p>
<ul>
<li><p>如果你正在编写一个不基于UI框架的程序，例如命令行工具。</p>
</li>
<li><p>如果编写一个创建许多临时对象的循环。</p>
</li>
</ul>
<p>你可以在循环内使用 <code>autorelease pool block</code> 在下一次迭代之前处理这些对象。在循环中使用 <code>autorelease pool block</code> 有助于减少应用程序的最大内存占用。</p>
<ul>
<li>如果生成 <code>secondary thread</code>(辅助线程)。 </li>
</ul>
<p>一旦线程开始执行，你必须创建自己的<code>autorelease pool block</code>；否则，您的应用程序将泄漏对象。 </p>
<h3 id="使用-Local-Autorelease-Pool-Blocks-来减少峰值内存占用量"><a href="#使用-Local-Autorelease-Pool-Blocks-来减少峰值内存占用量" class="headerlink" title="使用 Local Autorelease Pool Blocks 来减少峰值内存占用量"></a>使用 Local Autorelease Pool Blocks 来减少峰值内存占用量</h3><p>许多程序会创建自动释放的临时对象。这些对象添加到程序的内存占用，直到块结束。在许多情况下，允许临时对象累积到当前事件循环迭代结束不会导致过多的开销；但是，在某些情况下，你可能会创建大量临时对象，这些临时对象会大大增加内存占用，并且你希望更快地对其进行处理。在后一种情况下，你可以创建自己的<code>autorelease pool block</code>。在该块的末尾，将释放临时对象，这通常导致它们的<code>deallocation</code>，从而减少了程序的内存占用量。</p>
<p>以下示例显示了如何在for循环中使用<code>local autorelease pool block</code>：</p>
<p>for循环一次处理一个文件。在 <code>autorelease pool block</code> 内发送 <code>autorelease</code> 消息的任何对象（例如 <code>fileContents</code> ）都在该块的末尾释放。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;# An array of file URLs #&gt;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* 处理字符串，创建并自动释放更多对象 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>autorelease pool block</code>之后，你应该将在该块内自动释放的所有对象都视为<code>“disposed of.”</code>。不要向该对象发送消息或将其返回给你的方法的调用者。如果必须在<code>autorelease pool block</code>之外使用临时对象，则可以通过向块内的对象发送<code>retain</code>消息，然后在该块之后将其自动释放，来执行此操作，如下例所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">– (<span class="keyword">id</span>)findMatchingObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">id</span> match;</span><br><span class="line">    <span class="keyword">while</span> (match == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/* 进行搜索以创建许多临时对象. */</span></span><br><span class="line">            match = [<span class="keyword">self</span> expensiveSearchForObject:anObject];</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (match != <span class="literal">nil</span>) &#123;</span><br><span class="line">                [match <span class="keyword">retain</span>]; <span class="comment">/* Keep match around. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [match autorelease];   <span class="comment">/* Let match go and return it. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上示例，在 <code>autorelease pool block</code> 内将 <code>retain</code> 发送到 <code>match</code>，并在 <code>autorelease pool block</code> 后向其发送 <code>autorelease</code>，可延长 <code>match</code> 的生命周期，并允许其在循环外接收消息并返回给 <code>findMatchingObject:</code> 的调用程序。</p>
<h3 id="Autorelease-Pool-Blocks-和-Threads"><a href="#Autorelease-Pool-Blocks-和-Threads" class="headerlink" title="Autorelease Pool Blocks 和 Threads"></a>Autorelease Pool Blocks 和 Threads</h3><p><code>Cocoa</code> 应用程序中的每个线程都维护自己的<code>autorelease pool blocks</code>栈(<code>stack</code>)。如果你正在编写 仅限于 <code>Foundation</code> 的程序 或 <code>detach thread</code>(分离线程)，则需要创建自己的<code>autorelease pool block</code>。</p>
<p>如果你的应用程序或线程是<code>long-lived</code>，并且有可能生成大量<code>autoreleased objects</code>，则应使用<code>autorelease pool blocks</code>（例如 AppKit 和 UIKit 在主线程上所做的）；否则，<code>autoreleased objects</code>会堆积，并且你的内存占用量也会增加。如果<code>detach thread</code>不进行 <code>Cocoa</code> 调用，则无需使用<code>autorelease pool block</code>。</p>
<blockquote>
<p>如果使用 <code>POSIX thread APIs</code> 而不是 <code>NSThread</code> 创建 <code>secondary threads</code>(辅助线程)，则除非 <code>Cocoa</code> 处于多线程模式，否则无法使用 <code>Cocoa</code>。只有在分离其第一个 <code>NSThread</code> 对象之后，<code>Cocoa</code> 才进入多线程模式。要在 <code>secondary POSIX threads</code> 上使用 <code>Cocoa</code>，你的应用程序必须首先分离至少一个 <code>NSThread</code> 对象，该对象可以立即退出。您可以使用 <code>NSThread</code> 类方法<code>isMultiThreaded</code> 测试 <code>Cocoa</code> 是否处于多线程模式。</p>
</blockquote>
<h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">About Memory Management</a></p>
<p><a href="https://rimson.top/2019/08/07/ios-memory/" target="_blank" rel="noopener">Rimson * Objective-C 内存管理简介</a></p>
<p><a href="https://juejin.cn/post/6844903902169710600#heading-14" target="_blank" rel="noopener">Bytedance * RickeyBoy | iOS Memory 内存详解 (长文)</a></p>
<p><a href="https://mp.weixin.qq.com/s/YpJa3LeTFz9UFOUcs5Bitg" target="_blank" rel="noopener">一瓜技术 | iOS Memory 内存详解</a></p>
<p><a href="https://juejin.cn/post/6956144382906990623#heading-17" target="_blank" rel="noopener">清华同方 * 奉孝 | iOS 内存管理机制</a></p>
<p><a href="https://juejin.im/post/6844903713832697864" target="_blank" rel="noopener">即刻技术团队 | iOS 内存管理研究</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Czm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/25/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/">http://yoursite.com/2020/05/25/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Czm</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"><i class="fa fa-chevron-left">  </i><span>hexo搭建博客</span></a></div><div class="next-post pull-right"><a href="/2020/05/20/XCTest/"><span>XCTest</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Czm</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>